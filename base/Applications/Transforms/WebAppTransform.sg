///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Research Singularity
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Creates startup boilerplate code from Resource descriptions for processes started by cassini.
//

using Microsoft.SingSharp;
using Microsoft.Contracts;
using Microsoft.Singularity;
using Microsoft.Singularity.Channels;
using Microsoft.Singularity.Extending;
using Microsoft.Singularity.Directory;
using Microsoft.Singularity.Configuration;
using Microsoft.Singularity.V1.Services;
using System;

namespace Microsoft.Singularity.Applications
{

    transform WebAppResourceTransform
        where $EndpointType : unmanaged struct, Endpoint, ITracked
    {
        [Category(*)]
        class $Arguments
        {

            [Endpoint(*)]
            TRef<$EndpointType,$State> $$endpoints;

            [StringParameter(_, _, _)]
            string $$strings;

            [StringArrayParameter(_, _, _)]
            string[] $$stringArrays;

            [LongParameter(_, _, _)]
            long $$longs;

            [BoolParameter(_, _, _)]
            bool $$bools;

            implement private $Arguments() {
#if DEBUG
                DebugStub.WriteLine("WebAppTransform applied");
#endif

                int index;
                ParameterCode code;

                index = 0;
                forall (; $s in $$strings ;) {
                    string stringArg;
                    code = Process.GetStartupStringArg(index, out stringArg);
                    if (code != ParameterCode.Success) {
                        throw new ArgumentException(String.Format("error acquiring startup string array {0}. code={1}", index, code));
                    }
                    this.$s = stringArg;
                    //DebugStub.WriteLine("got string {0}=({1})",__arglist(index, $s));
                    ++index;
                }

                index = 0;
                forall (; $sa in $$stringArrays ;) {
                    string[] stringArrayArg;
                    code = Process.GetStartupStringArrayArg(index, out stringArrayArg );
                    if (code != ParameterCode.Success) {
                        throw new ArgumentException(String.Format("error acquiring startup string {0}. code={1}", index, code));
                    }
                    this.$sa = stringArrayArg;
                    //DebugStub.WriteLine("got string {0}=({1})",__arglist(index, $s));
                    ++index;
                }

                index = 0;
                forall (; $l in $$longs ;) {
                    long longArg;
                    code = ProcessService.GetStartupLongArg(index, out longArg);
                    if (code != ParameterCode.Success) {
                        throw new ArgumentException(String.Format("error acquiring startup integer {0}. code={1}", index, code));
                    }
                    this.$l = longArg;
                    //DebugStub.WriteLine("got long {0}=({1})",__arglist(index, $l));
                    ++index;
                }

                index = 0;
                forall (; $b in $$bools ;) {
                    bool b;
                    code = ProcessService.GetStartupBoolArg(index, out b);
                    if (code != ParameterCode.Success) {
                        throw new ArgumentException(String.Format("error acquiring startup bool {0}. code={1}", index, code));
                    }
                    this.$b = b;
                    //DebugStub.WriteLine("got bool {0}=({1})",__arglist(index, b));
                    ++index;
                }
                index = 0;
                forall (; $e in $$endpoints;) {
                    $e.$EndpointType* in ExHeap opt($e.$State) ep = Process.GetStartupEndpoint(index)
                        as $e.$EndpointType* in ExHeap opt($e.$State);
                    if (ep == null) {
                        throw new ArgumentException(String.Format("missing startup endpoint {0}", index));
                    }
                    $e = new TRef<$e.$EndpointType, $e.$State> (ep);
#if DEBUG
                    DebugStub.WriteLine("getting endpoint at {0}",__arglist(index));
#endif
                    ++index;
                }
            }

            generate public static int Main() {
                $Arguments args = new $Arguments();

                return $Application.AppMain(args);
            }

        }

        class $Application
        {

            internal static int AppMain($Arguments! args);

        }
    }
}
