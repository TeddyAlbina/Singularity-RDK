<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Compiler.Framework</name>
    </assembly>
    <members>
        <member name="T:System.Compiler.Scanner">
            <summary>
            Scans individual source lines and provides coloring and trigger information about tokens.
            </summary>
        </member>
        <member name="T:System.Compiler.IScanner">
            <summary>
            Scans individual source lines and provides coloring and trigger information about tokens.
            </summary>
        </member>
        <member name="M:System.Compiler.IScanner.SetSource(System.String,System.Int32)">
            <summary>
            Used to cheaply (re)initialize the scanner before scanning a small portion of text, such as single source line for syntax coloring purposes
            </summary>
            <param name="source">The source text portion to be scanned. May not be null.</param>
            <param name="offset">The index of the first character to be scanned. Must be a valid index into source.</param>
        </member>
        <member name="M:System.Compiler.IScanner.ScanTokenAndProvideInfoAboutIt(System.Compiler.TokenInfo,System.Int32@)">
            <summary>
            Scan the next token and fill in syntax coloring details about it in tokenInfo.
            </summary>
            <param name="tokenInfo">Keeps information about token.</param>
            <param name="state">Keeps track of scanner state. In: state after last token. Out: state after current token.</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Scanner.SetSource(System.String,System.Int32)">
            <summary>
            Used to cheaply (re)initialize the scanner before scanning a small portion of text, such as single source line for syntax coloring purposes
            </summary>
            <param name="source">The source text portion to be scanned. May not be null.</param>
            <param name="offset">The index of the first character to be scanned. Must be a valid index into source.</param>
        </member>
        <member name="M:System.Compiler.Scanner.ScanTokenAndProvideInfoAboutIt(System.Compiler.TokenInfo,System.Int32@)">
            <summary>
            Scan the next token and fill in syntax coloring details about it in tokenInfo.
            </summary>
            <param name="tokenInfo">Keeps information about token.</param>
            <param name="state">Keeps track of scanner state. In: state after last token. Out: state after current token.</param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.TokenInfo">
            <summary>
            Records the source position of a token, along with information about the syntactic significance of the token.
            </summary>
        </member>
        <member name="T:System.Compiler.TokenTrigger">
            <summary>
              If token has one or more triggers associated with it, it may  fire one of the following actions when it is typed in a smart editor:
                MemberSelect - a member selection tip window
                TriggerMatchBraces - highlight matching braces
                TriggerMethodTip - a method tip window
            
              The triggers exist for speed reasons: the fast scanner determines when the slow parser might be needed. 
              The MethodTip trigger is subdivided in four other triggers. It is the best to be as specific as possible;
              it is better to return ParamStart than just Param (or just MethodTip) 
              </summary>*
        </member>
        <member name="F:System.Compiler.TokenTrigger.None">
            <summary>No editor action when this token is encountered.</summary>
        </member>
        <member name="F:System.Compiler.TokenTrigger.MemberSelect">
            <summary>Display a member selection list</summary>
        </member>
        <member name="F:System.Compiler.TokenTrigger.MatchBraces">
            <summary>Highlight a matching pair of braces or similar delimiter pairs</summary>
        </member>
        <member name="F:System.Compiler.TokenTrigger.MethodTip">
            <summary>Display semantic information when the pointer hovers over this token</summary>
        </member>
        <member name="F:System.Compiler.TokenTrigger.ParamNext">
            <summary>Display information about the method parameter corresponding to the call argument following this token</summary>
        </member>
        <member name="M:System.Compiler.TypeSystem.IsBetterMatch(System.Compiler.TypeNode,System.Compiler.TypeNode,System.Compiler.TypeNode)">
            <summary>
            Returns true if conversion from t3 to t1 exists and is better (closer) than the conversion from t3 to t2
            Call this only if both conversions exist.
            </summary>
        </member>
        <member name="M:System.Compiler.TypeSystem.IsBetterMatch(System.Compiler.TypeNode,System.Compiler.TypeNode,System.Compiler.TypeNode,System.Compiler.TypeViewer)">
            <summary>
            Returns true if conversion from t3 to t1 exists and is better (closer) than the conversion from t3 to t2
            Call this only if both conversions exist.
            </summary>
        </member>
        <member name="M:System.Compiler.TypeSystem.UnifiedType(System.Compiler.TypeNodeList,System.Compiler.TypeViewer)">
            <summary>
            Computes an upper bound in the type hierarchy for the set of argument types.
            This upper bound is a type that all types in the list are assignable to.
            If the types are all classes, then *the* least-upper-bound in the class
            hierarchy is returned.
            If the types contain at least one interface, then *a* deepest upper-bound
            is found from the intersection of the upward closure of each type.
            Note that if one of the types is System.Object, then that is immediately
            returned as the unified type without further examination of the list.
            </summary>
            <param name="ts">A list containing the set of types from which to compute the unified type.</param>
            <returns>The type corresponding to the least-upper-bound.</returns>
        </member>
        <member name="M:System.Compiler.TypeSystem.FieldReadAsNonNull(System.Compiler.CompilerOptions,System.Compiler.Field)">
            <summary>
            Hook for overriding current policy of considering field reads to return non-null values
            </summary>
        </member>
        <member name="M:System.Compiler.TypeSystem.IsCompatibleWithNull(System.Compiler.TypeNode)">
            <summary>
            Should return false if null cannot be converted to targetType.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.TypeSystem.ExplicitNonNullCoercion(System.Compiler.Expression,System.Compiler.TypeNode)">
            <summary>
            This method only handles the coercion from possibly null to non-null. It does not do any Class-Type coercions!
            </summary>
        </member>
        <member name="M:System.Compiler.TypeSystem.ImplicitNonNullCoercion(System.Compiler.ErrorHandler,System.Compiler.Expression,System.Compiler.TypeNode)">
            <summary>
            This method only performs the non-null coercion, no other type coercions
            </summary>
        </member>
        <member name="T:System.Compiler.Scoper">
            <summary>
            Walks a CompilationUnit and creates a scope for each namespace and each type.
            The scopes are attached to the corresponding instances via the ScopeFor hash table.
            </summary>
        </member>
        <member name="T:System.Compiler.Looker">
            <summary>
            Walks an IR, mutating it by replacing identifier nodes with NameBinding/Block nodes representing the
            members/labels the identifiers resolve to, and replacing type expressions with the types they refer to.
            Most of the logic here deals with maintaining and querying the scope chain.
            </summary>
        </member>
        <member name="F:System.Compiler.Looker.scopeFor">
            <summary>
            Used to track the appropriate scope for each type
            </summary>
        </member>
        <member name="M:System.Compiler.Looker.VisitBaseClassReference(System.Compiler.Class,System.Boolean)">
            <summary>
            Turns ClassExpression Class.BaseClass into a real class, with substitution of template parameters.
            Returns false if the ClassExpression does not bind to a class. 
            Passing false for interfaceIsError will suppress the generation of an error message.
            This can be used to check if the first expression in an interface list is a base class.
            </summary>
        </member>
        <member name="T:System.Compiler.Analysis.AnalyzableMethodFinder">
            <summary>
            This class is used to compute the set of potentially analyzable methods
            I used to filter out the methods in order to limit the interprocedural 
            analysis scope
            </summary>
        </member>
        <member name="T:System.Compiler.Analysis.MyCGGenerator">
            <summary>
            Instruction visitor used to build the partial call graph
            Every method call is registered 
            </summary>
        </member>
        <member name="T:System.Compiler.InstructionVisitor">
            <summary>
            Decoder for CCI statements after normalization and code flattening. Provides a view of
            instructions close to CIL (.NET CLR Partition 3 document).
            The Visit method recognizes the CCI encodings for each instruction and calls
            the appropriate Visit* method.  Subclassing <c>InstructionVisitor</c> allows writing
            visitors that deal directly with only a small set of distinct instructions and without
            recursive expressions, since arguments to all instructions are variables.
            <p/>
            To make decoding simple, some MSIL instructions are split, such as ldtoken, which was
            split into three cases: LDTYPETOKEN, LDFIELDTOKEN, LDMETHODTOKEN.
            <p/>
            On the other hand, some instructions are distinguished by <c>null</c> tests; the MSIL instructions
            "ldfld" (load object field) and "ldsfld" (load static field) are modeled by the same visitor
            LDFIELD "dest := source.field" with source being <c>null</c> for a static field. Similarly, an unconditional
            branch instruction is modelled as an BRANCH with a <c>null</c> condition.
            <p/>
            The envisioned use of this class is as follows:  subclass <c>InstructionVisitor</c> and override
            each Visit* method
            (VisitCopy, VisitLoadConstant etc.) to specify the processing that you want for each instruction.
            Given a Cci statement (normalized and flattened) stat, do the appropriate processing for it by calling 
            Visit(stat, some_arg).
            <p/>
            Visit acts as a dispatcher: it recognizes the instruction encoded by stat and calls the
            appropriate Visit* method with the right arguments.  Visit stands for a top-level transfer function:
            its second argument is the argument passed to the appropriate transfer function; its result is the
            result of that transfer function.
            <p/>
            NOTE: With generics, we would have defined InstructionVisitor as Visitor&lt;A,B&gt;, where A and B
            are the argument type, respectively the result type of each transfer function.  If your transfer
            functions don't take any argument, you can pass <c>null</c>.
            Similarly, if they don't return anything, you can return <c>null</c>.
            <p/>
            See the documentation of each of the Visit* methods for more info on the format of each instruction.
            Also see the <c>SampleInstructionVisitor</c> for a full example.
            <p>
            The following conventions apply for each Visit* method:</p>
            
            <ol>
            <li>The last two arguments are the original Cci statement and the argument passed to
            Visit(Statement stat, object arg) 
            </li>
            Having the original statements allows you to attach information to it (in some hashtable) or, in rare
            cases, to look for features that are not exposed.
            <li>Each method returns an object. This is conceptually the result of the transfer function associated with
            that instruction.</li>
            <li>Each such method is called by the dispatcher Visit(Statement stat, object arg) with all arguments
            non-null, unless specified otherwise in the documentation for Visit*.</li>
            </ol>
            
            <p>
            By default, each Visit* method calls the abstract method <c>DefaultVisit</c>.</p>
            
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.Visit(System.Compiler.Statement,System.Object)">
            <summary>
            Decodes the statement and dispatches to one of the Visit methods below.
            </summary>
            <param name="stat">Visited statement.</param>
            <param name="arg">Argument for the transfer function.</param>
            <returns>Result of the appropriate transfer function.</returns>
            
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitNop(System.Compiler.Statement,System.Object)">
            <summary>
            nop -- no operation
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitMethodEntry(System.Compiler.Method,System.Collections.IEnumerable,System.Compiler.Statement,System.Object)">
            <summary>
            method entry -- a pseudo instruction that marks the beginning of a method.
            </summary>
            <param name="method">Method that starts with this instruction.</param>
            <param name="parameters">All parameters of this method, including <c>this</c> (order is important).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitUnwind(System.Compiler.Statement,System.Object)">
            <summary>
            unwind -- a pseudo instruction that marks the exceptional exit of a method. 
            <p>
            Description:
            <br/>
            This is the point where the currently thrown exception leaves the method.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitBranch(System.Compiler.Variable,System.Compiler.Block,System.Compiler.Statement,System.Object)">
            <summary>
            branch cond,target -- branch on condition.
            <p>
            Description:
            <br/>
            Branch to target block if condition is true.
            </p>
            </summary>
            <param name="cond">Condition of the branch statement; <c>null</c> for an unconditional jump.</param>
            <param name="target">Target of the branching instruction.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitSwitch(System.Compiler.Variable,System.Compiler.BlockList,System.Compiler.Statement,System.Object)">
            <summary>
            switch selector,targets -- branch to target block indexed by selector
            <p>
            Description:
            <br/>
            if <c>selector</c> is between <c>0</c> and <c>targets.Length-1</c>c>
            then branch to targets[selector]. Otherwise, fall through.
            </p>
            </summary>
            <param name="selector">Selector variable.</param>
            <param name="targets">List of targets.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitSwitchCaseBottom(System.Compiler.Statement,System.Object)">
            <summary>
            switchcasebottom -- a pseudo instruction equal to nop. Marks the end of a switch case when introduced by
            the language parser. Allows checking for fall through from one case to another.
            </summary>
            <param name="stat">The source context should point at the case.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitReturn(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            return -- return from the method
            <p>
            Description:
            <br/>
            Return the value in var from the method.
            </p>
            </summary>
            <param name="var">Variable that holds the returned value. <c>null</c> if the method return type
            is <c>void</c>.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitThrow(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            throw -- throw the exception
            </summary>
            <param name="var">Variable that holds the thrown value (never <c>null</c>).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitRethrow(System.Compiler.Statement,System.Object)">
            <summary>
            rethrow -- rethrow the currently handled exception
            <p>
            Description:
            <br/>
            Only appears within handlers. Its semantics is to rethrow the exception that the handler
            is currently processing.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCatch(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            var = catch(type) -- catch exception matching type and store in var
            <p>
            Description:
            <br/>
            Starts an exception handler and acts as the test whether the handler applies to the caught 
            exception given the type. If the exception does not apply, then control goes to the handler
            of the current block. Otherwise, control goes to the next instruction.
            </p>
            
            </summary>
            <param name="var">Variable that holds the caught exception.</param>
            <param name="type">Type of the exceptions that are caught here.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitFilter(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := filter -- pseudo instruction marking the beginning of a filter handler.
            <p>
            Description:
            <br/>
            Semantics: assigns the exception being filtered to the <c>dest</c> variable.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitEndFilter(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            endfilter code -- marks the end of the filter section of a filter handler. 
            <p>
            Description:
            <br/>
            tests the code at the end of the filter section of a filter handler. If code is 0, handler
            does not apply, and the next handler should be tried. If 1, hander applies and the next instruction
            is executed.
            
            In our encoding, if the instruction falls through, it must push the implicit exception being 
            handled onto the stack, since the next instruction is a catch of the actual handler.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadNull(System.Compiler.Variable,System.Compiler.Literal,System.Compiler.Statement,System.Object)">
            <summary>
            dest := null -- ldnull instruction, assigns null to destination.
            </summary>
            <param name="source">The <c>null</c> literal. Passed here for source context.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadConstant(System.Compiler.Variable,System.Compiler.Literal,System.Compiler.Statement,System.Object)">
            <summary>
            dest := ldc c -- store the constant c in dest
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitArgumentList(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := arglist -- (corresponds to the MSIL instruction OxFE00 arglist).
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitSizeOf(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := sizeof(T) -- store the runtime size of type T in dest
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitConstrainedCall(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.ExpressionList,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := Constraint(T).receiver.callee(arguments) -- invoke virtual method with Constrain prefix.
            </summary>
            <param name="dest">Variable that stores the result of the call. <c>null</c> if the called method
            return type is <c>void</c> or ignored.</param>
            <param name="receiver">Receiver of the virtual call. Note that the behavior of this instruction depends on the
            type of the receiver in the generic instance:
            The receiver must have a reference type ref P. If the instance of P is a struct type, then the code becomes
              st0 = box(receiver, T);
              st0.callee(arguments);
              
            If the instance of P is a reference type (class or interface), then we simply load the indirect pointer contents:
              st0 = *receiver;
              st0.callee(arguments);
            <br/>
            </param>
            <param name="callee">Compile-time called method; the method that is actually invoked might be different
            in the case of a dynamically dispatched call.</param>
            <param name="arguments">Call arguments; does not include the value for the "this" argument; that value is
            the given by the receiver (if any). All elements of this list are Variables.</param>
            <param name="constraint">The type constraint of the receiver</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCopy(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := source -- variable to variable assignment
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitNewObject(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := new T -- allocate a new object of type T. DOES NOT INCLUDE .CTOR CALL, see below.
            
            Called for a new expression. Note that MSIL newobj instructions are broken into 3 steps:
            1. A separate allocation (this method)
            2. A separate constructor call (normal call)
            3. A separate assignment of the newly allocated object to the intended target variable.
            
            </summary>
            <param name="dest">Temporary to hold raw allocation result</param>
            <param name="type">Object type to be allocated</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitNewArray(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := new T[size] -- allocate a new array of the given size and type
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCall(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.ExpressionList,System.Boolean,System.Compiler.Statement,System.Object)">
            <summary>
            dest := receiver.callee(arguments) -- invoke method 
            </summary>
            <param name="dest">Variable that stores the result of the call. <c>null</c> if the called method
            return type is <c>void</c>.</param>
            <param name="receiver">Receiver for virtual calls. <c>null</c> in the case of a static call
            (warning: static call and call to a static method different things: you can call a virtual method
            without using dynamic dyspatch).
            <br/>
            If the <c>callee</c> is a member of a value type T, <c>receiver</c> is of type T&amp; (reference to T).
            </param>
            <param name="callee">Compile-time called method; the method that is actually invoked might be different
            in the case of a dynamically dispatched call.</param>
            <param name="arguments">Call arguments; does not include the value for the "this" argument; that value is
            the given by the receiver (if any). All elements of this list are Variables.</param>
            <param name="virtcall">Indicates whether this is a dynamically dispatched call or not.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCallIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable[],System.Compiler.FunctionPointer,System.Compiler.Statement,System.Object)">
            <summary>
            dest := (*callee)([receiver], arguments) -- call indirect function pointer.
            </summary>
            <param name="dest">Variable that stores the result of the call. <c>null</c> if the called method
            return type is <c>void</c>.</param>
            <param name="callee">Function pointer value.</param>
            <param name="receiver">Receiver for virtual calls. <c>null</c> in the case of a static call
            (warning: static call and call to a static method are different things: you can call a virtual method
            without using dynamic dispatch).</param>
            <param name="arguments">Call arguments; does not include the value for the "this" argument; that value is
            the given by the receiver (if any). All elements of this list are Variables.</param>
            <param name="fp">Function pointer signature.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitBinaryOperator(System.Compiler.NodeType,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := operand1 op operand2 -- assign result of binary operation to dest
            </summary>
            <param name="op">Binary operator (e.g. NodeType.Add).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitUnaryOperator(System.Compiler.NodeType,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := op operand -- assign result of unary operation to dest.
            </summary>
            <param name="op">Unary operator.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCastClass(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := (T)source -- cast object source to type T and assign result to dest.
            <p>
            Description:
            <br/>
            if type of source is a subtype of <c>type</c>, then assign source to dest;
            otherwise throw a <c>System.InvalidCastException</c>.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitIsInstance(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := source as T -- istest instruction.
            <p>
            Description:
            <br/>
            If type of source is a subtype of T, assign source to dest; otherwise assign <c>null</c> to dest.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitBox(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := box(T) source -- box source object of type T.
            <p>
            Description:
            <br/>
            If boxable (T is a value type or type parameter), boxes the source value int a fresh object and assigns
            result to dest. If T is an object type, it acts as a no-op.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitUnbox(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := unbox(T) source -- convert boxed value type to its raw (value) form
            <p>
            Description:
            <br/>
            The instruction first checks that source is not null, otherwise throws NullReferenceException. Then it checks
            that the boxed value actually contains a value of type T, otherwise InvalidCastException is thrown.
            Finally, it copies a pointer of type T&amp; (reference to value type) into dest that points at the box 
            contents.
            </p>
            </summary>
            <param name="type">Value type of the contents expected in the boxed value.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitUnboxAny(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := unbox.any(T) source -- convert object to type T.
            <p>
            Description:
            <br/>
            <ul>
            <li>
            If <c>T</c> is a value type, extracts the value from the boxed object <c>source</c> and assigns it to <c>dest</c>. 
            In this case, the instruction acts like <c>unbox</c> followed by <c>ldobj</c>.
            </li>
            <li>
            If <c>T</c> is an object type, the instruction acts like castclass.
            </li>
            <li>
            If <c>T</c> is a type parameter, the instruction behaves dependent on the actual runtime type bound to T. 
            </li>
            </ul>
            </p>
            </summary>
            <param name="source">Object to unbox</param>
            <param name="type">Target type of the unbox.any.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadField(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Statement,System.Object)">
            <summary>
            dest := source.field -- load field and assign to destination.
            <p>
            Description
            <br/>
            This instruction covers the cases of instance AND static field read instructions. If source is null, the field
            is static, otherwise it is an instance field.
            
            In the case where the field is a member of a value type T, then source is of type T&amp; (reference to T).
            </p>
            </summary>
            <param name="source">Variable that points to the object whose field we read.
            <c>null</c> if <c>field</c> is static.</param>
            <param name="field">Loaded field (can be a static one).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitStoreField(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest.field := source -- store source into field.
            <p>
            Description:
            <br/>
            This instruction covers the cases of instance AND static field store instructions. If dest is null, the field
            is static, otherwise it is an instance field.
            
            In the case where the field is a member of a value type T, then dest is of type T&amp; (reference to T).
            </p>
            </summary>
            <param name="dest">Variable that points to the object whose field we write. <c>null</c> if
            <c>field</c> is static.</param>
            <param name="field">Written field.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := source[index] -- load element from array
            </summary>
            <param name="source">Variable that points to the array whose element we read.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitStoreElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest[index] := source -- store array element
            </summary>
            <param name="dest">Variable that points to the array whose element we write.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := &amp; source -- load address of local variable and store into dest.
            </summary>
            <param name="source">Variable whose address is taken.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadFieldAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Statement,System.Object)">
            <summary>
            dest := &amp; source.field -- load address of field and store into dest.
            <p>
            Description:
            <br/>
            The instruction covers both instance and static fields. For static fields, source is null.
            
            For fields of reference type T, source is of type T&amp; (reference to T).
            </p>
            </summary>
            <param name="source">Variable pointing to the object that contains <c>field</c>; may be
            <c>null</c> is <c>field</c> is static.</param>
            <param name="field">Field whose address we load (may be static).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadElementAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := &amp; array[index] -- load address of array element and store into dest.
            <p>
            Description:
            <br/>
            Takes the address of the array element indexed and stores it into dest.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := *((type *) pointer) -- load value stored at pointer and assign to dest
            <p>
            MSIL instructions: ldind.T, ldobj
            <br/>
            </p>
            </summary>
            <param name="type">Type of the loaded value.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitStoreIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            *((type *) pointer) := source -- store value at pointer
            <p>
            MSIL instructions: stind.T, stobj
            </p>
            </summary>
            <param name="type">Type of the stored value.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadFunction(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.Statement,System.Object)">
            <summary>
            dest := &amp;source.method -- load method pointer and store into dest.
            <p>
            Description:
            <br/>
            loads the address where a method code starts. This instruction covers both
            ldftn and ldvirtftn: for ldvirtftn, the dynamic dispatch algorithm is used to find
            the appropriate method.
            
            For static functions, source is null.
            </p>
            </summary>
            <param name="source">Address of the object whose dynamically-dispatched method we are
            interested in.</param>
            <param name="method">If <c>source</c> is <c>null</c>, then the address of this method is loaded,
            otherwise, we load the address of the method that is invoked by a call to source.method.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadToken(System.Compiler.Variable,System.Object,System.Compiler.Statement,System.Object)">
            <summary>
            dest := ldtoken token -- load meta data token (type, method, or field) and store into dest.
            </summary>
            <param name="token">TypeNode / Field / Method whose metadata token is assigned to <c>dest</c>.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCopyBlock(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            memcpy(destaddr, srcaddr, size) -- cpblk instruction, copies data from memory to memory
            </summary>
            <param name="destaddr">Variable that stores the start address of the destination memory area.</param>
            <param name="srcaddrs">Variable that stores the start address of the source memory area.</param>
            <param name="size">Variable that stores the number of bytes to copy.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitInitializeBlock(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            initblk addr, value, size -- initblk instruction, initializes memory to a value
            </summary>
            <param name="addr">Variable that stores the start address of the memory area to be initialized.</param>
            <param name="val">Variable that stores the "unsigned int8" value that will be stored in each
            memory byte.</param>
            <param name="size">Variable that stores the number of bytes to initialize.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitInitObj(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            *dest := initobj T -- initobj instruction, assigns a default value to dest.
            <p>
            Description:
            <br/>
            dest is managed or unmanaged pointer to T. If T is a value type, this instruction initializes each field of T
            to its default value or zero for primitive types.
            If T is an object type, this instruction has the same effect as <c>ldnull</c> followed by <c>stind</c>.
            </p>
            </summary>
            <param name="addr">The pointer to the value type to be initialized. Is either Struct or EnumNode</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitBreak(System.Compiler.Statement,System.Object)">
            <summary>
            break -- debugger break instruction, causes the execution to transfer control to a debugger.
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitMakeRefAny(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := mkrefany source,type -- assign typed reference to dest 
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitRefAnyValue(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := refanyval source,type -- load the address out of a typed reference
            <p>
            Description:
            <br/>
            Throws <c>InvalidCastException</c> if typed reference isn't of type <c>type</c>. If it is
            extracts the object reference and stores it in dest.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitRefAnyType(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := refanytype source --- extracts the type from a typed reference and assigns it to dest.
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.DefaultVisit(System.Compiler.Statement,System.Object)">
            <summary>
            Default visitor called by each non-overridden visitor above.
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.GetReceiverAndCallee(System.Compiler.MethodCall,System.Compiler.Variable@,System.Compiler.Method@,System.Compiler.FunctionPointer@)">
            <summary>
            Unscrambles a method target. 
            </summary>
            <param name="call">The method call node to unscramble</param>
            <param name="receiver">Returns the receiver expression. Maybe null.</param>
            <param name="callee">Returns the method, if target is a method, otherwise null.</param>
            <param name="fpointer">Returns the function pointer if target is a function pointer, otherwise null.</param>
        </member>
        <member name="T:System.Compiler.Analysis.CGGenerator">
            <summary>
            Small dataflow traversal. Just for building the 
            partial callgraph.
            Not exception support
            </summary>
        </member>
        <member name="T:System.Compiler.ForwardDataFlowAnalysis">
            <summary>
            Implements a pretty standard data flow analysis with merging of data flow states at join
            points. 
            
            Details:
            
            At each block, we maintain two data flow states, pending, and done. Done represents the 
            dataflow state under which the block has already been analyzed, whereas Pending represent
            the state under which the block still needs to be analyzed.
            
            When a block is reached with a state, it is merged into the pending state. This merge can
            either be precise, or with weakening (includes now more possibilities than the two states
            that were merged).
            
            Once a block is dequeued for analysis, we compute the new done state, which is the merge
            of the pending state with the	old done state. There are 3 possible outcomes:
            1. The old done state completely supersedes the new pending state: no reanalysis is necessary
            2. The merge is precise, then the block needs to be analyzed only with the pending state 
               (no need to redo all cases in the done state). 
            3. The merge is imprecise (contains more possibilities than in either the pending or the old 
               done state), then we need to analyze the block using this merged state in order to account
               for these new possibilities.
              
            Another imprecision arises from the merge of pending states. This merge could be imprecise, and
            therefore at the next analysis, we could be analyzing the block under extra cases. Buckets could
            be used to avoid this. Buckets just increase the language of formulas for expressing fixpoints to
            a finite disjunction.
            
            Each block can be in one of 3 states:
            a) unenabled (block needs to be reached by more edges before we run it)
            b) enabled and in work queue (needs to be rescheduled)
            c) enabled but has been processed with latest incoming states.
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.PopPendingState(System.Compiler.CfgBlock)">
            <summary>
            Like PendingState returns the pending state for the given block, but
            it also sets the pending state for this block to null.
            </summary>
            <returns>old pending state</returns>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.JoinWithPendingState(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Merge the new pending state with the old pending states.
            </summary>
            <returns>merged pending state</returns>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.StateToReanalyzeBlock(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState,System.Boolean@)">
            <summary>
            Checks if a block needs to be reanalyzed and under what state.
            
            Updates the doneState of this block to reflect the pending state
            </summary>
            <returns>null if no reanalysis necessary, the DFS state if the merge is precise,
            the merged state if the merge is imprecise
            </returns>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.Run(System.Compiler.ControlFlowGraph,System.Compiler.IDataFlowState)">
            <summary>
            Starts the analysis from the entry block of the CFG
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.Run(System.Compiler.ControlFlowGraph,System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Starts the analysis at the first instruction of the given block
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.PushExceptionState(System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Push the given state onto the handler of the block.
            This causes call-backs to SplitException in order to correctly distribute
            the exception state among different nested handlers.
            </summary>
            <param name="currentBlock">Block from which exception escapes</param>
            <param name="state">state on exception flow</param>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.PushState(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Add the given state to the pending states of the target block. If 
            the block is enabled (by the pending edge count optimization), add the
            block to the worklist.
            
            Inv: DoneState => PendingState /\ PendingState != null => InQueue
            
            Cases:
              1. Done => new, nothing to do
              2. Done |_| new is precise.  Pend' = Pend |_| new,  Done' = Done |_| new
              3. Done |_| new is imprecise.  Pend' = Done |_| new,  Done' = Done |_| new
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.VisitBlock(System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Default per block visitor. Called from Run.
            
            It calls VisitStatement on each statement in a block. 
            
            The result of this method is used as the state for all normal control flow successors.
            To push state onto an exception handler, use the PushExceptionState method. Furthermore, for
            conditional branches, different states can be pushed onto the true and false branches directly
            by calling PushPending. In that case, null should be returned from the method in order to avoid pushing
            the returned state onto both true and false targets again.
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.VisitStatement(System.Compiler.CfgBlock,System.Compiler.Statement,System.Compiler.IDataFlowState)">
            <summary>
            Default per statement visitor called from the default VisitBlock.
            Does identity transformation. Subclasses either override this method
            if the default block handling is sufficient, or they override the Visit method for blocks.
            
            The result of this method is used as the state for all normal control flow successors.
            To push state onto an exception handler, use the PushExceptionState method. Furthermore, for
            conditional branches, different states can be pushed onto the true and false branches directly
            by calling PushPending. In that case, null should be returned from the method in order to avoid pushing
            the returned state onto both true and false targets again.
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.Merge(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState,System.Compiler.IDataFlowState,System.Boolean@,System.Boolean@)">
            <summary>
            Compute the join of two data flow states at the given block.
            </summary>
            <param name="previous">Predecessor block for this new state</param>
            <param name="joinPoint">Block at which join is computed</param>
            <param name="atMerge">Old state at this block. Can be null, in which case the incoming state
            is the first non-bottom state. In this case, the method must set changed
             <c>resultDiffersFromPreviousMerge</c> to true.</param>
            <param name="incoming">New data flow state flowing to this block.</param>
            <param name="resultDiffersFromPreviousMerge">Boolean for fix point. If the state after
            the merge is equal to the old <c>atMerge</c> state, set to false, otherwise set to true.</param>
            <param name="mergeIsPrecise">can be set to true if the merged result state strictly contains only
            information representing either the atMerge or the incoming state, but no extra approximation. If
            this information cannot be determined by the merge, it must return false. True can only be returned
            if result is truly precise.</param>
            <returns>The new merged state.</returns>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.SplitExceptions(System.Compiler.CfgBlock,System.Compiler.IDataFlowState@,System.Compiler.IDataFlowState@)">
            <summary>
            Splits the exceptions into the ones that this handler will handle and the ones that should
            <code>currentHandlerState</code> and <code>nextHandlerState</code> cannot both be null.
            On exit, if <code>currentHandlerState</code> is null, <code>handler</code> handles no exceptions,
            and if <code>nextHandlerState</code> is null, <code>handler</code> handles all the exceptions in
            the initial exception set of <code>currentHandlerState</code>.
            </summary>
        </member>
        <member name="T:System.Compiler.ForwardDataFlowAnalysis.WorkQueue">
            <summary>
            Elements can only be once on this queue. Duplicates are removed.
            </summary>
        </member>
        <member name="T:System.Compiler.PriorityQueue">
            <summary>
            Implements a work list as a priority queue
            </summary>
        </member>
        <member name="M:System.Compiler.Analysis.CGGenerator.VisitStatement(System.Compiler.CfgBlock,System.Compiler.Statement,System.Compiler.IDataFlowState)">
            <summary>
            Visit the statement. It calls the instruction visitor to perform the transfer function
            </summary>
            <param name="block"></param>
            <param name="statement"></param>
            <param name="dfstate"></param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.UnknownInstructionException">
            <summary>
            Exception thrown when an unknown quad is encountered.
            </summary>
        </member>
        <member name="T:System.Compiler.SampleInstructionVisitor">
            <summary>
             Example use of <c>QuadVisitor</c>.  Generates an appropriate string representation
             for each quad.
            </summary>
        </member>
        <member name="M:System.Compiler.SampleInstructionVisitor.GetStringDesc(System.Compiler.Statement)">
            <summary>
            Returns a string representation for each quad.  Throws an exception when encountering
            an unknown quad or an unknown CciHelper pattern.
            </summary>
            <param name="stat"></param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.IStronglyConnectedComponent">
            <summary>
            Interface for Strongly Connected Methods.
            </summary>
        </member>
        <member name="M:System.Compiler.IStronglyConnectedComponent.FullToString">
            <summary>
            Detailed text representation of <c>this</c> StronglyConnectedComponent.
            <c>ToString</c> will return just a unique text id of the StronglyConnectedComponent,
            while the detailed text representation will be produced by
            <c>FullToString</c>
            </summary>
            <returns></returns>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.Nodes">
            <summary>
            Returns the nodes contained into <c>this</c> StronglyConnectedComponent.
            </summary>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.Size">
            <summary>
            Returns the number of nodes in <c>this</c> StronglyConnectedComponent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.NextComponents">
            <summary>
            Returns the SCCs that are end points of the arcs that starts in
            <c>this</c> StronglyConnectedComponent, i.e., the successors of <c>this</c> StronglyConnectedComponent in the
            component graph. Does not contain <c>this</c> StronglyConnectedComponent.
            </summary>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.PreviousComponents">
            <summary>
            Returns the SCCs that are starting points for arcs that end
            in <c>this</c> StronglyConnectedComponent, i.e., the predecessors of <c>this</c> StronglyConnectedComponent
            in the component graph. Does not contain <c>this</c> StronglyConnectedComponent.
            </summary>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.ContainsCycle">
            <summary>
            Checks whether <c>this</c> StronglyConnectedComponent is a cycle, i.e., if it has more than
            one node or it has a single node which points to itself.  The only
            StronglyConnectedComponent that does not contain a cycle is a StronglyConnectedComponent composed of a single node
            which doesn't point to itself.
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.StronglyConnectedComponent">
            <summary>
            StronglyConnectedComponent is a full implementation of the interface <c>ISCC</c>.
            It comes with a producer static method that constructs the
            component graph for a given graph. 
            </summary>
        </member>
        <member name="M:System.Compiler.StronglyConnectedComponent.FullToString">
            <summary>
            Detailed text representation of <c>this</c> StronglyConnectedComponent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.StronglyConnectedComponent.ToString">
            <summary>
            Simplified text representation for debug purposes: "StronglyConnectedComponent" + numeric id.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.StronglyConnectedComponent.ConstructSCCs(System.Collections.IEnumerable,System.Compiler.IGraphNavigator)">
            <summary>
            Use the <c>nav</c> navigator to explore the graph rooted in the
            objects from the <c>roots</c> set, decomposes it into strongly
            connected components. Returns the set of strongly connected components.
            </summary>
        </member>
        <member name="T:System.Compiler.PointsToAnalysis">
            <summary>
            The main analysis class. Entry point to analyze a method, an assembly or 
            a compilation unit.
            At construction time, you can define if the analysis is inter-procedural or only
            intra-procedural. If you choose inter-procedural, you can choose a fix-point 
            based approach, using a backward traversal over a partial call-graph, or an inlining
            simulation (by selecting a maximun call-stack depth).
            The analysis has 2 modes of operation: StandAlone or inside CCI or Boogie.
            The main diference is that in standalone mode, it tries to analyze all methods it finds in the assembly.
            In the other case, it only analyzes the methods annotated as [pure] or [confined]. 
            The purpose of the StandAlone mode is INFERENCE. The other mode is VERIFICATION.
            </summary>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.#ctor(System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Constructor with a given Node. 
            We used to compute the set of nodes in this node and (optionally) bound the set of 
            analyzable methods in the interprocedural analysis
            </summary>
            <param name="t"></param>
            <param name="node"></param>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.#ctor(System.Compiler.Analyzer,System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Same constructor but with the analyzer
            </summary>
            <param name="analyzer"></param>
            <param name="t"></param>
            <param name="node"></param>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.VisitTypeNode(System.Compiler.TypeNode)">
            <summary>
            We can filter a Node if we don't want to analyze it. 
            For the stand alone application...
            </summary>
            <param name="typeNode"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.VisitClass(System.Compiler.Class)">
            <summary>
            Idem previous
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.WholeProgramAnalysis">
            <summary>
            Entry point to analyze a given method. 
            Depending of the type of analysis a call to this method
            can lead to a fixpoint computation, the use of a precomputed
            intraprocedural analysis or performing the intraprocedural 
            analysis for the first time
            </summary>
            <param name="method"></param>
            <returns></returns>
            
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.FixPoint">
            <summary>
            Perform a fixpoint computation over a ser of methods (in general a strongly connected component).
            It perform the interprocedural analysis for each method, reanalysing any callers that require updating. 
            </summary>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.AnalysisResultsChanges(System.Compiler.Method,System.Compiler.PointsToState)">
            <summary>
            Check whether dataflow analysis changes or not
            </summary>
            <param name="m"></param>
            <param name="newResult"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.AnalyzeMethod(System.Compiler.Method)">
            <summary>
            Analyze a given method.
            That is, perform the IntraProdecural Dataflow Analysis
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.WasAnalyzed(System.Compiler.Method)">
            <summary>
            Determines if the method was analyzed 
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.IsAnalyzable(System.Compiler.Method)">
            <summary>
            Determines whether the method is analyzable or not
            for interProc call.
            That is, if we can get the method body 
            (not abstract, not interface, under our desired analysis scope)
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToAnalysis.solveMethodTemplate(System.Compiler.Method)">
            <summary>
            Get the method's template if it has it
            </summary>
            <param name="callee"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analysis.ObjectConsistencyAnalysis.#ctor(System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Constructor with a given Node. 
            We used to compute the set of nodes in this node and (optionally) bound the set of 
            analyzable methods in the interprocedural analysis
            </summary>
            <param name="t"></param>
            <param name="node"></param>
        </member>
        <member name="M:System.Compiler.Analysis.ObjectConsistencyAnalysis.#ctor(System.Compiler.Analyzer,System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Same constructor but with the analyzer
            </summary>
            <param name="analyzer"></param>
            <param name="t"></param>
            <param name="node"></param>
            
        </member>
        <member name="T:System.Compiler.MathematicalLattice.Element">
            <summary>
             An element of the lattice.  This class should be derived from in any
             implementation of MathematicalLattice.
            </summary>
        </member>
        <member name="M:System.Compiler.MathematicalLattice.AtMost(System.Compiler.MathematicalLattice.Element,System.Compiler.MathematicalLattice.Element)">
            <summary>
            Returns true if a &lt;= this.
            </summary>
        </member>
        <member name="T:System.Compiler.MathematicalLattice.Element">
            <summary>
             An element of the lattice.  This class should be derived from in any
             implementation of MathematicalLattice.
            </summary>
        </member>
        <member name="F:System.Compiler.PointsToState.pointsToGraph">
            <summary>
            This is the Semilattice
            A PointsToGraph, the WriteEffects and the non-analyzed calls
            </summary>
        </member>
        <member name="F:System.Compiler.PointsToState.methodAssumptions">
            <summary>
             Assumptions made when analyzing virtual calls
            </summary>
        </member>
        <member name="F:System.Compiler.PointsToState.method">
            <summary>
            Method under analysis (MUA)
            </summary>
        </member>
        <member name="M:System.Compiler.PointsToState.Join(System.Compiler.PointsToState)">
            <summary>
             Join two PointsToAndWriteEffects
            </summary>
            <param name="ptgWe"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.Includes(System.Compiler.PointsToState)">
            <summary>
             Inlusion check for two PointsToAndWriEffects
            </summary>
            <param name="ptgWe"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.InitMethod(System.Compiler.Method,System.Collections.IEnumerable,System.Compiler.Label)">
            <summary>
            Transfer function for the Method Header
            </summary>
            <param name="method"></param>
            <param name="parameters"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyAssignNull(System.Compiler.Variable)">
            <summary>
            f(v1 = null, cState), operation only over the pointsToGraph 
            </summary>
            <param name="v1"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ForgetVariable(System.Compiler.Variable)">
            <summary>
            Represent when the value of a variable is not longer valid
            This means losing information about which nodes v1 points to
            </summary>
            <param name="v1"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.CopyLocVar(System.Compiler.Variable,System.Compiler.Variable)">
            <summary>
            A more complex copy operation
            f(v1 = v2), operation only over the pointsToGraph
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.CopyLocVar(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1 = v2), operation only over the pointsToGraph
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyNewStatement(System.Compiler.Variable,System.Compiler.Label,System.Compiler.TypeNode)">
            <summary>
            f(new Type, cState) , operation only over the pointsToGraph
            </summary>
            <param name="v"></param>
            <param name="lb"></param>
            <param name="type"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyStoreField(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1.f = v2), operates over the pointsToGraph and register the writeEffect
            </summary>
            <param name="v1"></param>
            <param name="f"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyStoreElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1[.] = v2), operates over the pointsToGraph and register the writeEffect
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyStaticStore(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
            f(C.f = v2), operates over the pointsToGraph and register the writeEffect
            </summary>
            <param name="v2"></param>
            <param name="f"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyLoadField(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
            f(v1 = v2.f), operates over the pointsToGraph and register the read effect
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="f"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyLoadElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1 = v2[.]), operates over the pointsToGraph and register the read effect 
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyLoadStatic(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
            f(v1 = C.f), operates over the pointsToGraph 
            </summary>
            <param name="v1"></param>
            <param name="f"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyLoadAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
             f(v1 = &amp;v2)
            </summary>
            <param name="dest"></param>
            <param name="src"></param>
            <param name="lb"></param>
            
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyLoadIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1 = *v2), operation only over the pointsToGraph
            // I take it as dest = * pointer
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyStoreIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            A more complex copy operation
            f(*v1 = v2, operation only over the pointsToGraph
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyLoadFieldAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
             f(v1 = &amp; v2.f)
            </summary>
            <param name="dest"></param>
            <param name="src"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyLoadStaticFieldAddress(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
             f(v1 = &amp; C.f).  
            </summary>
            <param name="dest"></param>
            <param name="src"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyNonAnalyzableCall(System.Compiler.Variable,System.Compiler.Method,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.Label)">
            <summary>
            Register effect of the non-analyzable call in the pointsToGraph inferring the information from the callee annotations
            </summary>
            <param name="vr"></param>
            <param name="callee"></param>
            <param name="receiver"></param>
            <param name="arguments"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyAnalyzableCall(System.Compiler.Variable,System.Compiler.Method,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.PointsToState,System.Compiler.Label,System.Compiler.InterProcMapping@)">
            <summary>
            Apply the inter-procedural analysis, binding information from caller and callee
            </summary>
            <param name="vr"></param>
            <param name="callee"></param>
            <param name="receiver"></param>
            <param name="arguments"></param>
            <param name="calleecState"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.ApplyReturn(System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(return v, cState), only has effect in the pointsToGraph
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:System.Compiler.PointsToState.Dump">
            <summary>
            Display the cState
            </summary>
        </member>
        <member name="M:System.Compiler.Analysis.ConsistencyState.Join(System.Compiler.PointsToState)">
            <summary>
             Join two PointsToAndWriteEffects
            </summary>
            <param name="ptgWe"></param>
        </member>
        <member name="M:System.Compiler.Analysis.ConsistencyState.Includes(System.Compiler.PointsToState)">
            <summary>
             Inclusion check for two PointsToAndWriteEffects
            </summary>
            <param name="ptgWe"></param>
        </member>
        <member name="T:System.Compiler.Analysis.ConsistencyState.ConsistencyLattice.AVal">
            <summary>
            Ordering:
            
              A lt B   iff
              
              !A.NonNull implies !B.NonNull
              
            </summary>
        </member>
        <member name="T:System.Compiler.ElementFactory">
            <summary>
            Represents the pointsTo and the write effects of the current block
            That is cState = &lt; PtGraph , WriteEffecs , NonAnalyzableCalls &gt; 
            It is a semilattice (bottom , &lt;=)
            </summary>
        </member>
        <member name="T:System.Compiler.PointsToInferer">
            <summary>
            The dataflow analysis for the method under analysis 
            </summary>
        </member>
        <member name="F:System.Compiler.PointsToInferer.pointsToStateAnalysys">
            <summary>
            A reference to the Main Analysis class
            To get information about other methods under analysis
            </summary>
        </member>
        <member name="M:System.Compiler.PointsToInferer.#ctor(System.Compiler.TypeSystem,System.Compiler.PointsToAnalysis)">
            <summary>
            Constructor
            </summary>
            <param name="t"></param>
            <param name="pta"></param>
        </member>
        <member name="M:System.Compiler.PointsToInferer.ComputePointsToStateFor(System.Compiler.Method)">
            <summary>
            Compute the Dataflow analysis for the given method
            Returns true if the method is pure
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInferer.VisitStatement(System.Compiler.CfgBlock,System.Compiler.Statement,System.Compiler.IDataFlowState)">
            <summary>
            Visit the statement. It calls the instruction visitor to perform the transfer function
            </summary>
            <param name="block"></param>
            <param name="statement"></param>
            <param name="dfstate"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInferer.Merge(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState,System.Compiler.IDataFlowState,System.Boolean@,System.Boolean@)">
            <summary>
            Merge two cState
            </summary>
            <param name="previous"></param>
            <param name="joinPoint"></param>
            <param name="atMerge"></param>
            <param name="incoming"></param>
            <param name="resultDiffersFromPreviousMerge"></param>
            <param name="mergeIsPrecise"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInferer.SplitExceptions(System.Compiler.CfgBlock,System.Compiler.IDataFlowState@,System.Compiler.IDataFlowState@)">
            <summary>
            Exception management
            Need Checking!
            </summary>
            <param name="handler"></param>
            <param name="currentHandlerState"></param>
            <param name="nextHandlerState"></param>
        </member>
        <member name="P:System.Compiler.PointsToInferer.ExitState">
            <summary>
            Return the results of the analysis on exit of the CFG
            </summary>
        </member>
        <member name="M:System.Compiler.Analysis.ObjectConsistencyInferer.ComputeExposureFor(System.Compiler.Method)">
            <summary>
            Compute the Dataflow analysis for the given method
            Returns true if the method is pure
            </summary>
            <param name="method"></param>
            <returns></returns>
            
        </member>
        <member name="P:System.Compiler.Analysis.ObjectConsistencyInferer.ExposureState">
            <summary>
            Return the results of the analysis on exit of the CFG
            </summary>
        </member>
        <member name="T:System.Compiler.Analysis.ObjectConsistencyInstructionVisitor">
            <summary>
            Instruction visitor. Implement the transfer function of the dataflow analysis
            It is exactly the same as the points to analysis
            </summary>
        </member>
        <member name="T:System.Compiler.PointsToInstructionVisitor">
            <summary>
            Instruction visitor. Implement the transfer function of the dataflow analysis
            </summary>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.#ctor(System.Compiler.PointsToInferer)">
            <summary>
            Constructor
            </summary>
            <param name="pta"></param>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitCallIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable[],System.Compiler.FunctionPointer,System.Compiler.Statement,System.Object)">
            <summary>
            We treat this kind of call as non analyzable
            Not support for Function Pointers Yet
            </summary>
            <param name="dest"></param>
            <param name="callee"></param>
            <param name="receiver"></param>
            <param name="arguments"></param>
            <param name="fp"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitCall(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.ExpressionList,System.Boolean,System.Compiler.Statement,System.Object)">
            <summary>
            Visit a call statement. 
            It also wraps  set_item (a[i]=...) and get_item (dest = a[i])
            </summary>
            <param name="dest"></param>
            <param name="receiver"></param>
            <param name="callee"></param>
            <param name="arguments"></param>
            <param name="virtcall"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitConstrainedCall(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.ExpressionList,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            The treat VisitConstrainedCall as a Std call
            Can be improved...
            </summary>
            <param name="dest"></param>
            <param name="receiver"></param>
            <param name="callee"></param>
            <param name="arguments"></param>
            <param name="constraint"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.TryAnalyzeCallee(System.Compiler.PointsToState,System.Compiler.Variable,System.Compiler.Method,System.Compiler.Method,System.Boolean,System.Compiler.Label,System.Collections.Generic.Set{System.Compiler.PointsToState}@)">
            <summary>
            Determine if the callee method is analyzable
            or pure and gets or compute the callee dataflow information 
            </summary>
            <param name="callercState"></param>
            <param name="receiver"></param>
            <param name="callee"></param>
            <param name="caller"></param>
            <param name="isVirtualCall"></param>
            <param name="lb"></param>
            <param name="calleecState"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitCopy(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Visitor for copy statements dest = source
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitLoadField(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Statement,System.Object)">
            <summary>
            Visitor for load field, it computes different values for static and instance fields
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="field"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitStoreField(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Visitor for store field, it computes different values for static and instance fields
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="field"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitLoadElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Visitor for dest = source[index]. 
            In this case very similar to load field
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="index"></param>
            <param name="elementType"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitStoreElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Visitor for dest[index] = source
            In this case, veru similar to store field
            </summary>
            <param name="dest"></param>
            <param name="index"></param>
            <param name="source"></param>
            <param name="elementType"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitNewObject(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Visitor for dest = new type
            </summary>
            <param name="dest"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitNewArray(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Visitor for dest = new type[]
            </summary>
            <param name="dest"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitInitObj(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Visitor for init *addr
            </summary>
            <param name="dest"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitLoadConstant(System.Compiler.Variable,System.Compiler.Literal,System.Compiler.Statement,System.Object)">
            <summary>
            dest = conts. dest doesn't point to an object
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitBinaryOperator(System.Compiler.NodeType,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest = op1 op op2.  dest doesn't point to an object
            </summary>
            <param name="op"></param>
            <param name="dest"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitMethodEntry(System.Compiler.Method,System.Collections.IEnumerable,System.Compiler.Statement,System.Object)">
            <summary>
            We record the method entry
            </summary>
            <param name="method"></param>
            <param name="parameters"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitUnwind(System.Compiler.Statement,System.Object)">
            <summary>
            Unwind. No action performed. IT IS OK??
            </summary>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitUnaryOperator(System.Compiler.NodeType,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest = op op1.  dest doesn't point to an object
            </summary>
            <param name="op"></param>
            <param name="dest"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitSizeOf(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest = sizeof type.  dest doesn't point to an object
            </summary>
            <param name="op"></param>
            <param name="dest"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitIsInstance(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := source as T. We assume it as a copy
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitCastClass(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest = (type) source. Assumed as a copy
            Have to deal with Exception???
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitBox(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Box We assume it as a copy
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitUnbox(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Box We assume it as a copy
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitRefAnyType(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := refanytype source --- extracts the type from a typed reference and assigns it to dest.
            A type is not a reference, so we forget dest
            </summary>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitMakeRefAny(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := refanyval source,type -- load the address out of a typed reference
            Assumed as Copy.
            HAVE TO DEAL with exceptions
            <p>
            Description:
            <br/>
            Throws <c>InvalidCastException</c> if typed reference isn't of type <c>type</c>. If it is
            extracts the object reference and stores it in dest.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitLoadFunction(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.Statement,System.Object)">
            <summary>
            We assumed the function as something we don't track
            We forget the value of dest
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="method"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitCatch(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            var = catch(type) -- catch exception matching type and store in var
            <p>
            Description:
            <br/>
            Starts an exception handler and acts as the test whether the handler applies to the caught 
            exception given the type. If the exception does not apply, then control goes to the handler
            of the current block. Otherwise, control goes to the next instruction.
            </p>
            We forget the value of var
            SHOULD DO SOMETHING WITH THIS!
            </summary>
            <param name="var">Variable that holds the caught exception.</param>
            <param name="type">Type of the exceptions that are caught here.</param>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitThrow(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            CHECK
            </summary>
            <param name="var"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitRethrow(System.Compiler.Statement,System.Object)">
            <summary>
            CHECK
            </summary>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitLoadIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            I take it as dest = * pointer
            </summary>
            <param name="dest"></param>
            <param name="pointer"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitStoreIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            If take it as *pointer = source
            </summary>
            <param name="pointer"></param>
            <param name="source"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitLoadAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest = &amp; source. 
            In most cases the analysis consider this a std copy
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitLoadFieldAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Statement,System.Object)">
            <summary>
            dest = &amp;(source.field). Assumed as std LoadField
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="field"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PointsToInstructionVisitor.VisitLoadElementAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest = &amp;array[index]). Assumed as std LoadElement
            </summary>
            <param name="dest"></param>
            <param name="array"></param>
            <param name="index"></param>
            <param name="elementType"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analysis.ObjectConsistencyInstructionVisitor.#ctor(System.Compiler.PointsToInferer)">
            <summary>
            Constructor
            </summary>
            <param name="pta"></param>
        </member>
        <member name="T:System.Compiler.Verifier">
            <summary>
            Walks an IR looking for preconditions that have not been satisfied
            </summary>
        </member>
        <member name="T:System.Compiler.Evaluator">
            <summary>
            Executes an IR, typically an expression tree, resulting in a literal node representing the computed value of the IR.
            This class is intended for use by a debugger expression evaluator, as well as partial evaluation (constant folding) during compilation.
            </summary>
        </member>
        <member name="T:System.Compiler.Environment">
            <summary>
            
            </summary>
        </member>
        <member name="T:System.Compiler.PureEvaluator">
            <summary>
            Has no side effects on any Cci structures, just evaluates a single node if possible.
            </summary>
        </member>
        <member name="M:System.Compiler.PureEvaluator.EvalBinaryExpression(System.Compiler.Literal,System.Compiler.Literal,System.Compiler.BinaryExpression,System.Compiler.TypeSystem)">
            <summary>
            Tries to return the literal obtained from constant folding the binary expression whose literal arguments are given
            by opnd1 and opnd2. If any of these are null, the result is null. If the binary expression cannot be constant folded
            the result is also null.
            </summary>
            <param name="opnd1">null or literal corresponding to binary expression's 1st constant folded argument</param>
            <param name="opnd2">null or literal corresponding to binary expression's 2nd constant folded argument</param>
            <param name="binaryExpression">the original binary expression</param>
            <returns>null, or constant folded literal</returns>
        </member>
        <member name="T:System.Compiler.ContractSerializer">
            <summary>
            ContractSerializer is used to write a serialized form of method and type contracts
            into custom attributes. Currently, it just creates the serialized form as a string
            which must be retrieved externally and stored in a custom attribute.
            Note that the serialization should happen before the contracts are normalized.
            Eventually, I suppose this should be called in a separate pass before Normalizer
            is called. Currently, Checker serializes each contract (and stores it in a custom
            attribute).
            </summary>
        </member>
        <member name="M:System.Compiler.ContractSerializer.VisitField(System.Compiler.Field)">
            <summary>
            Used to print the field name from a member binding, nothing more
            </summary>
        </member>
        <member name="M:System.Compiler.ContractSerializer.VisitMethod(System.Compiler.Method)">
            <summary>
            Used to print the method name, nothing more
            </summary>
        </member>
        <member name="T:System.Compiler.StackDepthVisitor">
            <summary>
            This class is meant to be used only by the StackDepthAnalysis and the
            StackRemovalTransformation: given a stack depth right before a statement,
            it walks over the statement, update the depth and calls some code transformers
            to modify the code (by default, they don't do anything, StackRemoval overrides
            them.
            </summary>
        </member>
        <member name="T:System.Compiler.ProperOrderVisitor">
            <summary>
            Subclass of the CCI <c>StandardVisitor</c> that visits the fields of statements in
            the same order that is used by the Reader.  This is important if you want to (abstractly)
            interpret some code.  Sub-expressions have side effects, hence, the order they are
            visited IS important.  Unfortunately, this cannot be part of the CCI because many projects
            rely on the semantics (if any) of the current visitor.
            </summary>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.PopTransformer(System.Compiler.Expression,System.Int32)">
            <summary>
            Override this if you want to replace a Pop expression with some other expression.
            </summary>
            <param name="expression">Expression to replace; must have type NodeType.Pop.</param>
            <param name="depth">Stack Depth right before evaluating the pop.</param>
            <returns>Any valid expression; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.DupTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Override this if you want to replace a Dup statement with some other expression.
            </summary>
            <param name="statement">Statement to replace; must be an ExpressionStatement with the type
            of the expression equal to NodeType.Dup.</param>
            <param name="depth">Stack depth right before executing the dup.</param>
            <returns>Any valid statement; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.PopExprTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Override this if you want to replace a Call(...); Pop sequence (which is modeled
            by CCI as a unary expression with operator Pop and a MethodCall as its only operand).
            </summary>
            <param name="expr_stat">ExpressionStatement to replace.</param>
            <param name="depth">Stack depth right before the push;</param>
            <returns>Any valid statement; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.PushExprTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Override this if you want to replace an [implicit] Push expression expression statement
            with something else.
            </summary>
            <param name="expr_stat">Expression to replace.</param>
            <param name="depth">Stack depth right before the expression statement.</param>
            <returns>Any valid expression; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.PopStatTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Override this if you want to replace a Pop statement with something else.
            </summary>
            <param name="expr_stat">Expression to replace.</param>
            <param name="depth">Stack depth right before the Pop statement.</param>
            <returns>Any valid expression; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="T:System.Compiler.StackRemovalTransformation">
            <summary>
            Computes stack depth for each basic block and whether it is reachable from the entry.
            
            Also changes all pop, dup and push instructions into corresponding actions on stack temporary locals.
            </summary>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.Process(System.Compiler.ControlFlowGraph)">
            <summary>
            Examines a CFG and removes the stack manipulating instructions by introducing
            some explicit variables for stack locations.  After this transformation, no more
            Pop, Dup etc.
            </summary>
            <param name="cfg">Control Flow Graph that is modified by the transformation.
            This argument WILL be mutated.</param>
            <returns>A map that assigns to each block from <c>cfg</c> the stack depth at its
            beginning.  Useful as a pseudo-liveness information.</returns>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.PopTransformer(System.Compiler.Expression,System.Int32)">
            <summary>
            Replace a pop expression with the appropriate stack variable.
            </summary>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.DupTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Replace a dup expression with the appropriate stack variable.
            </summary>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.PopExprTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Remove the Pop from a CciHelper statement "sequence" of the form "Pop expr".
            </summary>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.PushExprTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Replace an implicit Push with an assignment to the appropriate stack variable.
            </summary>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.PopStatTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Replace an explicit Pop statement with a nop: stack is modeled by stack vars now.
            </summary>
        </member>
        <member name="T:System.Compiler.PathWrapper">
            <summary>
            A version of System.IO.Path that does not throw exceptions.
            </summary>
        </member>
        <member name="T:System.Compiler.Partitioner">
            <summary>
            Partitions IR into separate composition regions
            Composers are compiler extensions that are given responsibility for individual regions
            </summary>
        </member>
        <member name="T:System.Compiler.CodeDomTranslator">
            <summary>
            Walks a System.CodeDom.CodeCompileUnit and produces a corresponding CompilationUnit.
            </summary>
        </member>
        <member name="M:System.Compiler.CodeDomTranslator.Translate(System.Compiler.Compiler,System.CodeDom.CodeCompileUnit,System.Compiler.Module,System.Compiler.ErrorNodeList)">
            <summary>
            Walks the supplied System.CodeDom.CodeCompileUnit and produces a corresponding CompilationUnit.
            Enters declarations into the supplied Module and errors into the supplied ErrorNodeList. 
            Calls back to the supplied compiler to resolve assembly references and to create appropriate documents for code snippets.
            </summary>
            <param name="compiler">Called upon to resolve assembly references and to create Documents for snippets.</param>
            <param name="compilationUnit">The root of the CodeDOM tree to be translated into an IR CompileUnit.</param>
            <param name="targetModule">The module or assembly to which the compilation unit will be compiled.</param>
            <param name="errorNodes">Errors in the CodeDOM tree that are found during translation are added to this list.</param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.Analysis.ReentrancyElementFactory">
            <summary>
            The main analyis class. Entry point to analyze a method, an assembly or 
            a compilation unit.
            At contruction time, you can define if the analysis is interprocedural or only
            intraprocedural. If you choose interprocedural, you can decide for a fix point 
            based approach, using a backward traversal over a partial callgraph, or an inlining
            simulation (when you can decide the maximun callstack depth)
            The analysis has 2 modes of operation. StandAlone or assuminng that is using inside CCI or Boogie.
            The main diference is that in the standalone it tries to analyze all method it finds in the assembly
            and in the other case it only analyzed the method annotated as [pure] or [confined]. 
            The purpose on the StandAlone mode is the INFERENCE, and the other mode is VERIFICATION.
            </summary>
        </member>
        <member name="T:System.Compiler.Analysis.ReentrancyAnalysis">
            <summary>
            The interprocedural analysis main class. It is basically as the Points to analysis 
            </summary>
        </member>
        <member name="M:System.Compiler.Analysis.ReentrancyAnalysis.#ctor(System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Constructor with a given Node. 
            We used to compute the set of nodes in this node and (optionally) bound the set of 
            analyzable methods in the interprocedural analysis
            </summary>
            <param name="t"></param>
            <param name="node"></param>
        </member>
        <member name="M:System.Compiler.Analysis.ReentrancyAnalysis.#ctor(System.Compiler.Analyzer,System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Same constructor but with the analyzer
            </summary>
            <param name="analyzer"></param>
            <param name="t"></param>
            <param name="node"></param>
            
        </member>
        <member name="M:System.Compiler.Analysis.ReentrancyAnalysis.WasAnalyzed(System.Compiler.Method)">
            <summary>
            Determines if the method was analyzed 
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analysis.ReentrancyAnalysis.IsAnalyzable(System.Compiler.Method)">
            <summary>
            Determines whether the method if analyzable or not
            for interProc call.
            That is, if we can get the method body 
            (not abstract, not interface, under our desired analysis scope)
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analysis.ReentrancyAnalysis.ProcessResultsMethod(System.Compiler.Method)">
            <summary>
            Show detailed information about the results for the method.
            
            </summary>
            <param name="m"></param>
        </member>
        <member name="F:System.Compiler.Analysis.ReentrancyAnalysis.reportedErrors">
            <summary>
            Important: This is absolutely necessary, since we are doing fix-point
            Analysis. Bypass this sometimes means hundred's of the same error messages.
            </summary>
        </member>
        <member name="M:System.Compiler.Analysis.ReentrancyAnalysis.HandleError(System.Compiler.Statement,System.Compiler.Node,System.Compiler.Error,System.String[])">
            <summary>
            Error handler. Only file an error if it has not been filed yet. 
            
            Requires: the node has proper source context. Otherwise, it does not help.
            </summary>
            <param name="stat"></param>
            <param name="node"></param>
            <param name="error"></param>
            <param name="m"></param>
        </member>
        <member name="M:System.Compiler.Analysis.ObjectExposureAnalysis.#ctor(System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Constructor with a given Node. 
            We used to compute the set of nodes in this node and (optionally) bound the set of 
            analyzable methods in the interprocedural analysis
            </summary>
            <param name="t"></param>
            <param name="node"></param>
        </member>
        <member name="M:System.Compiler.Analysis.ObjectExposureAnalysis.#ctor(System.Compiler.Analyzer,System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Same constructor but with the analyzer
            </summary>
            <param name="analyzer"></param>
            <param name="t"></param>
            <param name="node"></param>
            
        </member>
        <member name="T:System.Compiler.Analysis.ReentrancyInferer">
            <summary>
            The dataflow analysis for the method under analysis 
            </summary>
        </member>
        <member name="M:System.Compiler.Analysis.ReentrancyInferer.#ctor(System.Compiler.TypeSystem,System.Compiler.Analysis.ReentrancyAnalysis)">
            <summary>
            Constructor
            </summary>
            <param name="t"></param>
            <param name="pta"></param>
        </member>
        <member name="M:System.Compiler.Analysis.ReentrancyInferer.ComputeReentrancyFor(System.Compiler.Method)">
            <summary>
            Compute the Dataflow analysis for the given method
            Returns true if the method is pure
            </summary>
            <param name="method"></param>
            <returns></returns>
            
        </member>
        <member name="P:System.Compiler.Analysis.ReentrancyInferer.ReentranceState">
            <summary>
            Return the results of the analysis on exit of the CFG
            </summary>
        </member>
        <member name="T:System.Compiler.Analysis.Reentrancy">
            <summary>
            Represents the pointsTo and the write effects of the current block
            That is cState = &lt; PtGraph , WriteEffecs , NonAnalyzableCalls &gt; 
            It is a semilattice (bottom , &lt;=)
            </summary>
        </member>
        <member name="F:System.Compiler.Analysis.Reentrancy.callEdges">
            <summary>
            This is the Semilattice
            </summary>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.Join(System.Compiler.PointsToState)">
            <summary>
             Join two PointsToAndWriteEffects
            </summary>
            <param name="ptgWe"></param>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.Includes(System.Compiler.PointsToState)">
            <summary>
             Inclusion check for two PointsToAndWriteEffects
            </summary>
            <param name="ptgWe"></param>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.ApplyNonAnalyzableCall(System.Compiler.Variable,System.Compiler.Method,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.Label)">
            <summary>
            Register effect of the non-analyzable call in the pointsToGraph inferring the information from the callee annotations
            </summary>
            <param name="vr"></param>
            <param name="callee"></param>
            <param name="receiver"></param>
            <param name="arguments"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.CalleeNodesReachableObjectsAsReceivers(System.Compiler.Variable,System.Compiler.Label,System.Boolean)">
            <summary>
            Register all nodes reachable from the argument as potencial receivers
            </summary>
            <param name="v"></param>
            <param name="lb"></param>
            <param name="confined"></param>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.ApplyAnalyzableCall(System.Compiler.Variable,System.Compiler.Method,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.PointsToState,System.Compiler.Label,System.Compiler.InterProcMapping@)">
            <summary>
            Apply the inter-procedural analysis, binding information from caller and callee
            </summary>
            <param name="vr"></param>
            <param name="callee"></param>
            <param name="receiver"></param>
            <param name="arguments"></param>
            <param name="calleecState"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.ReentrancyAnalysisForAnalyzableCalls(System.Compiler.Method,System.Compiler.Analysis.Reentrancy,System.Compiler.Label,System.Compiler.Analysis.Receivers,System.Compiler.InterProcMapping)">
            <summary>
            This is the MAIN reentrancy analysis rutine
            </summary>
            <param name="callee"></param>
            <param name="calleecState"></param>
            <param name="lb"></param>
            <param name="potentialReceivers"></param>
            <param name="ipm"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.CheckRule2UsingEdges(System.Compiler.Nodes,System.Compiler.Nodes)">
            <summary>
            Check for Rule 2: See Manuel's internal Report 
            Indirect call to "this"
            (I will complete later...)
            </summary>
            <param name="bindedPotentialCalleeReceivers"></param>
            <param name="thisVariableValues"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.CheckRule3UsingEdges(System.Compiler.Analysis.Reentrancy,System.Compiler.InterProcMapping,System.Compiler.Nodes@)">
            <summary>
            Rule 3: Reentrant call discovered using caller context 
            </summary>
            <param name="calleeReentrancy"></param>
            <param name="ipm"></param>
            <param name="withnesses"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.CheckRule4UsingEdges(System.Compiler.Analysis.Reentrancy,System.Compiler.Nodes,System.Compiler.Nodes,System.Compiler.InterProcMapping,System.Compiler.Nodes@)">
            <summary>
            Rule 4: Potential reentrant call because of a call in a Load Node (using type information)
            Must be refined!
            </summary>
            <param name="calleeReentrancy"></param>
            <param name="potentialReceivers"></param>
            <param name="thisValues"></param>
            <param name="ipm"></param>
            <param name="withnesses"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.UpdateCallEdges(System.Compiler.Nodes,System.Compiler.Nodes,System.Compiler.Analysis.Reentrancy,System.Compiler.InterProcMapping)">
            <summary>
            Update call edges with the information about the actual call, translate information 
            about call edges in the callee using the interproc mapping and clausure all to keep only load nodes. 
            </summary>
            <param name="thisVariableValues"></param>
            <param name="potentialReceivers"></param>
            <param name="calleeReentrancy"></param>
            <param name="ipm"></param>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.ClausureAndClean(System.Compiler.Edges)">
            <summary>
            Compute the clousure of Call Edges
            </summary>
            <param name="egdesToClausure"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analysis.Reentrancy.Dump">
            <summary>
            Display the cState
            </summary>
        </member>
        <member name="P:System.Compiler.Analysis.Reentrancy.CallEdges">
            <summary>
            Method under analysis (MUA)
            </summary>
        </member>
        <member name="T:System.Compiler.Analysis.PointsToAndReenrtancyInstructionVisitor">
            <summary>
            Instruction visitor. Implement the transfer function of the dataflow analysis
            It is exactly the same as the points to analysis
            </summary>
        </member>
        <member name="F:System.Compiler.Analysis.PointsToAndReenrtancyInstructionVisitor.count">
            <summary>
            Constructor
            </summary>
            <param name="pta"></param>
            
        </member>
        <member name="M:System.Compiler.INonNullState.IsNull(System.Compiler.Variable)">
            <summary>
            If variable is not a reference type, the nullness applies to the variable itself.
            If it is a Reference type however, the nullness applies to the contents of the reference.
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.INonNullState.IsNonNull(System.Compiler.Variable)">
            <summary>
            If variable is not a reference type, the nullness applies to the variable itself.
            If it is a Reference type however, the nullness applies to the contents of the reference.
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.INonNullInformation">
            <summary>
            Exposes computed non-null information for a method
            </summary>
        </member>
        <member name="M:System.Compiler.INonNullInformation.OnEdge(System.Compiler.CfgBlock,System.Compiler.CfgBlock)">
            <summary>
            Provides the non-null information for the state on edge (from, to)
            </summary>
        </member>
        <member name="T:System.Compiler.NonNullState">
            <summary>
            NonNull states for variables and Objects.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.TryValueValue(System.Compiler.Variable)">
            <summary>
            For indirect pointers (refs)
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.NullVariableSet(System.Compiler.IFunctionalSet@)">
            <summary>
            Returns a set of definitely null variables and a set of definitely non-null variables
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.AssignAVal(System.Compiler.Variable,System.Compiler.NonNullState.Lattice.AVal)">
            <summary>
            Set v to a new value that is abstracted by av
            </summary>
            <param name="v"></param>
            <param name="av"></param>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeNull(System.Compiler.ISymValue)">
            <summary>
            Adds assumption that sv == null
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeNull(System.Compiler.Variable)">
            <summary>
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeNonNull(System.Compiler.Variable)">
            <summary>
            Adds assumption that v != null
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.IsNonNullType(System.Compiler.TypeNode)">
            <summary>
            Check whether a given object is of nonnull type. It will check:
            Variable, Field, return type of Method.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullState.HavocHeap">
            <summary>
            Assume all accessible locations in the heap are modified.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.Join(System.Compiler.NonNullState,System.Compiler.NonNullState,System.Compiler.CfgBlock)">
            <summary>
            Returns null, if result of Join is the same as atMerge.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeFalse(System.Compiler.ISymValue,System.Compiler.NonNullState@)">
            <summary>
            Refines the given state according to the knowledge stored in the egraph about sv
            
            In addition, the state can be null when the knowledge is inconsistent.
            </summary>
            <param name="cv">symbolic value we assume to be null (false)</param>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeTrue(System.Compiler.ISymValue,System.Compiler.NonNullState@)">
            <summary>
            Refines the given state according to the knowledge stored in the egraph about sv
            
            In addition, the state can be null when the knowledge is inconsistent.
            </summary>
            <param name="cv">symbolic value we assume to be non-null (true)</param>
            <param name="state">state if sv is non-null (true)</param>
        </member>
        <member name="M:System.Compiler.NonNullState.HavocIndirect(System.Compiler.Variable,System.Compiler.Reference)">
            <summary>
            Havoc the contents of the pointed to locations, but 
            if non-null, reestablish that invariant.
            </summary>
            <param name="pointer"></param>
            <param name="type"></param>
        </member>
        <member name="T:System.Compiler.NonNullState.Lattice.AVal">
            <summary>
            Ordering:
            
              A lt B   iff
              
              !A.NonNull implies !B.NonNull
              
            </summary>
        </member>
        <member name="T:System.Compiler.NonNullChecker">
            <summary>
            The main class for NonNull checking.
            </summary>
        </member>
        <member name="F:System.Compiler.NonNullChecker.iVisitor">
            <summary>
            Current NonNull checking visitor
            </summary>
        </member>
        <member name="F:System.Compiler.NonNullChecker.currBlock">
            <summary>
            Current block being analyzed.
            </summary>
        </member>
        <member name="F:System.Compiler.NonNullChecker.reportedErrors">
            <summary>
            Used to avoid repeated error/warning report for the same Node.
            
            Important: This is absolutely necessary, since we are doing fix-point
            Analysis. Bypass this sometimes means hundred's of the same error messages.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullChecker.HandleError(System.Compiler.Statement,System.Compiler.Node,System.Compiler.Error,System.String[])">
            <summary>
            Error handler. Only file an error if it has not been filed yet. 
            
            Requires: the node has proper source context. Otherwise, it does not help.
            </summary>
            <param name="stat"></param>
            <param name="node"></param>
            <param name="error"></param>
            <param name="m"></param>
        </member>
        <member name="F:System.Compiler.NonNullChecker.eliminateCheck">
            <summary>
            This map keeps track of which expression statements representing a non null assertion check can
            be eliminated. Statements not in the map cannot be eliminated, others according to the stored value.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullChecker.Check(System.Compiler.TypeSystem,System.Compiler.Method,System.Compiler.Analyzer)">
            <summary>
            Entry point to check a method.
            </summary>
            <param name="t"></param>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.NonNullChecker.#ctor(System.Compiler.TypeSystem,System.Compiler.Method,System.Compiler.Analyzer)">
            <summary>
            Constructor
            </summary>
            <param name="t"></param>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.NonNullChecker.Merge(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState,System.Compiler.IDataFlowState,System.Boolean@,System.Boolean@)">
            <summary>
            Merge the two states for current block.
            </summary>
            <param name="previous"></param>
            <param name="joinPoint"></param>
            <param name="atMerge"></param>
            <param name="incoming"></param>
            <param name="resultDiffersFromPreviousMerge"></param>
            <param name="mergeIsPrecise"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullChecker.VisitBlock(System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Implementation of visit Block. It is called from run.
            
            It calls VisitStatement.
            </summary>
            <param name="block"></param>
            <param name="stateOnEntry"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullChecker.VisitStatement(System.Compiler.CfgBlock,System.Compiler.Statement,System.Compiler.IDataFlowState)">
            <summary>
            It visit individual statement. It is called from VisitBlock.
            
            It will call NonNullInstructionVisitor
            </summary>
            <param name="block"></param>
            <param name="statement"></param>
            <param name="dfstate"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullChecker.SplitExceptions(System.Compiler.CfgBlock,System.Compiler.IDataFlowState@,System.Compiler.IDataFlowState@)">
            <summary>
            It split exceptions for current handler and the next chained handler.
            
            It will:
            
              If the exception is completely intercepted by current handler, the
              exception will be consumed.
              
              If the exception caught but not completely, both current handler and 
              the next handler will take the states.
              
              If the exception is irrelevant to current caught, the next handler 
              will take over the state. Current handler is then bypassed.
            </summary>
            <param name="handler"></param>
            <param name="currentHandlerState"></param>
            <param name="nextHandlerState"></param>
        </member>
        <member name="T:System.Compiler.NonNullInstructionVisitor">
            <summary>
            Visit each instruction, check whether the modification is authorized.
            </summary>
        </member>
        <member name="F:System.Compiler.NonNullInstructionVisitor.NNChecker">
            <summary>
            Current NonNullChecker
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.CheckReceiver(System.Compiler.Statement,System.Compiler.Variable,System.Compiler.NonNullState)">
            <summary>
            For the possible receiver v, check if it is nonnull. if no, file an proper
            error/warning.
            </summary>
            
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.#ctor(System.Compiler.NonNullChecker)">
            <summary>
            Constructor.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.DefaultVisit(System.Compiler.Statement,System.Object)">
            <summary>
            A lot of the pointers are not supported.
            </summary>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitMethodEntry(System.Compiler.Method,System.Collections.IEnumerable,System.Compiler.Statement,System.Object)">
            <summary>
            Method entry. Need to add This pointer. 
            
            Does not have to deal with parameters.
            </summary>
            <param name="method"></param>
            <param name="parameters"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitCopy(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Copy the source to dest.
            
            If source is nonnull, no problem.
            If source is null and dest is nonnulltype, Error
            If source is possible null and dest is nonnulltype, warning.
            Else, nothing.
            
            Need to maintain proper heap transformation.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitCastClass(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Note: casts don't require a non-null argument. null value casts always succeed.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.IsAssertionMethodThatDoesNotReturn(System.Compiler.Method)">
            <summary>
            The checker assumes that all methods in AssertHelpers that have a boolean as their
            first argument are assertions that are called with false and will not return.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.CheckFieldOnceness(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Statement,System.Compiler.NonNullState)">
            <summary>
            Enforcement of once attributes: Check if the field is written more than one
            and also allow to write it if it was null before
            If required a to register the field mutated at the class level (FieldUsage in Analyzer)
            </summary>
            <param name="dest"></param>
            <param name="field"></param>
            <param name="stat"></param>
            <param name="nn"></param>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitStoreElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Perform 2 checks
            1) array is non-null
            2) if array element type is non-null type, then the new value written must be too.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitSwitchCaseBottom(System.Compiler.Statement,System.Object)">
            <summary>
            Shouldn't reach this point. The error is handled by the definite assignment analysis. So
            here we treat it as assume(false)
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitLoadIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Note that the type argument is the element type, or the type of the result of the load.
            </summary>
        </member>
        <member name="T:System.Compiler.ExposureState">
            <summary>
            Exposure states for variables and Objects.
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureState.AssignAVal(System.Compiler.Variable,System.Compiler.ExposureState.Lattice.AVal)">
            <summary>
            Set v to a new value that is abstracted by av
            </summary>
            <param name="v"></param>
            <param name="av"></param>
        </member>
        <member name="M:System.Compiler.ExposureState.AssumeExposed(System.Compiler.ISymValue)">
            <summary>
            Adds assumption that sv is exposed
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureState.AssumeNotExposed(System.Compiler.ISymValue)">
            <summary>
            Adds assumption that sv is not exposed
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureState.HavocHeap">
            <summary>
            Assume all accessible locations in the heap are modified.
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureState.Join(System.Compiler.ExposureState,System.Compiler.ExposureState,System.Compiler.CfgBlock)">
            <summary>
            Returns null, if result of Join is the same as atMerge.
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureState.AssumeFalse(System.Compiler.ISymValue,System.Compiler.ExposureState@)">
            <summary>
            Refines the given state according to the knowledge stored in the egraph about sv
            
            In addition, the state can be null when the knowledge is inconsistent.
            </summary>
            <param name="cv">symbolic value we assume to be false</param>
        </member>
        <member name="M:System.Compiler.ExposureState.AssumeTrue(System.Compiler.ISymValue,System.Compiler.ExposureState@)">
            <summary>
            Refines the given state according to the knowledge stored in the egraph about sv
            
            In addition, the state can be null when the knowledge is inconsistent.
            </summary>
            <param name="cv">symbolic value we assume to be non-null (true)</param>
            <param name="state">state if sv is non-null (true)</param>
        </member>
        <member name="T:System.Compiler.ExposureState.Lattice.AVal">
            <summary>
            Ordering:
            
                         Top
                        /    \
                       /      \
                      /        \
                  IsExposed IsNotExposed
                      \        /
                       \      /
                        \    /
                        Bottom
            
            IsExposed lt Top
            IsNotExposed lt Top
            Bottom lt IsExposed
            Bottom lt IsNotExposed
            
            </summary>
        </member>
        <member name="T:System.Compiler.ExposureChecker">
            <summary>
            The main class for NonNull checking.
            </summary>
        </member>
        <member name="F:System.Compiler.ExposureChecker.iVisitor">
            <summary>
            Current Exposure checking visitor
            </summary>
        </member>
        <member name="F:System.Compiler.ExposureChecker.currBlock">
            <summary>
            Current block being analyzed.
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureChecker.Check(System.Compiler.TypeSystem,System.Compiler.Method,System.Compiler.Analyzer)">
            <summary>
            Entry point to check a method.
            </summary>
            <param name="t"></param>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.ExposureChecker.#ctor(System.Compiler.TypeSystem,System.Compiler.Method)">
            <summary>
            Constructor
            </summary>
            <param name="t"></param>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.ExposureChecker.Merge(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState,System.Compiler.IDataFlowState,System.Boolean@,System.Boolean@)">
            <summary>
            Merge the two states for current block.
            </summary>
            <param name="previous"></param>
            <param name="joinPoint"></param>
            <param name="atMerge"></param>
            <param name="incoming"></param>
            <param name="resultDiffersFromPreviousMerge"></param>
            <param name="mergeIsPrecise"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.ExposureChecker.VisitBlock(System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Implementation of visit Block. It is called from run.
            
            It calls VisitStatement.
            </summary>
            <param name="block"></param>
            <param name="stateOnEntry"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.ExposureChecker.VisitStatement(System.Compiler.CfgBlock,System.Compiler.Statement,System.Compiler.IDataFlowState)">
            <summary>
            It visits an individual statement. It is called from VisitBlock.
            
            It calls NonNullInstructionVisitor
            </summary>
            <param name="block"></param>
            <param name="statement"></param>
            <param name="dfstate"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.ExposureChecker.SplitExceptions(System.Compiler.CfgBlock,System.Compiler.IDataFlowState@,System.Compiler.IDataFlowState@)">
            <summary>
            It split exceptions for current handler and the next chained handler.
            
            It will:
            
              If the exception is completely intercepted by current handler, the
              exception will be consumed.
              
              If the exception caught but not completely, both current handler and 
              the next handler will take the states.
              
              If the exception is irrelevant to current caught, the next handler 
              will take over the state. Current handler is then bypassed.
            </summary>
            <param name="handler"></param>
            <param name="currentHandlerState"></param>
            <param name="nextHandlerState"></param>
        </member>
        <member name="T:System.Compiler.ExposureInstructionVisitor">
            <summary>
            Visit each instruction, check whether the modification is authorized.
            </summary>
        </member>
        <member name="F:System.Compiler.ExposureInstructionVisitor.ExposureChecker">
            <summary>
            Current ExposureChecker
            </summary>
        </member>
        <member name="F:System.Compiler.ExposureInstructionVisitor.reportedErrors">
            <summary>
            Used to avoid repeated error/warning report for the same Node.
            
            Important: This is absolutely necessary, since we are doing fix-point
            Analysis. Bypass this sometimes means hundred's of the same error messages.
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureInstructionVisitor.HandleError(System.Compiler.Statement,System.Compiler.Node,System.Compiler.Error,System.String[])">
            <summary>
            Error handler. Only file an error if it has not been filed yet. 
            
            Requires: the node has proper source context. Otherwise, it does not help.
            </summary>
            <param name="stat"></param>
            <param name="node"></param>
            <param name="error"></param>
            <param name="m"></param>
        </member>
        <member name="M:System.Compiler.ExposureInstructionVisitor.CheckReceiver(System.Compiler.Statement,System.Compiler.Variable,System.Compiler.ExposureState)">
            <summary>
            For the possible receiver v, check if it is nonnull. if no, file an proper
            error/warning.
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureInstructionVisitor.DefaultVisit(System.Compiler.Statement,System.Object)">
            <summary>
            A lot of the pointers are not supported.
            </summary>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.ExposureInstructionVisitor.VisitMethodEntry(System.Compiler.Method,System.Collections.IEnumerable,System.Compiler.Statement,System.Object)">
            <summary>
            Method entry. Need to add This pointer. 
            
            Does not have to deal with parameters.
            </summary>
            <param name="method"></param>
            <param name="parameters"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.ExposureInstructionVisitor.VisitCopy(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Copy the source to dest.
            
            If source is nonnull, no problem.
            If source is null and dest is nonnulltype, Error
            If source is possible null and dest is nonnulltype, warning.
            Else, nothing.
            
            Need to maintain proper heap transformation.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.ExposureInstructionVisitor.VisitCastClass(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Note: casts don't require a non-null argument. null value casts always succeed.
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureInstructionVisitor.VisitStoreElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Perform 2 checks
            1) array is non-null
            2) if array element type is non-null type, then the new value written must be too.
            </summary>
        </member>
        <member name="M:System.Compiler.ExposureInstructionVisitor.VisitSwitchCaseBottom(System.Compiler.Statement,System.Object)">
            <summary>
            Shouldn't reach this point. The error is handled by the definite assignment analysis. So
            here we treat it as assume(false)
            </summary>
        </member>
        <member name="T:System.Compiler.CfgBlock">
            <summary>
            A refinement of blocks that the code flattener produces (single entry, single exit at end)
            
            The block also serves to cache various information once we build the CFG.
            </summary>
        </member>
        <member name="M:System.Compiler.CfgBlock.HandlersMatching(System.Compiler.TypeNode)">
            <summary>
            Returns a list of CfgBlock that are handlers of the current block, handling an exception
            of the given type, or a subtype thereof.
            </summary>
            <param name="exception">Type of exception thrown. It is assumed that any actual subtype could be thrown</param>
            <returns>All handlers that could apply directly to this exception.
             In addition, if the method might not handle it, then the ExceptionExit block is
            part of this list.</returns>
        </member>
        <member name="M:System.Compiler.CfgBlock.BeginSourceContext">
            <summary>
            Returns best effort node with source context for the beginning of the block
            </summary>
        </member>
        <member name="M:System.Compiler.CfgBlock.EndSourceContext">
            <summary>
            Returns best effort node with source context for the beginning of the block
            </summary>
        </member>
        <member name="P:System.Compiler.CfgBlock.Index">
            <summary>
            Returns an index of 0..n of this block within the CFG it is part of.
            
            Allows using arrays as tables indexed by blocks.
            </summary>
        </member>
        <member name="P:System.Compiler.CfgBlock.StackDepth">
            <summary>
            Returns the stack depth at the beginning of the block
            </summary>
        </member>
        <member name="P:System.Compiler.CfgBlock.Item(System.Int32)">
            <summary>
            Return statement in block.
            </summary>
        </member>
        <member name="P:System.Compiler.CfgBlock.Length">
            <summary>
            Returns number of statements in block
            </summary>
        </member>
        <member name="T:System.Compiler.CfgCachingFactory">
            <summary>
            <c>ICFGFactory</c> with caching.
            </summary>
        </member>
        <member name="M:System.Compiler.CfgCachingFactory.ComputeControlFlowGraph(System.Compiler.Method)">
            <summary>
            Get the CFG for a method.  Results are cached, so getting the CFG for the same
            method twice will return the same CFG object.
            </summary>
            <param name="method">Method whose CFG we want to get.</param>
            <returns>CFG for <c>method</c>; cached.</returns>
        </member>
        <member name="M:System.Compiler.CfgCachingFactory.Flush(System.Compiler.Method)">
            <summary>
            Flushes the CFG for <c>method</c> from the internal cache.
            </summary>
            <param name="method">Method whose CFG we want to flush from the cache.</param>
        </member>
        <member name="T:System.Compiler.ControlFlowGraph">
            <summary>
            	/// Control Flow Graph (CFG) for a method.  The CFG is an extra layer on top of
            the CCI representation; all the CFG related information (flow edges) is maintained into
            the CFG object.  Both the normal and the exceptional flows are modeled by the CFG.
            
            <p>THE UNDERLYING CCI REPRESENTATION IS MUTATED *A LOT* BY THE "FINALLY" BLOCK DUPLICATION
            AND THE STACK REMOVAL TRANSFORMATION.  YOU SHOULD MANUALLY CLONE IT BEFORE CONSTRUCTING
            THE CFG IF YOU NEED IT; E.G, IF YOU NEED TO WRITE THE CODE BACK TO DISK.  CFG IS USED FOR
            PROGRAM ANALYSIS ONLY, NOT FOR CODE GENERATION.</p>
            
            <p>A Control Flow Graph is basically an oriented graph whose nodes are the
            basic blocks from the method body; the edges reflect the normal and the exceptional flow
            of control (the exceptional flow is the flow that occurs when an exception is raised).
            In addition to the basic blocks of the original method, three more blocks are added:</p>
            
            <ul>
            <li>a special <c>CFG.NormalExitBlock</c> that is a successor for all the basic block
            terminated in a return instruction; it is a merge point for all the
            paths on the normal (intra-procedural) control flow.</li>
            <li>a special <c>CFG.ExcpExitBlock</c> that is the default handler for all the uncaught
            exceptions; it is a merge point for all the paths on the intra-procedural execution
            paths that may terminate with an uncaught exception.</li>
            <li>a special <c>CFG.ExitBlock</c> that is the only successor of the aforementioned
            normal and the exception exit.  Its only normal flow predecessor is the special block
            for the normal exit and its only exceptional flow predecessor is the special block
            for the exceptional exit. </li>
            </ul>
            
            <p>
            If you are given a block and want to know if it's the [normal/excp] exit of its
            method, all you have to do is use the appropriate "is" test
            (e.g. "block is CFG.NormalExitBlock"). If you have the CFG, and want to know its
            [normal/excp] exit, you just have to query the appropriate method.</p>
            
            <p>
            NOTE:
            If an analysis is interested in the result for the normal flow, then it can retrieve
            the result of the dataflow equations for the normal exit point. Similarly, if an analysis
            is interested in the result for the exceptional flow, then it can retrieve the result
            of the dataflow equations for the exceptional exit point.  Finally, if the distinction between
            normal/exceptional flow is not important, the "unified" exit point can be used instead.</p>
            
            </summary>
        </member>
        <member name="T:System.Compiler.IGraphNavigator">
            <summary>
            Interface for navigating into a graph.
            </summary>
        </member>
        <member name="M:System.Compiler.IGraphNavigator.NextNodes(System.Object)">
            <summary>
            Returns the nodes that can be reached from <c>node</c> by
            navigating one level along the graph edges.
            </summary>
        </member>
        <member name="M:System.Compiler.IGraphNavigator.PreviousNodes(System.Object)">
            <summary>
            Returns the nodes that can be reached from <c>node</c> by
            navigating one level AGAINST the graph edges (i.e., from edge
            target to the edge source).
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.#ctor(System.Compiler.Method,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructs the Control Flow Graph for <c>method</c>.
            If the code for <c>method</c> is unavailable, throw an <c>UnavailableCodeException</c>
            (a constructor cannot return an error code).  If the code for <c>method</c> is empty
            (abstract method), thrown a <c>NoCodeException</c>.  Otherwise, examine the CciHelper
            representation of the method code and construct the CFG.
            </summary>
            <param name="method">Method whose CFG will be constructed.</param>
            <param name="duplicateFinallyBlocks">If <c>true</c>, the finally blocks will be duplicated and you'll obtain a real
            CFG.  Otherwise, you'll have to manually deal with the finally blocks that are traversed by each
            "leave" instruction.  HIGHLY RECOMMENDED!</param>
            <param name="eliminateEvaluationStack">If <c>true</c>, <c>StackRemovalTransf.Process</c> will be called
            to remove the stack manipulating operations. See more commends in the class
            <c>StackRemovalTransf</c>. RECOMMENDED!</param>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.#ctor(System.Compiler.Method,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructs the Control Flow Graph for <c>method</c>.
            If the code for <c>method</c> is unavailable, throw an <c>UnavailableCodeException</c>
            (a constructor cannot return an error code).  If the code for <c>method</c> is empty
            (abstract method), thrown a <c>NoCodeException</c>.  Otherwise, examine the CciHelper
            representation of the method code and construct the CFG.
            </summary>
            <param name="method">Method whose CFG will be constructed.</param>
            <param name="duplicateFinallyBlocks">If <c>true</c>, the finally blocks will be duplicated and you'll obtain a real
            CFG.  Otherwise, you'll have to manually deal with the finally blocks that are traversed by each
            "leave" instruction.  HIGHLY RECOMMENDED!</param>
            <param name="eliminateEvaluationStack">If <c>true</c>, <c>StackRemovalTransf.Process</c> will be called
            to remove the stack manipulating operations. See more commends in the class
            <c>StackRemovalTransf</c>. RECOMMENDED!</param>
            <param name="constantFoldBranches">When <c>true</c>, use constant folding 
            to prune infeasible branches.</param>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.#ctor(System.Compiler.Method)">
            <summary>
            Convenient CFG constructor: by default, the finally blocks are duplicated to obtain
            a real CFG, the stack removal transformation is applied, and constant-folding for
            branches is done.
            </summary>
            <param name="method">Method whose CFG is produced.</param>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.#ctor(System.Compiler.Method,System.Boolean)">
            <summary>
            Convenient CFG constructor: by default, the finally blocks are duplicated to obtain
            a real CFG and the stack removal transformation is applied.
            </summary>
            <param name="method">Method whose CFG is produced.</param>
            <param name="constantFoldBranches">When true, prune infeasible paths
            due to branch conditions that are constants.</param>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.AddCatchStatements(System.Collections.IEnumerable,System.Collections.IList)">
            <summary>
            Add explicit Catch statements at beginning of each catch handler.
            If a Catch handler has a next handler that differs from the ExceptionHandler enclosing the handler block, then we split 
            the Catch statement into a separate block.
            
            Special case for Finally handlers that have been turned into catch handlers by the finally-elimination:
            - Move the special instruction FINALLYVARPREFIX&lt;n&gt; = pop() to the header.
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.BuildContinuationMap(System.Compiler.CfgBlock[])">
            <summary>
            Construct a continuation description for each block
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.examine_real_excp_flow(System.Compiler.Method,System.Compiler.ExceptionHandlerList,System.Compiler.StatementList,System.Collections.IList@)">
            <summary>
            Computes the ExceptionHandler for each block and the chaining of exception handlers.
            Note: 
              Filter handlers are currently treated as starting at the filter expression
              and the endfilter is like a fall through into the actual handler.
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.Blocks">
            <summary>
            Returns an array containing all the blocks from this CFG.
            You should never mutate this array.
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.ContainingBlock(System.Compiler.Statement)">
            <summary>
            If statement is part of this CFG, returns the containing block, otherwise null
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.SortedSCCs">
            <summary>
            Returns the topologically sorted list of the strongly connected components of blocks
            (according to the control flow).  The first SCC in the returned list is the one that
            contains the method entry block.
            </summary>
            <returns>Top-sort list of SCCs of blocks from <c>this</c> CFG (method entry first).</returns>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.Succ(System.Compiler.CfgBlock)">
            <summary>
            Returns the successors of <c>block</c> on both normal and exceptional flow.
            Iterating over the returned <c>IEnumerable</c> is equivalent to iterating first
            over the normal successors and next over the exception flow successors.
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.NormalSucc(System.Compiler.CfgBlock)">
            <summary>
            Returns the normal successors of <c>block</c>.
            You should never mutate this array.
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.ExceptionHandler(System.Compiler.Block)">
            <summary>
            Returns the closest enclosing handler of a particular block
            where control goes if an exception is raised inside <c>block</c>.  
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.Pred(System.Compiler.CfgBlock)">
            <summary>
            Returns the predecessors of <c>block</c> on both normal and exceptional flow.
            Iterating over the returned <c>IEnumerable</c> is equivalent to iterating first
            over the normal predecessors and next over the exception flow predecessors.
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.NormalPred(System.Compiler.CfgBlock)">
            <summary>
            Returns the normal predecessors of <c>block</c>.
            You should never mutate the returned array.
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.ExcpPred(System.Compiler.CfgBlock)">
            <summary>
            Returns the predecessors of <c>block</c> on the exceptional flow of control.
            In C# terms, if <c>block</c> is the beginning of an exception handler, these are
            the blocks protected by that exception handler.  Otherwise, this array has
            length 0.
            You should never mutate the returned array.
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.ExcpSucc(System.Compiler.CfgBlock)">
            <summary>
            Returns the successor of <c>block</c> on the exceptional flow of control.
            You should never mutate the returned array.
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.HandlerThatStartsAtBlock(System.Compiler.Block)">
            <summary>
            Returns the ExceptionHandler that starts at <c>block</c>, if any; null otherwise.
            This is useful when trying to see what kind of exceptions can arrive in <c>block</c>
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.HandlerContainingBlock(System.Compiler.CfgBlock)">
            <summary>
            Useful for finding which handler a block belongs to. This may be needed for
            determining rethrow information.
            </summary>
            <remarks>This is NOT the handler protecting the block!</remarks>
            <param name="block"></param>
            <returns>Start block of handler containing the given block. Otherwise null,
            if given block is not part of any handler.</returns>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.FinallyCloningChain(System.Compiler.CfgBlock)">
             <summary>
             FOR DEBUG ONLY:
             <p>
             Returns the list of "leave" instructions whose processing created a specific block.
             Returns an empty <c>IEnumerable</c> if an original block (not a clone) is sent as
             argument.  In the enumeration, the innermost leave instructions come first.</p>
            
             Returns <c>null</c> if block is not a clone.
             
             NOTE: as we don't have source context info for branching instructions, we manipulate
             the blocks of the leave's instead of the leave instructions themselves.
             </summary>
             <param name="block"></param>
             <returns></returns>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.OrigBlock(System.Compiler.CfgBlock)">
            <summary>
            FOR DEBUG ONLY:
            <p/>
            Returns the original block that, possibly through some cloning, produced a specific block.
            Transitively walks over the copy2orig map until the original block is found.  Acts as an
            identity function for an original block.
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.IsDead(System.Compiler.CfgBlock)">
            <summary>
            Block is unreachable from entry
            </summary>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.StackDepth(System.Compiler.CfgBlock)">
            <summary>
            Returns the stack depth at the beginning of block <c>block</c>.
            </summary>
            <param name="block">Block that we are interested in.</param>
            <returns>Stack depth at the beginning of <c>block</c>.</returns>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.Display(System.IO.TextWriter)">
            <summary>
            Simplified CFG pretty printer: all the info printers are set to null.
            </summary>
            <param name="tw"></param>
        </member>
        <member name="M:System.Compiler.ControlFlowGraph.Display(System.IO.TextWriter,System.Compiler.CfgBlock[],System.Compiler.DGetBlockInfo,System.Compiler.DGetBlockInfo,System.Compiler.DGetStatInfo)">
            <summary>
            CFG pretty-printer.  For each block, this method
            calls <c>pre_printer</c>c(if non-null),
            prints the normal/excp. successors,
            the code of the block, the normal/excp. predecessors and finally calls
            <c>post_printer</c>.  A useful use of the pre and post printers is the
            debugging of a flow-sensitive analysis.
            </summary>
            <param name="tw">Where to print.</param>
        </member>
        <member name="P:System.Compiler.ControlFlowGraph.Entry">
            <summary>
            Return the entry point of this CFG.  This is the point where the execution
            of the underlying method starts.
            </summary>
        </member>
        <member name="P:System.Compiler.ControlFlowGraph.Exit">
            <summary>
            Return the special block for the exit point of this CFG.
            </summary>
        </member>
        <member name="P:System.Compiler.ControlFlowGraph.NormalExit">
            <summary>
            Return the special block for the normal exit of this CFG.
            </summary>
        </member>
        <member name="P:System.Compiler.ControlFlowGraph.ExceptionExit">
            <summary>
            Return the special block for the exceptional exit of this CFG.
            </summary>
        </member>
        <member name="P:System.Compiler.ControlFlowGraph.BlockCount">
            <summary>
            Return the total number of blocks in this CFG
            </summary>
        </member>
        <member name="T:System.Compiler.ControlFlowGraph.UnavailableCodeException">
            <summary>
            Exception thrown when trying to construct the CFG
            of a method whose code is unavailable.
            </summary>
        </member>
        <member name="T:System.Compiler.ControlFlowGraph.UnsupportedCodeException">
            <summary>
            Exception thrown when trying to construct the CFG
            of a method whose code contains some unsupported features,
            e.g. Filter exception handlers.
            </summary>
        </member>
        <member name="T:System.Compiler.ControlFlowGraph.NoCodeException">
            <summary>
            Exception thrown when trying to construct the CFG
            of a method without code (e.g., abstract methods).
            </summary>
        </member>
        <member name="T:System.Compiler.ControlFlowGraph.FinallyBlockDuplicator.SpecialBranch">
            <summary>
            When we duplicate a finally body and graft it into the normal path,
            the jump that goes to this new code must remain a 'leave' rather
            than a 'branch', because we must retain the semantics that 'leave'
            clears the evaluation stack before jumping. However, to correctly
            do recursive copies (i.e. try/finally inside a finally), we need
            to remember that these leaves are not actual leaves. To mark them,
            we derive a new class from Branch and use an 'is' test to look for 
            this class.
            </summary>
        </member>
        <member name="T:System.Compiler.ControlFlowGraph.ISpecialBlock">
            <summary>
            "Marker" interface: only the three artificial blocks introduced by the CFG implement it.
            You should not try to implement it in any of your classes.
            </summary>
        </member>
        <member name="T:System.Compiler.ControlFlowGraph.Continuation">
            <summary>
            Captures how a block continues. Currently only for normal control flow.
            </summary>
        </member>
        <member name="T:System.Compiler.MethodHeader">
            <summary>
            Special statement to identify the starting point of a method.
            This is the definition point for all the method parameters. (this way, each variable is
            defined by one or more statements).
            </summary>
        </member>
        <member name="M:System.Compiler.MethodHeader.#ctor(System.Compiler.Method)">
            <summary>
            Creates the MethodHeader statement for <c>method</c>.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodHeader.parameters">
            <summary>
            List of method parameters, including This if the method is non-static.
            This is grabbed from the method. If it is not found there, but the method is non static,
            we create one to enforce the invariant that each non-static method has a This parameter.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodHeader.method">
            <summary>
            Method that <c>this</c> MethodHeader belongs to; useful in case you want to grab more information.
            </summary>
        </member>
        <member name="T:System.Compiler.Unwind">
            <summary>
            Special statement to identify the exception exit point of a method.
            </summary>
        </member>
        <member name="M:System.Compiler.CciHelper.IsVirtual(System.Compiler.MethodCall)">
            <summary>
            Predicate determines if a particular call is virtual or non virtual
            </summary>
            <param name="call">The call to test</param>
            <returns>true if virtual.</returns>
        </member>
        <member name="M:System.Compiler.CciHelper.IsOut(System.Compiler.Parameter)">
            <summary>
            Checks whether a specific parameter is an "out" parameter.
            </summary>
            <param name="parameter">Parameter to test.</param>
            <returns>True if "out" parameter.</returns>
        </member>
        <member name="M:System.Compiler.CciHelper.IsPopStatement(System.Compiler.Statement)">
            <summary>
            Checks whether a given CciHelper statement encodes an MSIL Pop instruction.
            The correctness of this method depends heavily on what Herman does in the CciHelper reader ...
            </summary>
            <param name="stat">Statement to check.</param>
            <returns><c>true</c> iff <c>stat</c> encodes an MSIL Pop instruction.</returns>
        </member>
        <member name="M:System.Compiler.CciHelper.GetThis(System.Compiler.Method)">
            <summary>
            Find the This node in the method body if method is an instance method.
            </summary>
            <param name="method">Method for which we find the This node</param>
            <returns>The This node or null if method is not instance.</returns>
        </member>
        <member name="T:System.Compiler.Declarer">
            <summary>
            Walks the statement list of a Block gathering information from declarations for use by forward references. Does not recurse into nested blocks.
            This visitor is instantiated and called by Looker.
            </summary>
        </member>
        <member name="F:System.Compiler.Declarer.scope">
            <summary>Maps identifiers to Metadata nodes (e.g. varDecl.Name -> field).</summary>
        </member>
        <member name="F:System.Compiler.Declarer.targetFor">
            <summary>Maps labels (Identifiers) to the corresponding labeled blocks (single statements are promoted to blocks for this purpose).
            Needed to keep local variable and labels in separate namespaces.</summary>
        </member>
        <member name="F:System.Compiler.Declarer.localLabels">
            <summary>A subset of targetFor that maps only labels (Identifiers) declared in the current block. Needed to check for duplicates.</summary>
        </member>
        <member name="F:System.Compiler.Declarer.labelList">
            <summary>A list of all the labels encountered by Declarer.</summary>
        </member>
        <member name="M:System.Compiler.Declarer.VisitBlock(System.Compiler.Block,System.Compiler.Class,System.Compiler.TrivialHashtable,System.Compiler.IdentifierList)">
            <summary>
            Walks the statement list of the given block gathering information from declarations for use by forward references. Does not recurse into nested blocks.
            </summary>
            <param name="block">The block whose declarations are to be processed</param>
            <param name="scope">Maps identifiers to Metadata nodes (e.g. Fields).</param>
            <param name="targetFor">Maps labels (Identifiers) to the corresponding labeled blocks (single statements are promoted to blocks for this purpose).</param>
            <param name="labelList">A list of all the labels encountered by Declarer.</param>
        </member>
        <member name="F:System.Compiler.Analyzer.compilation">
            <summary>
            Current compilation being analyzed.
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.typeSystem">
            <summary>
            Type system for the compilation unit.
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.fieldUsage">
            <summary>
            For checking once fields
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.debug">
            <summary>
            Turn the debug information on
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.debugDFA">
            <summary>
            Turn the detailed DFA debug information on
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.stats">
            <summary>
            Turn on statistics
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.analyzerDebugSymbol">
            <summary>
            Debugging switch.
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.PreprocessorDefinedSymbols">
            <summary>
            Command line switches.
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.NonNullChecking">
            <summary>
            Implications from command line switches (with defaults)
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.cfgRepository">
            <summary>
            Repository that stores the CFGs that have been built.
            
            Since building Control Flow Graph is destructive, we need to keep it for later use.
            </summary>
        </member>
        <member name="M:System.Compiler.Analyzer.GetCFG(System.Compiler.Method)">
            <summary>
            Get the correct CFG for the method.
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analyzer.ErrorSeverity(System.Compiler.ErrorNodeList)">
            <summary>
            return the level of the most severe error. 
            </summary>
            <param name="errors"></param>
            <returns></returns>
        </member>
        <member name="F:System.Compiler.Analyzer.CodeIsWellFormed">
            <summary>
            True if compilation had no errors so far, meaning the trees are well formed and we 
            can build CFGs.
            </summary>
        </member>
        <member name="M:System.Compiler.Analyzer.#ctor(System.Compiler.TypeSystem,System.Compiler.Compilation)">
            <summary>
            Constructor.
            </summary>
            <param name="t">The type system for the compilation.</param>
            <param name="c">The complication being analyzed.</param>
        </member>
        <member name="M:System.Compiler.Analyzer.Analyze(System.Compiler.Method)">
            <summary>
            Analyze the given method.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.Analyzer.LanguageSpecificAnalysis(System.Compiler.Method)">
            <summary>
            Language specific flow analysis.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.Analyzer.GeneralAnalysis(System.Compiler.Method)">
            <summary>
            Put general analysis targeting to general IL properties.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.Analyzer.VisitMethod(System.Compiler.Method)">
            <summary>
            Visit each method, start the analysis.  
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.InterProcMapping">
            <summary>
            Computes the mapping that binds caller's nodes with the callee parameters
            It helps computes the pointsToGraph after the call 
            </summary>
        </member>
        <member name="M:System.Compiler.InterProcMapping.Relate(System.Compiler.IPTAnalysisNode,System.Compiler.IPTAnalysisNode)">
            <summary>
            node2 \in mapping[node1]
            </summary>
            <param name="node1"></param>
            <param name="node2"></param>
        </member>
        <member name="M:System.Compiler.InterProcMapping.Relate(System.Compiler.IPTAnalysisNode,System.Compiler.Nodes)">
            <summary>
            sNodes \in mapping[node1]
            </summary>
            <param name="node1"></param>
            <param name="node2"></param>
        </member>
        <member name="M:System.Compiler.InterProcMapping.RelateNodeWithCallerVar(System.Compiler.Variable,System.Compiler.Expression)">
            <summary>
            LV[args] \in mapping[n]
            </summary>
            <param name="n"></param>
            <param name="arg"></param>
        </member>
        <member name="M:System.Compiler.InterProcMapping.Related(System.Compiler.IPTAnalysisNode)">
            <summary>
            return mapping[n]
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.InterProcMapping.RelatedExtended(System.Compiler.IPTAnalysisNode)">
            <summary>
            return mapping[n] U ({n} - PNode)
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.InterProcMapping.RelateParams">
            <summary>
            Step 1: bind parameters and arguments
            </summary>
        </member>
        <member name="M:System.Compiler.InterProcMapping.MatchOutsideEdges">
            <summary>
            Step 2
            Match outsides egdes from the callee (reads) with inside egdes from the caller (writes).
            Handle cases when callee read data is created by the caller.
            </summary>
        </member>
        <member name="M:System.Compiler.InterProcMapping.MatchOutsideWithInsideInCallee">
            <summary>
            Step 3: Match Outside Edges with Insides Egdes in Callee using resolved aliasing from calling context
            </summary>
        </member>
        <member name="M:System.Compiler.InterProcMapping.ComputeInterMapping(System.Compiler.PTGraph,System.Compiler.PTGraph,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.Variable)">
            <summary>
            Compute the interProc mapping between callee and caller.
            This is a fixpoint of steps 1,2 and 3
            </summary>
            <param name="caller"></param>
            <param name="callee"></param>
            <param name="thisRef"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.InterProcMapping.ComputeInterProgMapping(System.Compiler.PTGraph,System.Compiler.PTGraph,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            Computes the PTGraph that binds caller with callee
            </summary>
            <param name="caller"></param>
            <param name="callee"></param>
            <param name="thisRef"></param>
            <param name="arguments"></param>
            <param name="vr"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.InterProcMapping.bindCallerWithCalleePTG(System.Compiler.PTGraph,System.Compiler.PTGraph,System.Compiler.Variable)">
            <summary>
            Bind the caller with the callee and simplify the resulting pointsToGraph
            by removing the load nodes that has been resolved (captured objects)
            </summary>
            <param name="callerPTG"></param>
            <param name="calleePTG"></param>
            <param name="vr"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.InterProcMapping.bindRefOrOutParameter(System.Compiler.PTGraph,System.Compiler.PTGraph,System.Compiler.Variable,System.Compiler.Variable)">
            <summary>
            Bind an output or ref result with the argument
            </summary>
            <param name="calleePTG"></param>
            <param name="vr"></param>
            <param name="outParameter"></param>
            <param name="ipm"></param>
            <returns></returns>
        </member>
        <member name="F:System.Compiler.LanguageService.currentSymbolTable">
            <summary>Tracks the symbol table (Module) associated with the current editor window</summary>
        </member>
        <member name="F:System.Compiler.LanguageService.EnableDropDownCombos">
            <summary>Set this to True if you want drop downs showing types and members</summary>
        </member>
        <member name="M:System.Compiler.AuthoringScope.GetDeclarations(System.Int32,System.Int32,System.Compiler.ParseReason)">
            <summary>
            Called for completions.
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringScope.GetGenericMethods(System.Int32,System.Int32,System.Compiler.Expression)">
            <summary>
            Called for parameter help.
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringScope.GetMethods(System.Int32,System.Int32,System.Compiler.Expression)">
            <summary>
            Called for parameter help.
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringScope.GetTypes(System.Int32,System.Int32,System.Compiler.Expression)">
            <summary>
            Called for parameter help.
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.MatchPair(System.Compiler.SourceContext,System.Compiler.SourceContext)">
            <summary>
            Whenever a matching pair is parsed, e.g. '{' and '}', this method is called
            with the text span of both the left and right item. The
            information is used when a user types "ctrl-]" in VS
            to find a matching brace and when auto-highlight matching
            braces is enabled.
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.MatchTriple(System.Compiler.SourceContext,System.Compiler.SourceContext,System.Compiler.SourceContext)">
            <summary>
            Matching tripples are used to highlight in bold a completed statement.  For example
            when you type the closing brace on a foreach statement VS highlights in bold the statement
            that was closed.  The first two source contexts are the beginning and ending of the statement that
            opens the block (for example, the span of the "foreach(...){" and the third source context
            is the closing brace for the block (e.g., the "}").
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.StartName(System.Compiler.Expression)">
            <summary>
            In support of Member Selection, CompleteWord, QuickInfo, 
            MethodTip, and Autos, the StartName and QualifyName methods
            are called.
            StartName is called for each identifier that is parsed (e.g. "Console")
            Its type is Expression since it can be this/base etc
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.QualifyName(System.Compiler.SourceContext,System.Compiler.Expression)">
            <summary>
            QualifyName is called for each qualification with both
            the text span of the selector (e.g. ".")  and the text span 
            of the name ("WriteLine").
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.AutoExpression(System.Compiler.SourceContext)">
            <summary>
            AutoExpression is in support of IVsLanguageDebugInfo.GetProximityExpressions.
            It is called for each expression that might be interesting for
            a user in the "Auto Debugging" window. All names that are
            set using StartName and QualifyName are already automatically
            added to the "Auto" window! This means that AutoExpression
            is rarely used.
            </summary>   
        </member>
        <member name="M:System.Compiler.AuthoringSink.CodeSpan(System.Compiler.SourceContext)">
            <summary>
            CodeSpan is in support of IVsLanguageDebugInfo.ValidateBreakpointLocation.
            It is called for each region that contains "executable" code.
            This is used to validate breakpoints. Comments are
            automatically taken care of based on TokenInfo returned from scanner. 
            Normally this method is called when a procedure is started/ended.
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.StartParameters(System.Compiler.SourceContext)">
            <summary>
            The StartParameters, Parameter and EndParameter methods are
            called in support of method tip intellisense (ECMD_PARAMINFO).
            [StartParameters] is called when the parameters of a method
            are started, ie. "(".
            [NextParameter] is called on the start of a new parameter, ie. ",".
            [EndParameter] is called on the end of the paramters, ie. ")".
            REVIEW: perhaps this entire scheme should go away
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.NextParameter(System.Compiler.SourceContext)">
            <summary>
            NextParameter is called after StartParameters on the start of each new parameter, ie. ",".
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.EndParameters(System.Compiler.SourceContext)">
            <summary>
            EndParameter is called on the end of the paramters, ie. ")".
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.AddError(System.Compiler.ErrorNode)">
            <summary>
            Send a message to the development enviroment. The kind of message
            is specified through the given severity. 
            </summary>
        </member>
        <member name="T:System.Compiler.TypeAndMemberDropdownBars">
            <summary>
            Represents the two drop down bars on the top of a text editor window that allow types and type members to be selected by name.
            </summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.languageService">
            <summary>The language service object that created this object and calls its SynchronizeDropdowns method</summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.sortedDropDownTypes">
            <summary>The list of types that appear in the type drop down list. Sorted by full type name.</summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.dropDownTypes">
            <summary>The list of types that appear in the type drop down list. Textual order.</summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.dropDownMembers">
            <summary>The list of members that appear in the member drop down list. Sorted by name.</summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.sortedDropDownMembers">
            <summary>The list of members that appear in the member drop down list. Textual order.</summary>
        </member>
        <member name="M:System.Compiler.TypeAndMemberDropdownBars.SynchronizeDropdowns(System.String,System.Int32,System.Int32)">
            <summary>
            Updates the state of the drop down bars to match the current contents of the text editor window. Call this initially and every time
            the cursor position changes.
            </summary>
            <param name="textView">The editor window</param>
            <param name="line">The line on which the cursor is now positioned</param>
            <param name="col">The column on which the cursor is now position</param>
        </member>
        <member name="T:System.Compiler.CodeFlattener">
            <summary>
            Transforms the nested CCI representation into a flat one.
            
            More precisely it does 3 things
            - It turns nested block structures into a 2 level structure, the method body is a block consisting of blocks. These
              2nd level blocks only contain statements, not nested blocks. All branch targets are to a block in the 2nd level.
              
            - All statements are simplified to three address codes, by splitting complicated expressions so that they push their
              result onto the stack, whereas the continuation pops it off the stack.
              
            - Produces only CfgBlocks
            
            In order to correctly deal with nested dup expressions which appear when the input is not read in
            from an external DLL, but is the output of the compiler, we need to use an explicit stack model.
            Consider the following problem:
            
               Construct(Delegate, [ local0, BinaryExpr(ldvirtfn, dup, Test.M) ]
               
            The dup instruction acts on the local0, which is the first argument to the constructor. Previously,
            we would try to use this local0 directly, without stacking it. Now we have to stack everything.
            
            Stacking everything has the undesirable side effect that data flow analyses that do branch refinement have
            a hard time updating information about tests, since the tests always involve stack variables.
            </summary>
        </member>
        <member name="T:System.Compiler.EmptyVisitor">
            <summary>
            Visitor that doesn't implement any Visit method
            (throws new ApplicationException("unimplemented") instead.)
            Good if all you want to do is dispatch some specific processing for each node type,
            without going deep into the recursive data structure.  Throwing an exception for
            unimplemented things is also useful for catching the untreated cases.
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.expandAllocations">
            <summary>
            When true, an allocation is split into a separate memory alloc, followed by an explicit constructor call.
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.performConstantFoldingOnBranchConditions">
            <summary>
            When true, use branch conditions that are literals to prune infeasible execution paths.
            In general, we always want this to be done. But if it is done for the code that
            does the runtime checking of contracts, that would influence whether the "regular"
            code downstream of the branch is represented in the CFG or not.
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.orig2Copy">
            <summary>
            Contains mappings from original ExpressionStatement to new ExpressionStatement
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.MakeFlat(System.Compiler.Method,System.Boolean,System.Compiler.CodeMap@)">
            <summary>
            Flattens the code of the method <c>method</c>.  Leaves the CCI representation of <c>method</c> intact.
            
            Returns a mutated copy.
            
            Important! don't forget to adjust handler block boundaries as well
            </summary>
            <param name="expandAllocations">When true, then Construct expressions are expanded
            into a separate allocation and separate constructor call.</param>
        </member>
        <member name="M:System.Compiler.CodeFlattener.MakeFlat(System.Compiler.Method,System.Boolean,System.Boolean,System.Compiler.CodeMap@)">
            <summary>
            Flattens the code of the method <c>method</c>.  Leaves the CCI representation of <c>method</c> intact.
            
            Returns a mutated copy.
            
            Important! don't forget to adjust handler block boundaries as well
            </summary>
            <param name="expandAllocations">When true, then Construct expressions are expanded into a separate allocation and separate
            constructor call.</param>
            <param name="constantFoldEvenInContracts">When <c>true</c>, use constant folding 
            to prune infeasible branches.</param>
        </member>
        <member name="F:System.Compiler.CodeFlattener.orig2newBlocks">
            <summary>
            Maintains the mapping from original blocks to new blocks so we can adjust branch targets
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.branchInstructions">
            <summary>
            Used to build up a list of all branch statements, so that in a post pass we can adjust their targets
            using the orig2newBlocks mapping
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.switchInstructions">
            <summary>
            Used to build up a list of all switch statements, so that in a post pass we can adjust their targets
            using the orig2newBlocks mapping
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.new_stats">
            <summary>
            To accumulate statements from a block. The transformed statements
            go onto this list.
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.new_blocks">
            <summary>
            Accumulates the newly created blocks.
            
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.current_oldBlock">
            <summary>
            Holds either null, or the current old block that must be mapped to the
            next dynamically created new block in the map.
            
            Note: Because a nested block can appear as the first statement of
            a block, we have to be careful. There can be multiple outstanding oldBlocks
            that need to be mapped to the first generated block.
            
            We do this by the following invariant:
            Every block expansion starts with a call to FlattenBlock
             The FlattenBlock stack activation frame keeps track of the prior current_oldBlock 
             and stores the new current oldBlock.
             At the end of FlattenBlock, the prior_oldBlock is mapped to the same new block
             as the oldBlock on which FlattenBlock was called.
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.EndStatementList">
            <summary>
            Invariant: whenever during the traversal, we find that we need to start a new block
            (because we reach a block that could be the target of a branch),
            we have to take the new_stats StatementList and if non-empty, create a new block from it
            and put it onto the new_blocks list. new_stats is then initialized with a new empty list.
            
            We also have to update the orig2newblock map, using the current_oldBlock as the key and the
            newly created block as the target. If we update the map, we null out the current_oldBlock.
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.UpdateBlockMap(System.Compiler.Block@,System.Compiler.Block)">
            <summary>
            if oldBlock != null, then we need to update the blockMap to map oldBlock to newBlock
            and set oldBlock to null.
            
            POST: oldBlock == null
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.FlattenBlock(System.Compiler.Block)">
            <summary>
            Can be called to recursively flatten a block from the following places:
            1. From within a block on a nested block
            2. From within a BlockExpression
            3. From the top-level method body block
            
            Because of 2 and 3, we may have a pending list of statements in new_stats that belong
            to the previous block. Thus we first need to end that block, then start the new one.
            
            Furthermore, since the old block could be a branch target, we also must update the 
            orig2newBlock map once we generated the first block within this flattening.
            
            Every block expansion starts with a call to FlattenBlock
             The FlattenBlock stack activation frame keeps track of the prior current_oldBlock 
             and stores the new current oldBlock.
             At the end of FlattenBlock, the prior_oldBlock is mapped to the same new block
             as the oldBlock on which FlattenBlock was called.
             
             POST: this.current_oldBlock == null.
            </summary>
            <param name="block"></param>
        </member>
        <member name="M:System.Compiler.CodeFlattener.AdjustBranches">
            <summary>
            Called once after we handled all blocks (by MakeFlat)
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.simplify_addressof_operand(System.Compiler.Expression)">
            <summary>
            
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitThis(System.Compiler.This)">
            <summary>
            Unify all occurrences of This
            </summary>
            <param name="This"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitBase(System.Compiler.Base)">
            <summary>
            BIG FIXME for CCI. Base should not occur here, since it just means "this" after
            normalization.
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitConstruct(System.Compiler.Construct)">
            <summary>
            </summary>
            <param name="cons">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitConstructArray(System.Compiler.ConstructArray)">
            <summary>
            </summary>
            <param name="consArr">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitExpressionStatement(System.Compiler.ExpressionStatement)">
            <summary>
            </summary>
            <param name="expr_stat">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitExpressionList(System.Compiler.ExpressionList)">
            <summary>
            </summary>
            <param name="expressions">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitIndexer(System.Compiler.Indexer)">
            <summary>
            </summary>
            <param name="indexer">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitMemberBinding(System.Compiler.MemberBinding)">
            <summary>
            </summary>
            <param name="memberBinding">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitMethodCall(System.Compiler.MethodCall)">
            <summary>
            
            </summary>
            <param name="call">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitReturn(System.Compiler.Return)">
            <summary>
            
            </summary>
            <param name="Return">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitSwitchInstruction(System.Compiler.SwitchInstruction)">
            <summary>
            
            </summary>
            <param name="switchInstruction">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitThrow(System.Compiler.Throw)">
            <param name="Throw">Cloned</param>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitUnaryExpression(System.Compiler.UnaryExpression)">
            <summary>
            </summary>
            <param name="expression">Cloned</param>
        </member>
        <member name="T:System.Compiler.StackVariable">
            <summary>
            Class for the stack variables introduced by the stack removal transformation.
            </summary>
        </member>
        <member name="M:System.Compiler.StackVariable.#ctor(System.Int32,System.Compiler.TypeNode)">
            <summary>
            Create a stack variable for a given stack depth and a specific type.
            </summary>
            <param name="depth"></param>
            <param name="type"></param>
        </member>
        <member name="M:System.Compiler.StackVariable.NEWTemp(System.Compiler.TypeNode)">
            <summary>
            Bogus stack variable useful for desugaring of NEWwithCONSTRUCT.
            We hope we'll never go beyond 50000 stack vars.  Actually, it would be great if we could analyze
            method with >50000 stack variables !
            </summary>
        </member>
        <member name="M:System.Compiler.StackVariable.NEWValueTemp(System.Compiler.TypeNode)">
            <summary>
            Bogus stack variable useful for desugaring of NEWwithCONSTRUCT for Value types.
            This variable represents the contents of the newly created value object, which does not
            get allocated in the heap.
            </summary>
        </member>
        <member name="T:System.Compiler.FlattenerTest">
            <summary>
            To test the code flattener, this visitor takes a method and expands the body expressions to 
            add a nested BlockExpression around every sub expression it encounters.
            
            It also adds a nested block for the first statement in each block.
            
            The idea is that we can then undo this expansion with the CodeFlattener.
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.TryLookup(System.Compiler.IUniqueKey,System.Compiler.ISymValue[])">
            <summary>
            returns sv, such that sv == function(args), or null if not mapped
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.AssumeEqual(System.Compiler.ISymValue,System.Compiler.ISymValue)">
            <summary>
            Assumes v1 == v2
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.IsEqual(System.Compiler.ISymValue,System.Compiler.ISymValue)">
            <summary>
            Returns true if v1 == v2
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.Eliminate(System.Compiler.IUniqueKey,System.Compiler.ISymValue[])">
            <summary>
            Removes the mapping from the egraph. Semantically equivalent to setting 
            the corresponding term to a Fresh symbolic value.
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.EliminateAll(System.Compiler.ISymValue)">
            <summary>
            Removes all mappings from the egraph of the form g(from).
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.Join(System.Compiler.IEGraph,System.Compiler.CfgBlock,System.Boolean@)">
            <summary>
            Merge two EGraphs. Result is null if result is no different than this.
            </summary>
            <param name="isIsomorphicToThis">true, if result is isomorphic to this graph</param>
        </member>
        <member name="M:System.Compiler.IEGraph.Join(System.Compiler.IEGraph,System.Compiler.CfgBlock,System.Compiler.IMergeInfo@)">
            <summary>
            Merge two EGraphs. Result is null if result is no different than this.
            MergeInfo provides the mapping of symbolic values in the result to values in the
            two incoming branches.
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.Functions(System.Compiler.ISymValue)">
            <summary>
            return the set of unary function symbols f, such that f(symval) = sv' exists in
            the egraph.
            </summary>
            <param name="symval"></param>
        </member>
        <member name="M:System.Compiler.IEGraph.EqTerms(System.Compiler.ISymValue)">
            <summary>
            Return set of equivalent terms to this symbolic value
            </summary>
        </member>
        <member name="P:System.Compiler.IEGraph.Item(System.Compiler.IUniqueKey,System.Compiler.ISymValue[])">
            <summary>
            getter returns sv, such that sv == function(args)
            
            setter sets function(args) == value, is equivalent to Eliminate(f, args), followed by
            assume (f(args) == value)
            </summary>
            <param name="function"></param>
            <param name="args"></param>
        </member>
        <member name="P:System.Compiler.IEGraph.Item(System.Compiler.ISymValue)">
            <summary>
            Associates symval with an abstract value.
            
            getter returns current association or Top
            setter sets current association (forgetting old association)
            </summary>
        </member>
        <member name="P:System.Compiler.IEGraph.Constants">
            <summary>
            return the set of constant function symbols in this egraph
            </summary>
        </member>
        <member name="P:System.Compiler.IEGraph.SymbolicValues">
            <summary>
            Returns the set of defined symbolic values in the egraph that have outgoing edges.
            </summary>
        </member>
        <member name="P:System.Compiler.IMergeInfo.Changed">
            <summary>
            Returns true if result is different from G1
            </summary>
        </member>
        <member name="F:System.Compiler.EGraph.forwMap">
            <summary>
            Used to represent equalities among symbolic values
            </summary>
        </member>
        <member name="M:System.Compiler.EGraph.#ctor(System.Compiler.EGraph,System.Compiler.CfgBlock)">
            <summary>
            Copy constructor
            </summary>
            <param name="from"></param>
        </member>
        <member name="M:System.Compiler.EGraph.Update.Replay(System.Compiler.EGraph.MergeState)">
            <summary>
            Replay update on merge state
            </summary>
        </member>
        <member name="T:System.Compiler.Optimizer">
            <summary>
            Runs after Normalizer and Analyzer. Performs rewrites that we don't want the analyzer to see, e.g., removes
            calls to conditional methods.
            It can also take advantage of invariants learned during the Analyzer phase.
            </summary>
        </member>
        <member name="T:System.Compiler.WPurity.PointsToAndWriteEffects">
            <summary>
            Represents the pointsTo and the write effects of the current block
            That is PtWe = &lt; PtGraph , WriteEffecs , NonAnalyzableCalls &gt; 
            It is a semilattice (bottom , &lt;=)
            </summary>
        </member>
        <member name="F:System.Compiler.WPurity.PointsToAndWriteEffects.writeEffects">
            <summary>
            This is the Semilattice
            A PointsToGraph, the WriteEffects and the non-analyzed calls
            </summary>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.Join(System.Compiler.PointsToState)">
            <summary>
             Join two PointsToAndWriteEffects
            </summary>
            <param name="ptgWe"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.Includes(System.Compiler.PointsToState)">
            <summary>
             Inclusion check for two PointsToAndWriteEffects
            </summary>
            <param name="ptgWe"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.InitMethod(System.Compiler.Method,System.Collections.IEnumerable,System.Compiler.Label)">
            <summary>
            Transfer function for the Method Header
            </summary>
            <param name="method"></param>
            <param name="parameters"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyAssignNull(System.Compiler.Variable)">
            <summary>
            f(v1 = null, ptwe), operation only over the pointsToGraph 
            </summary>
            <param name="v1"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ForgetVariable(System.Compiler.Variable)">
            <summary>
            Represent when the value of a variable is not longer valid
            This means losing information about which nodes v1 points to
            </summary>
            <param name="v1"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.CopyLocVar(System.Compiler.Variable,System.Compiler.Variable)">
            <summary>
            A more complex copy operation
            f(v1 = v2), operation only over the pointsToGraph
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.CopyLocVar(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1 = v2), operation only over the pointsToGraph
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyNewStatement(System.Compiler.Variable,System.Compiler.Label,System.Compiler.TypeNode)">
            <summary>
            f(new Type, ptwe) , operation only over the pointsToGraph
            </summary>
            <param name="v"></param>
            <param name="lb"></param>
            <param name="type"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyStoreField(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1.f = v2), operates over the pointsToGraph and register the writeEffect
            </summary>
            <param name="v1"></param>
            <param name="f"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyStoreElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1[.] = v2), operates over the pointsToGraph and register the writeEffect
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyStaticStore(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
            f(C.f = v2), operates over the pointsToGraph and register the writeEffect
            </summary>
            <param name="v2"></param>
            <param name="f"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyLoadField(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
            f(v1 = v2.f), operates over the pointsToGraph and register the read effect
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="f"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyLoadElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1 = v2[.]), operates over the pointsToGraph and register the read effect 
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyLoadStatic(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
            f(v1 = C.f), operates over the pointsToGraph 
            </summary>
            <param name="v1"></param>
            <param name="f"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyLoadAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
             f(v1 = &amp;v2)
            </summary>
            <param name="dest"></param>
            <param name="src"></param>
            <param name="lb"></param>
            
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyLoadIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1 = *v2), operation only over the pointsToGraph
            // I take it as dest = * pointer
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyStoreIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            A more complex copy operation
            f(*v1 = v2, operation only over the pointsToGraph
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyLoadFieldAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
             f(v1 = &amp; v2.f)
            </summary>
            <param name="dest"></param>
            <param name="src"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyLoadStaticFieldAddress(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
             f(v1 = &amp; C.f).  
            </summary>
            <param name="dest"></param>
            <param name="src"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyNonAnalyzableCall(System.Compiler.Variable,System.Compiler.Method,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.Label)">
            <summary>
            Register effect of the non-analyzable call in the pointsToGraph inferring the information from the callee annotations
            </summary>
            <param name="vr"></param>
            <param name="callee"></param>
            <param name="receiver"></param>
            <param name="arguments"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyAnalyzableCall(System.Compiler.Variable,System.Compiler.Method,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.PointsToState,System.Compiler.Label,System.Compiler.InterProcMapping@)">
            <summary>
            Apply the inter-procedural analysis, binding information from caller and callee
            </summary>
            <param name="vr"></param>
            <param name="callee"></param>
            <param name="receiver"></param>
            <param name="arguments"></param>
            <param name="calleePTWE"></param>
            <param name="lb"></param>
            
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ApplyReturn(System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(return v, ptwe), only has effect in the pointsToGraph
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.RegisterWriteEffect(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label,System.Boolean)">
            <summary>
            Register the write effect in all nodes pointed by v
            </summary>
            <param name="v"></param>
            <param name="f"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.RegisterReadFields(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
            Register the write effect in all nodes pointed by v
            </summary>
            <param name="v"></param>
            <param name="f"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ComputeEffects(System.Compiler.WPurity.AbstractEffects)">
            <summary>
            Given a Set of effects over abstract heap locations,
            computes a set of effects over the method parameters
            or in the global scope
            </summary>
            <param name="Effects"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ComputeOneEffectPath(System.Compiler.AField,System.Collections.Generic.List{System.Compiler.Edge},System.Compiler.Variable)">
            <summary>
            Compute one Effects using one path from a variable an effect in 
            an abstract heap location
            </summary>
            <param name="af"></param>
            <param name="currentPath"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.IsReadOnly(System.Compiler.Parameter)">
            <summary>
            Verify if the parameter is read-only. That means it cannot reach a modified node
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.ComputePurityWarnings">
            <summary>
            Generate the set with all the non-purity warnings using writEffects and call information.
            This set is used to send information to the compiler about the non-purity warnings.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.VerifyPurity">
            <summary>
            Check whether a method is pure or not by analyzing the pointsTo and writeEffects info.
            To be pure, the parameters (or locations reachable from them) cannot be modified 
            or accessed via escaping locations, and it cannot call non-analyzable methods.
            </summary>
            <param name="ptwe"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffects.Dump">
            <summary>
            Display the ptwe
            </summary>
        </member>
        <member name="T:System.Compiler.WPurity.AbstractEffects">
            <summary>
            Effects: Represent the semilattice of read/write effects
            It it a Set of &lt; PTAnalysisNode, Field &gt; Elements
            with Join and Include functions
            </summary>
        </member>
        <member name="T:System.Compiler.WPurity.VariableEffect">
            <summary>
            VariableEffect: Represent a Read/Write effects over a variable
            That is, the variable and a chain of fields until the 
            (read) written field
            </summary>
        </member>
        <member name="M:System.Compiler.WPurity.VariableEffect.ApplyFieldName(System.String,System.Compiler.Field)">
            <summary>
            Used to give format to a field dereference (.f, [.], *)
            </summary>
            <param name="pathString"></param>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.WPurity.PointsToAndWriteEffectsInferer">
            <summary>
            The dataflow analysis for the method under analysis 
            </summary>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffectsInferer.#ctor(System.Compiler.TypeSystem,System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis)">
            <summary>
            Constructor
            </summary>
            <param name="t"></param>
            <param name="pta"></param>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffectsInferer.VerifyPurity">
            <summary>
            Verify Purity in the Final State
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffectsInferer.VisitStatement(System.Compiler.CfgBlock,System.Compiler.Statement,System.Compiler.IDataFlowState)">
            <summary>
            Visit the statement. It calls the instruction visitor to perform the transfer function
            </summary>
            <param name="block"></param>
            <param name="statement"></param>
            <param name="dfstate"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffectsInferer.Merge(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState,System.Compiler.IDataFlowState,System.Boolean@,System.Boolean@)">
            <summary>
            Merge two PtWe
            </summary>
            <param name="previous"></param>
            <param name="joinPoint"></param>
            <param name="atMerge"></param>
            <param name="incoming"></param>
            <param name="resultDiffersFromPreviousMerge"></param>
            <param name="mergeIsPrecise"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffectsInferer.SplitExceptions(System.Compiler.CfgBlock,System.Compiler.IDataFlowState@,System.Compiler.IDataFlowState@)">
            <summary>
            Exception management
            Need Checking!
            </summary>
            <param name="handler"></param>
            <param name="currentHandlerState"></param>
            <param name="nextHandlerState"></param>
        </member>
        <member name="P:System.Compiler.WPurity.PointsToAndWriteEffectsInferer.PointsToWE">
            <summary>
            Return the results of the analysis on exit of the CFG
            </summary>
        </member>
        <member name="T:System.Compiler.WPurity.PointsToAndWriteEffectsInstructionVisitor">
            <summary>
            Instruction visitor. Implement the transfer function of the dataflow analysis
            </summary>
        </member>
        <member name="M:System.Compiler.WPurity.PointsToAndWriteEffectsInstructionVisitor.#ctor(System.Compiler.WPurity.PointsToAndWriteEffectsInferer)">
            <summary>
            Constructor
            </summary>
            <param name="pta"></param>
        </member>
        <member name="T:System.Compiler.WPurity.WriteEffectsElementFactory">
            <summary>
            The main analyis class. Entry point to analyze a method, an assembly or 
            a compilation unit.
            At contruction time, you can define if the analysis is interprocedural or only
            intraprocedural. If you choose interprocedural, you can decide for a fix point 
            based approach, using a backward traversal over a partial callgraph, or an inlining
            simulation (when you can decide the maximun callstack depth)
            The analysis has 2 modes of operation. StandAlone or assuminng that is using inside CCI or Boogie.
            The main diference is that in the standalone it tries to analyze all method it finds in the assembly
            and in the other case it only analyzed the method annotated as [pure] or [confined]. 
            The purpose on the StandAlone mode is the INFERENCE, and the other mode is VERIFICATION.
            </summary>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.#ctor(System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Constructor with a given Node. 
            We used to compute the set of nodes in this node and (optionally) bound the set of 
            analyzable methods in the interprocedural analysis
            </summary>
            <param name="t"></param>
            <param name="node"></param>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.#ctor(System.Compiler.Analyzer,System.Compiler.TypeSystem,System.Compiler.Node)">
            <summary>
            Same constructor but with the analyzer
            </summary>
            <param name="analyzer"></param>
            <param name="t"></param>
            <param name="node"></param>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.VisitTypeNode(System.Compiler.TypeNode)">
            <summary>
            We can filter a Node if we don't want to analyze it. 
            For the stand alone application...
            </summary>
            <param name="typeNode"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.VisitClass(System.Compiler.Class)">
            <summary>
            Idem previous
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.AnalysisForMethod(System.Compiler.Method)">
            <summary>
            Entry point to analyze a given method. 
            Depending of the type of analysis a call to this method
            can lead to a fixpoint computation, the use of a precomputed
            intraprocedural analysis or performing the intraprocedural 
            analysis for the first time
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.FixPoint">
            <summary>
            Perform a fixpoint computation over a ser of methods (in general a strongly connected component).
            It perform the interprocedural analysis for each method, reanalysing any callers that require updating. 
            </summary>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.AnalysisResultsChanges(System.Compiler.Method,System.Compiler.PointsToState)">
            <summary>
            Check whether dataflow analysis changes or not
            </summary>
            <param name="m"></param>
            <param name="newResult"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.AnalyzeMethod(System.Compiler.Method)">
            <summary>
            Analyze a given method.
            That is, perform the IntraProdecural Dataflow Analysis
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.ComputeOnlyPurity(System.Compiler.Method)">
            <summary>
            Check if we already cumputed the purity of the method under analysis
            If not, the methdo purity is computed and saved
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.WasAnalyzed(System.Compiler.Method)">
            <summary>
            Determines if the method was analyzed 
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.IsAnalyzable(System.Compiler.Method)">
            <summary>
            Determines whether the method is analyzable or not
            for interProc call.
            That is, if we can get the method body 
            (not abstract, not interface, under our desired analysis scope)
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.ProcessResultsMethod(System.Compiler.Method)">
            <summary>
            Show detailed information about the results for the method.
            
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:System.Compiler.WPurity.WeakPurityAndWriteEffectsAnalysis.printStatements(System.Compiler.Method)">
            <summary>
            Used for test purposes
            </summary>
            <param name="m"></param>
        </member>
        <member name="T:System.Compiler.IPTAnalysisNode">
            <summary>
            Is the base for all nodes in the pointsToGraph
            It has a Label representing its position in code and the Type of the heap
            location it represents
            </summary>
        </member>
        <member name="T:System.Compiler.PTAnalysisNode">
            <summary>
            PtAnalysisNode: Is the base class for all nodes in the pointsToGraph
            It has a Label representing its position in code and the Type of the heap
            location it represents
            </summary>
        </member>
        <member name="T:System.Compiler.GNode">
            <summary>
            GNode: Represents Global (static) nodes
            It has neither Label nor Type
            </summary>
        </member>
        <member name="T:System.Compiler.InsideNode">
            INode: Represents objects created by the method under analysis 
        </member>
        <member name="T:System.Compiler.RNode">
            <summary>
             An Inside Node representing the returned expression 
            </summary>
        </member>
        <member name="T:System.Compiler.StructNode">
            <summary>
             An Inside Node representing a struct  
            </summary>
        </member>
        <member name="T:System.Compiler.PNode">
            <summary>
            PNode: Represents objects pointed by a parameter
            </summary>
        </member>
        <member name="T:System.Compiler.PRefNode">
            <summary>
            PRefNode: Represents a parameter passed by Reference
            </summary>
        </member>
        <member name="T:System.Compiler.POutNode">
            <summary>
            POutNode: Represents an out  parameter
            </summary>
        </member>
        <member name="T:System.Compiler.PByValueNode">
            <summary>
            PByValueNode: Represents a parameter passed by Value
            </summary>
        </member>
        <member name="T:System.Compiler.LNode">
            <summary>
            LNode: Represents a placeholder  for an unknown node(s) read by the instruction
            Typically from instructions like a = b.f with b escaping
            </summary>
        </member>
        <member name="T:System.Compiler.Nodes">
            <summary>
            Set of nodes
            </summary>
        </member>
        <member name="T:System.Compiler.Edge">
            <summary>
            Edge: An edge in the pointsTo graph
            </summary>
        </member>
        <member name="T:System.Compiler.IEdge">
            <summary>
            IEdge: An internal edge. Represents a reference created by the analyzed method (writes)
            </summary>
        </member>
        <member name="T:System.Compiler.OEdge">
            <summary>
            OEdge: An outside edge. Represents a reference to a node outside the analyzed method (reads) 
            </summary>
        </member>
        <member name="T:System.Compiler.StructEdge">
            <summary>
            StructEdge: An edge that connects an Struct Type with another element. 
            It is used to know which elements has to be copied from a struct 
            </summary>
        </member>
        <member name="T:System.Compiler.Edges">
            <summary>
            Set of edges
            </summary>
        </member>
        <member name="T:System.Compiler.LocVar">
            <summary>
            LocVar: A mapping between variables and nodes it may point to.
            This mapping is used to record points to information
            </summary>
        </member>
        <member name="T:System.Compiler.AField">
            <summary>
            AField: A field update. An element of a write effect
            </summary>
        </member>
        <member name="T:System.Compiler.PTExtraField">
            <summary>
            A points-to Graph. This is the structure that represents the points-to information for a program point.
            The model supports Reference types (object subclasses) and struct types. 
            Every program variable has a related node that represents its address. 
            An address node can point to one of several locations (the object/s in the heap). 
            We say that the value/s of an Address are the heap locations that the variable (or address)
            can point to.
            That means, given a = Addr(v), *a represent the actual object abstraction in the heap.
            For struct types Addr(v) directly contains the struct element
            For fields the reasoning is the same. A heap location represent an object (or several) that
            can have several attributes (fields). If the field type is a reference type, it will have
            an address, and the address will point to the heap location representing the field dereference.
            Example: <c>v.f = *((*Addr(v)).f)</c> for v and v.f being reference types. 
            For struct type the reasoning is similar as the addr/value mentioned before. 
            A pointsToGraph G = &lt; I &#44; O &#44; LV &#44; E &gt;
            I = set of inside edges: references generated by the method under analysis
            O = set of outside edges: read refences to elements not known at that program point
            LV = a mapping from variables to the heap locations it may point to (in particular 
            it is a one to one mapping between a variable and its address or associated struct)
            
            There are different kind of nodes. 
            AddrNodes: An address of a variable or field
            LAddrNode: An address node create to reflect a loaded (and unknown) address 
            LNode: A node that represents a loaded (and unknown) object. There are subclasses
            to represent whether the unknown node is a value (content of an address) like LValueNode 
            (and PLNode for parameters values) or a field value (content of a field dereference 
            address) like LFNode
            PNode: A node that represents the address of a parameter. There are subclasses to represent 
            the parameter passing style (PByValue, PByRef, POut)
            InsideNode: A newly created object 
            StructNode: A node that represent a struct value type
            </summary>
        </member>
        <member name="F:System.Compiler.PTGraph.allFields">
            <summary>
            Special fields used for array indexing and pointer 
            </summary>
        </member>
        <member name="F:System.Compiler.PTGraph.parameterNodes">
            <summary>
             The set of parameter nodes
            </summary>
        </member>
        <member name="F:System.Compiler.PTGraph.m">
            <summary>
            The method under analysis
            </summary>
        </member>
        <member name="F:System.Compiler.PTGraph.vRet">
            <summary>
            The return value of the method
            </summary>
        </member>
        <member name="F:System.Compiler.PTGraph.GlobalScope">
            <summary>
            This variable represent a global variable 
            </summary>
        </member>
        <member name="F:System.Compiler.PTGraph.thisParameterNode">
            <summary>
            Represent the location pointed by this 
            </summary>
        </member>
        <member name="F:System.Compiler.PTGraph.parameterMap">
            <summary>
            A mapping to access the parameter nodes using parameters
            </summary>
        </member>
        <member name="M:System.Compiler.PTGraph.Parameter(System.Compiler.PNode)">
            <summary>
            Get the parameter represented by a PNode
            </summary>
            <param name="pn"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.#ctor(System.Compiler.Method)">
            <summary>
            Construct an empty pointsToGraph for the method
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.InitParams(System.Compiler.Method,System.Compiler.Label)">
            <summary>
            Create the parameter nodes for each method's parameter
            It consider the type of parameter passing (value, out, or ref)
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.#ctor(System.Compiler.PTGraph)">
            <summary>
            Copy Constructor
            </summary>
            <param name="ptg"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.AtMost(System.Compiler.PTGraph,System.Compiler.PTGraph)">
            <summary>
             Inclusion test
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.Join(System.Compiler.PTGraph)">
            <summary>
            Join to PointsTo Graphs
            </summary>
            <param name="ptG2"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.InitMethod(System.Compiler.Method,System.Collections.IEnumerable,System.Compiler.Label)">
            <summary>
            f(methodHeader)
            </summary>
            <param name="method"></param>
            <param name="parameters"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.NodesBackwardReachableFrom(System.Compiler.IPTAnalysisNode)">
            <summary>
            Compute the set of backward reachable nodes from n(forward or backward) using I and O edges
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.NodesForwardReachableFrom(System.Compiler.IPTAnalysisNode)">
            <summary>
            Compute the set of forward reachable nodes from n(forward or backward) using I and O edges
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.NodesForwardReachableFromVariable(System.Compiler.Variable,System.Boolean)">
            <summary>
            Used to get only the nodes reachable using owned fields
            The problem is that it is not working because of the "allField" 
            special field.
            </summary>
            <param name="v"></param>
            <param name="onlyOwned"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.NodesForwardReachableFromOnlyOEdges(System.Compiler.IPTAnalysisNode)">
            <summary>
            Compute the set of forward reachable nodes from n(forward or backward) using O edges
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.NodesReachableFrom(System.Compiler.Nodes,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Compute the set of reachable nodes using a set of starting nodes
            </summary>
            <param name="n"></param>
            <param name="forward"></param>
            <param name="useIEdges"></param>
            <param name="useOEdges"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.DFSPathFrom(System.Compiler.IPTAnalysisNode,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Compute the set of maximal paths from n
            </summary>
            <param name="n"></param>
            <param name="forward"></param>
            <param name="useIEdges"></param>
            <param name="useOEdges"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.DFSPathFrom(System.Compiler.IPTAnalysisNode,System.Compiler.Field,System.Boolean,System.Boolean,System.Boolean,System.Compiler.Nodes,System.Collections.Generic.Set{System.Collections.Generic.List{System.Compiler.Edge}},System.Collections.Generic.List{System.Compiler.Edge})">
            <summary>
            The actual computation of the path
            </summary>
            <param name="n"></param>
            <param name="f"></param>
            <param name="forward"></param>
            <param name="useIEdges"></param>
            <param name="useOEdges"></param>
            <param name="visited"></param>
            <param name="res"></param>
            <param name="current"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.AddVariable(System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            Add v1 variable to the mapping LV. If v1 is a reference type, a node representing the reference 
            is added. If it is a struct type, the node directly represent the value
            </summary>
            <param name="v1"></param>
            <param name="lb"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.VerifyAndSetLocationForAssigment(System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            Add a variable and its value to the PTG. 
            </summary>
            <param name="v1"></param>
            <param name="n"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.Assign(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            Assign a potencial values of v2 to v1
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.CheckValues(System.Compiler.Nodes,System.Compiler.Label,System.Compiler.Variable)">
            <summary>
            Check values (nodes pointed by the node(s) that v references) is not empty. If it's empty create a 
            "Value node" representing a read (*loc(v)) 
            </summary>
            <param name="values"></param>
            <param name="lb"></param>
            <param name="v"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.CheckValues(System.Compiler.Nodes,System.Compiler.Label,System.Compiler.IPTAnalysisNode)">
            <summary>
            Check values (nodes pointed by addr) is not empty. If it's empty create a 
            "Value node" representing a read (*addr) 
            </summary>
            <param name="values"></param>
            <param name="lb"></param>
            <param name="addr"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.CheckValues(System.Compiler.Nodes,System.Compiler.Label,System.Compiler.Nodes)">
            <summary>
            Compute Check Values to a set of references. That is, check if every reference points to a value.
            If not, create a Value node to represent a value
            </summary>
            <param name="values"></param>
            <param name="lb"></param>
            <param name="addrs"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.Assign(System.Compiler.Variable,System.Compiler.IPTAnalysisNode,System.Compiler.Label)">
            <summary>
            Assign a value to a variable (that means, if it's a reference a value to the reference node
            or directly to the variable if it's a struct)
            </summary>
            <param name="v1"></param>
            <param name="n"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.Assign(System.Compiler.Variable,System.Compiler.Nodes,System.Compiler.Label)">
            <summary>
            Idem previous but for a set of values 
            </summary>
            <param name="v1"></param>
            <param name="ns"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.Values(System.Compiler.IPTAnalysisNode)">
            <summary>
            Get the set of values pointed by the node
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.Values(System.Compiler.Nodes)">
            <summary>
            Get the union of set of values pointed by the nodes
            </summary>
            <param name="ns"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.GetLocations(System.Compiler.Variable)">
            <summary>
            A variable is a name for a location. It the type is a reference, 
            then the location containts a reference. 
            This method get that reference. 
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.GetLoadNodes(System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Label)">
            <summary>
            </summary>
            <param name="v1Type"></param>
            <param name="v2"></param>
            <param name="f"></param>
            <param name="lb"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.CopyStruct(System.Compiler.IPTAnalysisNode,System.Compiler.IPTAnalysisNode,System.Compiler.Label)">
            <summary>
            Copy contents of Struct srcSn in Struct destSn
            </summary>
            <param name="destSn"></param>
            <param name="srcSn"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.CopyStructForEdges(System.Compiler.IPTAnalysisNode,System.Compiler.IPTAnalysisNode,System.Compiler.Edges,System.Compiler.Label,System.Compiler.Nodes)">
            <summary>
            Copy the contents pointed by a set of edges
            </summary>
            <param name="destSn"></param>
            <param name="srcSn"></param>
            <param name="edges"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.ApplyAssignNull(System.Compiler.Variable)">
            <summary>
            f(v1 = null). v1 points to nothing (is deleted from LV)
            </summary>
            <param name="v1"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.CopyLocVar(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Label)">
            <summary>
            f(v1 = v2) or f(v1 = *v2) or f(v1= &amp;v2) 
            or copy of struct type
            It is an strong update
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="lb"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.ForgetVariable(System.Compiler.Variable)">
            <summary>
            Make p1 points to nothing
            </summary>
            <param name="v1"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.RemoveValues(System.Compiler.Variable)">
            <summary>
            Remove the values assigned to a variable
            </summary>
            <param name="v1"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.RemoveValues(System.Compiler.IPTAnalysisNode)">
            <summary>
            Remove the values assigned to an addr
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:System.Compiler.PTGraph.ApplyAnalyzableCall(System.Compiler.Variable,System.Compiler.Method,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.PTGraph,System.Compiler.Label,System.Compiler.InterProcMapping@)">
            <summary>
            Bind pointsTo graph of the caller with the pointsTo graph of the callee.
            This is the most expensive operation.
            Can be skiped assuming that all calls are non-analyzable.
            </summary>
            <param name="vr"></param>
            <param name="callee"></param>
            <param name="receiver"></param>
            <param name="arguments"></param>
            <param name="calleePTGraph"></param>
            <param name="lb"></param>
            <param name="imp"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PTGraph.BindNonAnalyzedCall(System.Compiler.Variable,System.Compiler.Method,System.Compiler.Variable,System.Compiler.ExpressionList,System.Compiler.Label,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Collections.Generic.Set{System.Compiler.Parameter},System.Collections.Generic.Set{System.Compiler.Parameter},System.Collections.Generic.Set{System.Compiler.Parameter})">
            <summary>
            Updates the caller points to graph to reflect the effect of a call
            to the non-analyzable callee. It generates different values
            for the return value and out parameters and also parameter 
            and global aliasing as parameter escaping
            To drive the effect it has parameters that inform 
            about freshness of return value and out parameters, 
            which parameters escape and whether and how the callee access 
            to global variables and callee purity.
            </summary>
            <param name="vr"></param>
            <param name="callee"></param>
            <param name="receiver"></param>
            <param name="arguments"></param>
            <param name="lb"></param>
            <param name="isPure"></param>
            <param name="isReturnFresh"></param>
            <param name="modifiesGlobal"></param>
            <param name="readsGlobal"></param>
            <param name="escapingParameters"></param>
            <param name="freshParameters"></param>
        </member>
        <member name="T:System.Compiler.Pair`2">
            <summary>
            A Generic Pair
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
        </member>
        <member name="T:System.Compiler.IDelayInfo">
            <summary>
            Exposes computed existential delay information for a method
            </summary>
            
        </member>
        <member name="T:System.Compiler.InitializedVariables">
            <summary>
            Encapsulation for the variable initialization state.
            The state is an equality graph between locations (for tracking refs) and
            each location is mapped to a two point lattice (top unassigned) (bot assigned).
              
            For References, we keep track of the assignment status of the contents of the location
            by mapping terms of the form
            
               ValueOf(s) to assignment lattice elements as well.
               
            For structs, we additionally keep track of field individual assignment status by tracking
            
               Field(Value(s))
               
            In addition, we keep a single set (not program point specific) of
            variables that were assigned, and one set of variables that were 
            referenced. If we find variables at the end that were assigned, but not
            referenced, we issue the C# warning.
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.Canonical(System.Compiler.TypeNode)">
            <summary>
            Due to generics, we see different fields for the same field
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.#ctor(System.Compiler.InitializedVariables)">
            <summary>
            Copy Constructor
            </summary>
            <param name="old"></param>
        </member>
        <member name="M:System.Compiler.InitializedVariables.IsAssigned(System.Compiler.ISymValue)">
            <summary>
            Use only for non-struct values.
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.IsAssigned(System.Compiler.ISymValue,System.Compiler.Struct)">
            <summary>
            Returns null if all fields of the struct are fully assigned, otherwise the field that is not.
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.IsAssignedRef(System.Compiler.Variable,System.Compiler.Struct)">
            <summary>
            </summary>
            <param name="structType">null if no struct type</param>
        </member>
        <member name="M:System.Compiler.InitializedVariables.NonAssignedRefField(System.Compiler.Variable,System.Compiler.Struct)">
            <summary>
            Like IsAssignedRef, but returns null if true, and a witness field if false.
            </summary>
            <param name="structType">Non-null struct type of variable</param>
        </member>
        <member name="M:System.Compiler.InitializedVariables.CanAssumeDelayed(System.Compiler.Variable)">
            <summary>
            Check that value in v is (universally) delayed (and if bottom, make it delayed)
            </summary>
            <param name="v"> </param>
            <returns>true if value is delayed from here on.</returns>
        </member>
        <member name="M:System.Compiler.InitializedVariables.CanAssumeNotDelayed(System.Compiler.Variable)">
            <summary>
            Check that value in v is NOT delayed (and if bottom, make it not delayed)
            </summary>
            <param name="v"></param>
            <returns>true if value is not delayed from here on.</returns>
        </member>
        <member name="M:System.Compiler.InitializedVariables.ElementType(System.Compiler.TypeNode)">
            <summary>
            Returns element type of reference or pointer, otherwise null
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.GetLocalMappingToLoc(System.Compiler.ISymValue)">
            <summary>
            Must follow field edges of value types backwards as well
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.#ctor(System.Compiler.Analyzer)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.Dump">
            <summary>
            Required by IDataFlowAnalysis interface.
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.FilterStackAndTemporaryLocals(System.Int32)">
            <summary>
            Called when a merge point is first encountered. Provides the ability to remove dead variables from
            the state to keep its size down.
            </summary>
            <param name="stackdepth">depth of stack at the beginning of the block</param>
        </member>
        <member name="P:System.Compiler.InitializedVariables.Variables">
            <summary>
            Returns a canonically sorted list of non-temp variables.
            </summary>
        </member>
        <member name="T:System.Compiler.DefAssignLattice">
             <summary>
             Definite assignment and usage analysis.
             
             Definite assignment is about locations, not values. Thus, we use the egraph as follows:
             
             Variables represent locations, thus the symbolic values in the egraph represent location addresses.
             
             We track the status of these locations (assigned, referenced)
             
             To track pointers to locations, we also keep track of terms of the form Value(loc), representing
             the value stored in the location loc.
             
             Thus, an assignment x = y is represented as Value(sym(x)) := Value(sym(y))
             
             
             DELAYED REFERENCES
            
             In order to allow static checking of initialization of circular structures, we introduce the
             notion of a delayed reference. A delayed reference D(T) is a pointer whose type invariants may
             not be valid (and thus observed) until time T. The CLR already has such a notion in the fact that
             "this" is delayed in constructors until the base call.
             We add to this "universally quantified" delays for "This" and other parameters. We track that
             no reads are performed on universally delayed references and that they are stored only in other
             universally delayed references.
             
             Reference types T<amp/> that may point to fields of delayed objects are treated specially. Intuitively,
             these references would have to have the same delay as the pointed to object field.
             Within a method, that is the case. However, the common cases of ref and out parameters that create
             such pointers in regular C#/Spec# code can be handled slightly better.
             Essentially, a delayed reference or a pointer to a field of a delayed reference should never be passed as
             a ref parameter, since it cannot be read prior to initialization.
             On the other hand, passing such pointers as Out parameters seems valid and desirable and in fact does
             not require the parameter to be marked [Delayed], since the out aspect already guarantees initialization
             prior to use. This assumes that the type of the out parameter captures all the invariants that the 
             field should ultimately possess.
             </summary>
        </member>
        <member name="T:System.Compiler.DefAssignLattice.AVal">
            <summary>
            Ordering:
            
              A lt B   iff
              
              !A.Assigned implies !B.Assigned
              and 
              !A.Unassigned implies !B.Unassigned
            </summary>
        </member>
        <member name="M:System.Compiler.DefAssignLattice.AVal.For(System.Boolean,System.Boolean,System.Compiler.DefAssignLattice.Delay)">
            <summary>
            Can round up value.
            </summary>
        </member>
        <member name="T:System.Compiler.MethodDefiniteAssignmentChecker">
             <summary>
             Definite assignment checker.
            
             This checker also makes sure that all non-null fields are properly initialized prior to any possible read accesses.
             There are two cases: 
              1) if the constructor is non-delayed (i.e., the this parameter is not delayed), then the fields must be initialized prior to the 
                 base .ctor call
              2) if the constructor is delayed (guaranteeing that during the constructor execution, no fields of this are ever consulted), then
                 the fields must be initialized by the end of the constructor.
             </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.iVisitor">
            <summary>
            Current instruction visitor.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.currBlock">
            <summary>
            Current Block under analysis.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.typeSystem">
            <summary>
            typeSystem. Only used to file errors and warnings.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.currentMethod">
            <summary>
            Current method being analyzed.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.reportedErrors">
            <summary>
            This is a repository that stores errors that has been reported.
            
            It is used basically as a set. Only used in DefiniteAssignmentInstructorVisitor.check. 
            If the invariant that all variables have their source context holds, then the key in this set 
            could be individual variables. 
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.exitState">
            <summary>
            The exit state. Used to check assigned but not referenced variables.
            </summary>
        </member>
        <member name="M:System.Compiler.MethodDefiniteAssignmentChecker.Check(System.Compiler.TypeSystem,System.Compiler.Method,System.Compiler.Analyzer)">
            <summary>
            Entry point of the check. 
            
            It create a new instance of the checker, and run the checker on the given method.
            </summary>
            <param name="t"></param>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.MethodDefiniteAssignmentChecker.SplitExceptions(System.Compiler.CfgBlock,System.Compiler.IDataFlowState@,System.Compiler.IDataFlowState@)">
            <summary>
            Since we push the state from each block to the exception handler, we don't need to chain them here.
            </summary>
        </member>
        <member name="M:System.Compiler.DefiniteAssignmentInstructionVisitor.VisitLoadElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Loading an element of an array is like accessing a field of an object. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.DefiniteAssignmentInstructionVisitor.MethodCallDelayInstance(System.Compiler.InitializedVariables,System.Compiler.Variable,System.Compiler.Method,System.Compiler.ExpressionList,System.Compiler.Node,System.Int32@)">
            <summary>
            Figure out how to instantiate the quantified delay of the method parameters (if any).
            We assume that each method has the form \forall T. where T is a delay. Parameters with the "Delayed" attribute
            are assumed to have type Delay(T). 
            Given the concrete arguments, this method determines if any parameter whose formal is delayed is actually delayed.
            [existential delay change]
            In addition, put the checking of existential delayed actuals here
            For error diagnostics purpose, we also note the position of the first delay-matched argument
            </summary>
            <param name="receiver"></param>
            <param name="callee"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.DefiniteAssignmentInstructionVisitor.CheckParameterDelay(System.Compiler.InitializedVariables,System.Compiler.Variable,System.Compiler.Method,System.Compiler.Parameter,System.Boolean,System.Compiler.Node,System.Int32,System.Int32)">
            <summary>
            The instantiated formal type is non-delayed unless the parameter is marked delayed and "delayedInstance" is true.
            [Existential Delay Change] When there is only one delayed argument, we allow it to be existential delayed
            This is done by keeping track of the number of possible delay matches. 
            if actual/formal is universal/universal, then this number (possibleDelayMatch) is not changed, we allow it only when
                 the number is not zero (the only way it can be zero at this point (delayinstance is true) is because
                 an existential/universal delay match happened.
            if actual/formal is existential/universal, then match happens only when the number is 1
                 number is changed to zero to disallow future existential/universal match
            Delay match error will be reported as delay not compatible with the witness. If the witness does not have an appropriate delay
            we do not report an error, which will be safe (see comments below).
            </summary>
        </member>
        <member name="T:System.Compiler.ArrayEnumerator">
            <summary>
            Enumerator over a prefix of an array (System.Array.GetEnumerator returns
            an enumerator over ALL the elements of the array).
            </summary>
        </member>
        <member name="M:System.Compiler.ArrayEnumerator.#ctor(System.Object[],System.Int32)">
            <summary>
            Constructs an enumerator  over the first <c>size</c> elements of <c>array</c>.
            NOTE: I couldn't find any way of detecting comodification errors ...
            </summary>
        </member>
        <member name="T:System.Compiler.DataStructUtil">
            <summary>
            Summary description for DataStructsUtil.
            </summary>
        </member>
        <member name="M:System.Compiler.DataStructUtil.IEnum2String(System.Collections.IEnumerable,System.Compiler.DObj2String)">
            <summary>
            Produces a string representation of an <c>IEnumerable</c> object,
            using <c>o2s</c> to produce the string representation of each
            element.
            </summary>
            <param name="eable"></param>
            <param name="o2s"></param>
            <returns></returns>
            
        </member>
        <member name="T:System.Compiler.DObj2String">
            <summary>
            Conversion object -> string. Useful for classes for which we cannot
            modify / override the <c>ToString</c> method. A <c>null</c> value
            should be interpreted as the classic <c>ToString</c> method.
            </summary>
        </member>
        <member name="T:System.Compiler.ICopyable">
            <summary>
            Represents an object that can be copied deeply, as opposed to the shallow ICloneable.
            </summary>
        </member>
        <member name="M:System.Compiler.ISet.Contains(System.Object)">
            <summary>
            Checks whether a given element is part of <c>this</c> set.
            </summary>
            <param name="elem">element searched into the set</param>
            <returns><c>true</c> if <c>elem</c> is in the set, <c>false</c> otherwise</returns>
        </member>
        <member name="T:System.Compiler.Datatype">
            <summary>
            An attempt to make coding with datatypes more pleasant in C#
            </summary>
            <remarks>
            Use <c>Datatype</c> as a base class on each of your abstract data type base classes. When doing
            case analysis on such a value, use the method <c>Tag</c> to get a String representation of the 
            dynamic class name. This can be matched in the <c>case</c> branches of a switch. 
            <p>
            For pairwise matching, use <c>x.Tag + y.Tag</c> and <c>case "Foo"+"Bar"</c>.
            </p>
            Can be extended to compute the set of tags of each abstract datatype instance and utility methods.
            </remarks>
        </member>
        <member name="T:System.Compiler.FList">
            <summary>
            Functional lists. null represents the empty list.
            </summary>
        </member>
        <member name="M:System.Compiler.FList.Intersect(System.Compiler.FList,System.Compiler.FList)">
            <summary>
            Given two sorted lists, compute their intersection
            </summary>
            <param name="l1">sorted list</param>
            <param name="l2">sorted list</param>
            <returns>sorted intersection</returns>
        </member>
        <member name="T:System.Compiler.IMap">
            <summary>
            An abstraction for maps
            </summary>
        </member>
        <member name="T:System.Compiler.HashedMap">
            <summary>
            A Map based on a hashtable.
            </summary>
        </member>
        <member name="M:System.Compiler.HashedMap.Copy">
            <summary>
            Deep copy. Checks if values implement ICopyable. If so, copies them too.
            </summary>
        </member>
        <member name="T:System.Compiler.ListMap">
            <summary>
            A Map based on a ListDictionary
            </summary>
        </member>
        <member name="M:System.Compiler.ListMap.Copy">
            <summary>
            Deep copy. Checks if values implement ICopyable. If so, copies them too.
            </summary>
        </member>
        <member name="T:System.Compiler.IMutableSet">
            <summary>
            Interface for the set abstraction: collection of distinct elements.
            </summary>
        </member>
        <member name="M:System.Compiler.IMutableSet.Add(System.Object)">
            <summary>
            Adds an element to <c>this</c> set.
            </summary>
            <param name="elem">element to add</param>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
            
        </member>
        <member name="M:System.Compiler.IMutableSet.Remove(System.Object)">
            <summary>
            Removes an element from <c>this</c> set. 
            </summary>
            <param name="elem"></param>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
        </member>
        <member name="M:System.Compiler.IMutableSet.AddAll(System.Collections.IEnumerable)">
            <summary>
            Adds several elements from <c>this</c> set.
            </summary>
            <param name="eable"><c>IEnumerable</c> that contains the elements to be added</param>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
        </member>
        <member name="M:System.Compiler.IMutableSet.RemoveAll(System.Collections.IEnumerable)">
            <summary>
            Removes several elements from <c>this</c> set.
            </summary>
            <param name="eable"><c>IEnumerable</c> containing the elements to be removed</param>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
        </member>
        <member name="M:System.Compiler.IMutableSet.Clear">
            <summary>
            Deletes all the elements of <c>this</c> set. As a result the <c>Count</c> property will be <c>0</c>.
            </summary>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
        </member>
        <member name="M:System.Compiler.Set.NonSubsetWitness(System.Compiler.ISet,System.Compiler.ISet)">
            <summary>
            Returns null if A included in B. Otherwise, returns an element in
            A that is not in B.
            </summary>
        </member>
        <member name="T:System.Compiler.NodeSet">
            <summary>
            uses trivial hashtable as its set implementation
            </summary>
        </member>
        <member name="M:System.Compiler.NodeSet.GetEnumerator">
            <summary>
            Has to clean out the ArrayList, since it may contain stale keys.
            </summary>
        </member>
        <member name="T:System.Compiler.HashSet">
             <summary>
             Full implementation of the <c>ISet</c> interface, backed by a <c>Hashtable</c>.
             </summary>
             <remarks>
             As each <c>HashSet</c> is backed by a
             <see cref="T:System.Collections.Hashtable">Hashtable</see>, all requirements that
             apply for the <c>Hashtable</c> keys apply for the elements of a <c>HashSet</c>
             as well.
            
             <p>The <c>HashSet</c> class overrides the methods
             <see cref="M:System.Compiler.HashSet.GetHashCode">GetHashCode</see> and <see cref="M:System.Object.Equals(System.Object)">Equals</see>
             (inherited from <see cref="T:System.Object">Object</see>) in order to provide
             structural equality:
             two sets are equal iff they contain the same elements (where the semantics of "same"
             is defined by the <c>Equals</c> method of those objects).  You can put HashSets into
             HashSets; however, to avoid infinite loops, you should never insert a <c>HashSet</c>
             into itself.
             The hashcode of a <c>HashSet</c> is defined as the "xor" of the hashcodes of the set
             elements. 
             </p>
             
             <p>
             The <c>GetHashCode</c> function of a <c>HashSet</c> executes in <c>O(1)</c> time:
             the hashcode is dynamically updated after each operation that modifies the set.
             If the hashcode functions used for all the other involved objects is good and
             is computed in <c>O(1)</c> time, one element addition and removal execute in
             <c>O(1)</c> time; <c>Equals</c> works in time linear to the number of elements of
             <c>this</c> set.
             </p> 
             </remarks>
        </member>
        <member name="M:System.Compiler.HashSet.#ctor">
            <summary>
            Constructs an empty <c>HashSet</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.HashSet.#ctor(System.Collections.IEnumerable)">
            <summary>
            Constructs a <c>HashSet</c> initialized to contain all
            elements from an <c>IEnumerable</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.IMutableRelation.AddRelation(System.Compiler.IRelation)">
            <summary>
            Adds an entire relation to <d>this</d> relation.
            </summary>
            <param name="relation">Relation that is unioned with this relation.</param>
            <returns><c>true</c> iff <c>this</c> relation changed.</returns>
        </member>
        <member name="T:System.Compiler.Relation">
            <summary>
            Full <c>IMutableRelation</c> implementation.
            </summary>
        </member>
        <member name="M:System.Compiler.Relation.#ctor(System.Compiler.DDictionaryFactory,System.Compiler.DSetFactory)">
            <summary>
            Full power relation constructor that allows you to finely tune the memory consumption.
            Internally, a relation is a dictionary that assigns to each key the set of values that are
            in relation with it.  This constructor allows you to specify the dictionary and the set
            factory.
            </summary>
            <param name="dict_fact">Dictionary factory used to construct the underlying dictionary.</param>
            <param name="set_fact">Set factory used to construct the set that will store the values
            associated with each key.</param>
        </member>
        <member name="M:System.Compiler.Relation.#ctor">
            <summary>
            Default constructor.  Uses the default factory for dictionaries (i.e., equiv. to new Hashtable())
            and sets (i.e., equiv. to new HashSet()).
            </summary>
        </member>
        <member name="M:System.Compiler.Relation.Clone">
            <summary>
            "Shallow" copy of a relation.  Produces an independent copy of <c>this</c> <c>Relation</c>.
            The keys and values are not duplicated.  Operations on the
            resulting <c>Relation</c> and on <c>this</c> <c>Relation</c> don't interact.
            </summary>
            <returns>An independent copy of <c>this</c> Relation.</returns>
        </member>
        <member name="M:System.Compiler.Relation.Copy">
            <summary>
            Deep copy of a relation.  Produces an independent copy of <c>this</c> <c>Relation</c>,
            in which even the keys and values are duplicated (using deep copy) if they implement
            the ICopyable interface.  Operations on the resulting <c>Relation</c> and on <c>this</c>
            <c>Relation</c> don't interact.
            </summary>
            <returns>A really deep copy of <c>this</c> <c>Relation</c>.</returns>
        </member>
        <member name="T:System.Compiler.EnumeratorFilter">
            <summary>
            Returns null if object should not be returned, otherwise, returns object.
            Can thus change objects.
            </summary>
        </member>
        <member name="T:System.Compiler.CompoundEnumerable">
            <summary>
            "Glues" together two <c>IEnumerable</c> objects in a single view.
            </summary>
        </member>
        <member name="M:System.Compiler.CompoundEnumerable.#ctor(System.Collections.IEnumerable,System.Collections.IEnumerable,System.Compiler.EnumeratorFilter,System.Object)">
            <summary>
            Construct an enumerable that enumerators over ieable1, then ieable2. Each element
            is passed to the filter which can decide if the element should be returned by
            the enumerator or not. The filter can also change the element (map).
            </summary>
            <param name="filter">can be null</param>
            <param name="context">passed to filter</param>
        </member>
        <member name="T:System.Compiler.MultiEnumerator">
            <summary>
            Serial composition of two enumerators.  Enumerating with a
            multi-enumerator is equivalent to enumerating with the first enumerator,
            and next with the second one.  Implements the full <c>IEnumerable</c>
            interface.  Aliases to the enumerators are sequentially composed are
            internally stored and used by the encapsulating multi-enumerator.
            </summary>
        </member>
        <member name="M:System.Compiler.MultiEnumerator.#ctor(System.Collections.IEnumerator,System.Collections.IEnumerator,System.Compiler.EnumeratorFilter,System.Object)">
            <summary>
            Creates a <c>MultiEnumerator</c> that serially chains the two
            enumerators passed as arguments.
            </summary>
        </member>
        <member name="T:System.Compiler.UnionEnumerable">
            <summary>
            Union enumerator over two <c>IEnumerable</c> objects. Each key is visited only once
            </summary>
        </member>
        <member name="T:System.Compiler.UnionEnumerator">
            <summary>
            Union composition of two enumerators.  Enumerating with a
            multi-enumerator is equivalent to enumerating over the union of the elements in
            the first and second enumerator.
            </summary>
        </member>
        <member name="M:System.Compiler.UnionEnumerator.#ctor(System.Collections.IEnumerable)">
            <summary>
            Creates a <c>UnionEnumerator</c> over both given enumerators.
            </summary>
        </member>
        <member name="T:System.Compiler.WorkStack">
            <summary>
            Stack-based implementation of IWorkList.
            </summary>
        </member>
        <member name="T:System.Compiler.WorkList">
            <summary>
            Queue-based implementation of IWorkList.
            </summary>
        </member>
        <member name="T:System.Compiler.Compare">
            <summary>
            Returns 0 if x and y are equal, less than 0 if x is less than y and greater than 0 if x is greater than y
            </summary>
        </member>
        <member name="T:System.Compiler.UnionGraphNavigator">
            <summary>
            Navigator for the graph obtained by unioning two graphs.
            </summary>
        </member>
        <member name="M:System.Compiler.UnionGraphNavigator.#ctor(System.Compiler.IGraphNavigator,System.Compiler.IGraphNavigator)">
            <summary>
            Constructs a navigator into a graph which is the union of two graphs
            (where the graphs are seen as edge sets).
            </summary>
            <param name="nav1">Navigator for the first graph.</param>
            <param name="nav2">Navigator for the second graph.</param>
        </member>
        <member name="M:System.Compiler.UnionGraphNavigator.NextNodes(System.Object)">
            <summary>
            In a union graph, the list of successors of a node includes its successors in
            the first graph followed by its successors in the second graph.
            </summary>
        </member>
        <member name="M:System.Compiler.UnionGraphNavigator.PreviousNodes(System.Object)">
            <summary>
            In a union graph, the list of predecessors of a node includes the its predecessors in
            the first graph followed by its predecessors in the second graph.
            </summary>
        </member>
        <member name="T:System.Compiler.BackwardGraphNavigator">
            <summary>
            Navigator for an inverse graph.  The successors (i.e., <c>NextNodes</c>)
            of a node are the predecessors of the node in the original graph.  Analogously
            for the predecessors.
            </summary>
        </member>
        <member name="M:System.Compiler.BackwardGraphNavigator.#ctor(System.Compiler.IGraphNavigator)">
            <summary>
            Constructs a <c>BackwardGraphNavigator</c> that reverses an
            <c>IGraphNavigator</c>.
            </summary>
            <param name="navigator">The navigator that is reversed.</param>
        </member>
        <member name="M:System.Compiler.FilteredGraphNavigator.#ctor(System.Compiler.ISet,System.Compiler.IGraphNavigator)">
            <summary>
            Only nodes in given set are considered part of the graph.
            </summary>
        </member>
        <member name="T:System.Compiler.SccNavigator">
            <summary>
            Navigator in a component graph (an acyclic graph of ISCCs).
            </summary>
        </member>
        <member name="M:System.Compiler.GraphUtil.TopologicallySortGraph(System.Compiler.DSetFactory,System.Collections.IEnumerable,System.Compiler.IGraphNavigator)">
            <summary>
            Topologically sorts the graph rooted in <c>roots</c> and described by
            <c>nav</c>. Throws a <c>CyclicGraphException</c> if the graph contains
            a cycle. Otherwise, returns a topologically sorted list of the graph nodes. 
            The returned list is in ascending order: it starts with the nodes that don't
            have any out-arc (i.e., arcs going out of them) and ends with the nodes
            that don't have any in-arcs (i.e., arcs going into them).  If the navigator
            works in constant time, the topological sort works in time linear with the
            number of nodes plus the number of edges. 
            
            </summary>
        </member>
        <member name="M:System.Compiler.GraphUtil.TopologicallySortComponentGraph(System.Compiler.DSetFactory,System.Collections.IEnumerable)">
            <summary>
            Topologically sorts a component graph: a graph whose nodes are the
            strongly connected components of the original graph (such a graph is
            clearly acyclic). Calls the full-fledged TopSortComponentGraph with
            the standard <c>ISCCNavigator</c>.
            
            </summary>
            <param name="roots">The set of the root SCCs, only the SCCs reachable
            from these roots will be considered by the topological sort.</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.GraphUtil.SearchDepthFirst(System.Collections.IEnumerable,System.Compiler.IGraphNavigator,System.Compiler.DNodePredicate,System.Compiler.DNodeVisitor,System.Compiler.DNodeVisitor,System.Compiler.DNodeVisitor)">
            <summary>
            DFS traversal of the (sub)graph rooted in a set of nodes.
            </summary>
            <param name="roots">Roots of the traversed subgraph. The subgraph
            rooted in the first root will be traversed in DFS order; next, if
            the second root wasn't reached yet, the subgraph rooted in it will
            be traversed in DFS order and so on. The order of
            the roots is given by the corresponding <c>IEnumerator</c>.</param>
            <param name="navigator">Navigator that describes the graph structure.</param>
            <param name="avoid">Encountered nodes that satisfy this predicate will be
            ignored by the DFS traversal (together with their attached arcs). <c>null</c>
            corresponds to the predicate that is always false (i.e., no encountered node
            will be ignored).</param>
            <param name="new_subgraph_visitor">Visitor for the root node of each
            new subgraph: the roots (see the roots parameter)
            are explored in order; if a root node has not been already reached
            by the DFS traversal of the previous roots, <c>new_subgraph_visitor</c>
            will be called on it, and next the subgraph rooted in it will be DFS
            traversed.</param>
            <param name="begin_visitor">Node visitor to be called when a node is reached
            for the first time by the DFS traversal. <c>null</c> corresponds to no
            visitor.</param>
            <param name="end_visitor">Node visitor to be called when the exploration of
            a node has finished. <c>null</c> corresponds to no visitor.</param>
        </member>
        <member name="M:System.Compiler.GraphUtil.dfs(System.Collections.IEnumerable,System.Compiler.IGraphNavigator,System.Compiler.DNodePredicate,System.Compiler.DNodeVisitor,System.Compiler.DNodeVisitor)">
            <summary>
            Convenient <c>DFS</c> function.  Call the full <c>dfs</c> function
            with new_subgraph_visitor set to <c>null</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.GraphUtil.bfs(System.Collections.IEnumerable,System.Compiler.IGraphNavigator,System.Compiler.DNodePredicate,System.Compiler.DNodeVisitor,System.Compiler.DEdgeVisitor)">
            <summary>
            Does a breadth first traversal of the given graph
            </summary>
            <param name="roots">The roots of the traversal.</param>
            <param name="avoid">If not null, is a predicate to avoid certain nodes</param>
            <param name="visitRoot">If not null, called for each root that is not avoided.</param>
            <param name="visitEdge">Called for each edges in the bf traversal, i.e., only for edges going to unvisited nodes.</param>
        </member>
        <member name="T:System.Compiler.Checker">
            <summary>
            Walk IR checking for semantic errors and repairing it so that subsequent walks need not do error checking
            </summary>
        </member>
        <member name="M:System.Compiler.Checker.AutoDereferenceCoercion(System.Compiler.Expression)">
            <summary>
            Can be called after VisitExpression to have expressions of type "reference"
            be automatically dereferenced
            </summary>
        </member>
        <member name="M:System.Compiler.Checker.VisitEnsuresList(System.Compiler.EnsuresList)">
            <summary>
            Need to have this override so that inherited postconditions are not
            checked again. 
            </summary>
            <param name="Ensures"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Checker.CheckContractInheritance(System.Compiler.TypeNode)">
            <summary>
            This method checks all of the methods in a class or structure to make sure that
            if the method implements an interface method (either explicitly or implicitly),
            then the contract inheritance rules are not violated.
            
            It also introduces the default expose block around the body of whichever methods
            should get the default.
            </summary>
            <param name="type">The type that will have all of its methods checked.</param>
        </member>
        <member name="M:System.Compiler.Checker.VisitRequiresList(System.Compiler.RequiresList)">
            <summary>
            Need to have this override so that inherited preconditions are not
            checked again. 
            </summary>
            <param name="Requires"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Checker.CreateProxy(System.Compiler.TypeNode,System.Compiler.Method,System.Compiler.Method)">
            <summary>
            Create a proxy method implementing the abstractMethod and which calls the implementingMethod.
            This is needed when the implementingMethod is supposed to be used for the implementation
            of the abstractMethod, but cannot be because it lives in another assembly or isn't virtual
            or the abstractMethod has an out-of-band contract and the implementingMethod must have
            an identical type signature (i.e., no optional type modifiers for the non-null types).
            </summary>
            <param name="type">The type containing the implementingMethod and to which the
            proxy will be added as a member.</param>
            <param name="abstractMethod">The abstract method that the proxy is an implementation of.</param>
            <param name="implementingMethod">The implementing method that is supposed to implement
            the abstractMethod, but is unable to for various reasons.</param>
            <returns>The newly created proxy method.</returns>
        </member>
        <member name="M:System.Compiler.Checker.CheckForInterfaceImplementationsOfOutOfBandContractedMethods(System.Compiler.TypeNode)">
            <summary>
            If type has an explicit or implicit implementation of a method that has an out-of-band contract,
            then need to create a proxy that has the same signature as the "real" interface
            method and have it call the one the programmer wrote.
            </summary>
            <param name="type">The type whose members should be checked to find such methods.</param>
        </member>
        <member name="M:System.Compiler.Checker.MakeMethodVirtualIfThatWouldMakeItImplementAnInterfaceMethod(System.Compiler.Method)">
             <summary>
            The hidden base method may still end up implementing an interface explicitly implemented by this.currentType.
            Prevent that by marking meth as virtual (and newslot) if that means it gets to implement a local interface method
            </summary>
        </member>
        <member name="M:System.Compiler.Checker.IsLessAccessible(System.Compiler.TypeNode,System.Compiler.TypeNode)">
            <summary>
            returns true if t1 is less accessible than t2
            </summary>
        </member>
        <member name="T:System.Compiler.DGetStatInfo">
            <summary>
            Prints some information attached to a statement.
            </summary>
        </member>
        <member name="T:System.Compiler.DGetBlockInfo">
            <summary>
            Prints some information attached to a block.
            </summary>
        </member>
        <member name="T:System.Compiler.CodePrinter">
            <summary>
            Helper class for printing an ASCII representation of the representation
            produced by CciHelper.
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.b2s(System.Compiler.Block)">
            <summary>
            Convenient version of <c>b2s</c>: <c>b2id</c> is null.
            </summary>
        </member>
        <member name="F:System.Compiler.CodePrinter.BlockShortPrinter">
            <summary>
            Convenient wrapping of <c>CodePrinter.b2s</c>; used in conjunction with
            <c>DataStructUtil.IEnum2String</c> for printing collections of blocks.
            It would have been some much easier to have a nice Block.ToString() method ...
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.b2s(System.Compiler.Block,System.Collections.Hashtable)">
            <summary>
            Returns a string id for "block" based on the integer identified b2id[block].
            If <c>b2id</c> is null, then the block hashcode is used as the block identifier.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodePrinter.PrintMethod(System.IO.TextWriter,System.Compiler.Method)">
            <summary>
            Method pretty-printer.  Note: the method blocks are identified by their 0-based index in the
            method list of blocks.
            </summary>
            <param name="tw">Where to print.</param>
            <param name="method">The method to be printed</param>
        </member>
        <member name="M:System.Compiler.CodePrinter.MethodSignature(System.Compiler.Method)">
            <summary>
            Returns a string describing the signature of <c>method</c>: return type, method name, 
            argument types and names (param names are not really part of the method signature, but
            it's nice to know them anyway). 
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.FullName(System.Compiler.Method)">
            <summary>
            Fully qualified name of <c>method</c>: fullname(declaring_class).method_name
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.PrintBlock(System.IO.TextWriter,System.Compiler.Block,System.Compiler.DGetStatInfo,System.Collections.Hashtable)">
            <summary>
            Block pretty-printer.
            </summary>
            <param name="tw">Where to print.</param>
            <param name="block">What to print</param>
            <param name="get_stat_info">Provider of statement specific information;
            if non-null, it will be called after printing each statement, and its result
            printed too.</param>
            <param name="b2id">Map block -&gt; int identifier; if <c>null</c>, then the block
            UniqueKey is used as block id.</param>
        </member>
        <member name="M:System.Compiler.CodePrinter.PrintBlock(System.IO.TextWriter,System.Compiler.Block)">
            <summary>
            Convenient version of the block pretty-printer, with no statement
            specific information and block.UniqueKey used as block id.
            </summary>
            <param name="tw">Where to print.</param>
            <param name="block">What to print.</param>
        </member>
        <member name="M:System.Compiler.CodePrinter.StatementToString(System.Compiler.Statement)">
            <summary>
            Convenient statement pretty-printer; the <c>b2id</c> map is <c>null</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.SourceContextToString(System.Compiler.Statement)">
            <summary>
            Returns a textual representation of the source context info attached to statement <c>stat</c>.
            </summary>
            <param name="stat">Statement whose source we're interested in.</param>
            <returns>Textual representation of the source context info for <c>stat</c>.</returns>
        </member>
        <member name="M:System.Compiler.CodePrinter.StatementToString(System.Compiler.Statement,System.Collections.Hashtable)">
            <summary>
            Statement pretty-printer.
            </summary>
            <param name="stat">Statement to print</param>
            <param name="b2id">Map block -> integer id; if <c>null</c>, the block UniqueKey will be used instead.</param>
            <returns>String representation of the statement argument.</returns>
        </member>
        <member name="M:System.Compiler.CodePrinter.ExpressionToString(System.Compiler.Expression)">
            <summary>
            Expression pretty-printer.
            </summary>
            <param name="expr">Expression to print.</param>
            <returns>String representation of the expression argument.</returns>
        </member>
        <member name="T:System.Compiler.Compiler">
            <summary>
            This class provides compilation services for various clients such as command line compilers,
            in memory compilers hosted by some application such as Visual Studio, and CodeDom clients such
            as ASP .NET. 
            </summary>
        </member>
        <member name="M:System.Compiler.Compiler.ConstructSymbolTable(System.Compiler.Compilation,System.Compiler.ErrorNodeList)">
            <summary>
            Parses all of the CompilationUnitSnippets in the given compilation, ignoring method bodies. Then resolves all type expressions.
            The resulting types can be retrieved from the module in compilation.TargetModule. The base types, interfaces and 
            member signatures will all be resolved and on an equal footing with imported, already compiled modules and assemblies.
            </summary>
        </member>
        <member name="M:System.Compiler.Compiler.ResolveSymbolTable(System.Compiler.Compilation,System.Compiler.ErrorNodeList)">
            <summary>
            Resolves all type expressions in the given (already parsed) compilation.
            The base types, interfaces and member signatures will all be on an equal footing with signatures from imported, 
            already compiled modules and assemblies.
            </summary>
        </member>
        <member name="M:System.Compiler.Compiler.UpdateSymbolTable(System.Compiler.Compilation,System.Compiler.Document,System.Compiler.Document,System.Compiler.SourceChangeList,System.Compiler.ErrorNodeList)">
            <summary>
            Updates the specified symbol table, substituting changedDocument for originalDocument.
            Fires the OnSymbolTableUpdate event before returning (provided that changes occurred to member signatures).
            </summary>
            <param name="symbolTable">The symbol table to update or replace.</param>
            <param name="originalDocument">The document of a CompilationUnit instance in compilation.</param>
            <param name="changedDocument">A new version of originalDocument.</param>
            <param name="changes">A list of the changes made to orignalDocument in order to derive changedDocument.</param>
            <param name="errors">A list to which errors detected during the update must be added.</param>
            <returns>The given symbol table instance, suitably updated, or a new symbol table that replaces the given table.</returns>
        </member>
        <member name="M:System.Compiler.Compiler.UpdateSymbolTable(System.Compiler.Compilation,System.Compiler.Compilation,System.Compiler.Compilation,System.Compiler.MemberList,System.Compiler.ErrorNodeList)">
            <summary>
            Updates the specified symbol table, given a list of changed members from another Compilation instance
            on which it has a dependency. Does nothing if the symbol table does not refer to any of the changed members.
            Fires the OnSymbolTableUpdate event before returning (provided that changes occurred to member signatures).
            </summary>
            <param name="symbolTable">The symbol table to update or replace.</param>
            <param name="originalReference">The compilation instance to which the given symbol table currently refers.</param>
            <param name="changedReference">The compilation instance to which the updated symbol table must refer to instead of to originalReference.</param>
            <param name="changedMembers">A list of the members defined in originalReference that have changed.</param>
            <param name="errors">A list to which errors detected during the update must be added.</param>
            <returns>The given symbol table instance, suitably updated, or a new symbol table that replaces the given table.</returns>
        </member>
        <member name="M:System.Compiler.Compiler.ApplyDefaultContractAssemblies(System.Compiler.Module,System.Boolean)">
            <summary>
            For each referenced assembly Xyz, looks for a contract assembly named Xyz.Contracts.dll in our installation directory.
            Also looks in the same directory as Xyz (just like the xml and pdb files are looked for automatically)
            </summary>
        </member>
        <member name="M:System.Compiler.Compiler.SaveCompilation(System.Compiler.Compilation,System.Compiler.Module,System.CodeDom.Compiler.CompilerParameters,System.CodeDom.Compiler.CompilerResults)">
            <summary>
            Provides a hook to save things other than just the module.
            </summary>
        </member>
        <member name="M:System.Compiler.Compiler.CompileParseTree(System.Compiler.Compilation,System.Compiler.ErrorNodeList)">
            <summary>
            Translates the given parse tree into a normalized form that is suitable for writing out as CLI IL.
            This translation process is normally accomplished
            by a series of visitors that are language specific derivations of base class visitors provided by
            the Cci code generation framework. The base Compiler class does not call the visitors directly, in
            order to provide language implementations with the opportunity to add or replace visitors.
            </summary>
            <param name="compilation">An IR tree that represents the parse tree for the entire compilation.</param>
            <param name="errorNodes">Errors encountered during the compilation are appended to this list.</param>
        </member>
        <member name="M:System.Compiler.Compiler.CompileParseTree(System.Compiler.Node,System.Compiler.Scope,System.Compiler.Module,System.Compiler.ErrorNodeList)">
            <summary>
            Translates the given parse tree node into a corresponding normalized node.
            If the node is a type node or contains type nodes, the normalized versions of the type nodes
            are added to the target module. Expected to be mainly useful for compiling expressions. 
            </summary>
            <param name="node">An IR tree that represents a parse tree</param>
            <param name="scope">A symbol table for resolving free variables in the parse tree</param>
            <param name="targetModule">A module to which types found in the IR tree are added</param>
            <param name="errorNodes">Errors encountered during the compilation should be appended to this list</param>
        </member>
        <member name="E:System.Compiler.Compiler.OnSymbolTableUpdate">
            <summary>
            This event happens just before UpdateSymbolTable returns, provided that UpdateSymbolTable made any changes.
            </summary>
        </member>
        <member name="T:System.Compiler.Compiler.SymbolTableUpdateEventHandler">
            <summary>
            Called when a symbol table has been updated. The updateSpecification argument specifies how
            the original Compilation instance (symbol table) differs from the updated symbol table. The changedMembers argument
            provides a list of all member signatures that have changed as a result of the recompilation.
            </summary>
        </member>
        <member name="M:System.Compiler.Analysis.PointsTo.PointsToAndEffectsAnnotations.IsAssumedPureMethod(System.Compiler.Method)">
            <summary>
            Determine if a method has to be assumed as Pure.
            That is because it is annotaed as pure or confined
            Or belong to a ser of well know methods (that should be annotated in the future)
            </summary>
            <param name="m"></param>
            <returns></returns>
            
        </member>
        <member name="M:System.Compiler.PreOrder.Compute(System.Compiler.ControlFlowGraph)">
            <summary>
            Compute a pre order (ignoring back edges) of the CFG reachable from the entry node
            
            As a side effect, assigns each block its DF finishing number.
            </summary>
        </member>
        <member name="T:System.Compiler.Normalizer">
            <summary>
            Walks an IR, mutating it into a form that can be serialized to IL+MD by Writer
            </summary>
        </member>
        <member name="M:System.Compiler.Normalizer.NormalizeToPointerCoercion(System.Compiler.BinaryExpression)">
            <summary>
            Hook for other languages to do something different. Normal C# or Spec# don't emit any particular coercion to pointer types.
            </summary>
            <param name="binaryExpr">NodeType.Castclass, Type is Pointer</param>
        </member>
        <member name="M:System.Compiler.Normalizer.CreateTryCatchBlock(System.Compiler.Method,System.Compiler.Block,System.Compiler.Block,System.Compiler.Local)">
            <summary>
            Creates a block containing the given tryBlock and catchBlocks and
            returns it. The method is modified by having new ExceptionHandlers
            added to it which points to the right places in the blocks.
            The type of exception caught by each catch block should be the type
            of the corresponding local l.
            </summary>
            <param name="m">The method in which the try-catch block will be
            inserted into.</param>
            <param name="tryBody">A block of statements that will be the body
            of the try-catch statement.</param>
            <param name="catchBodies">A sequence of blocks; each one contains the
            statements that will be the body of a catch clause on the try-catch statement.
            </param>
            <param name="l">The local into which the exception will be
            assigned. Presumably, the body of the catch clause does something
            with this local.</param>
            <returns>A single block which must be inserted into m by the client.
            </returns>
        </member>
        <member name="M:System.Compiler.Normalizer.MarkAsInstrumentationCode(System.Compiler.Statement)">
            <summary>
            Generates a pre-normalized contract marker block.
            </summary>
        </member>
        <member name="T:System.Compiler.Resolver">
            <summary>
            Walks an IR, mutating it by resolving overloads and inferring expression result types
            Following this, all Indexers, NameBindings, QualifiedIdentifiers, and non built-in operators have been replaced by MemberBindings or MethodCalls 
            and every expression has its Type field filled in.
            (Exception 1: Indexers whose objects are tuples or single dimensional zero based arrays are not replaced.)
            (Exception 2: When resolution fails the NameBindings and QualifiedIdentifiers are not replaced. Checker uses them to generate appropriate errors.)
            </summary>
        </member>
        <member name="F:System.Compiler.Resolver.insideAssertion">
            <summary>
            Are we inside an assert statement, assume statement, loop invariant, requires clause, or ensures clause, but not in an object invariant?
            </summary>
        </member>
        <member name="M:System.Compiler.Resolver.InferMethodTemplateArguments(System.Compiler.TypeNode,System.Compiler.MemberBinding,System.Compiler.TypeNode,System.Compiler.TrivialHashtable)">
            <summary>
            We pass the argument expression in case we are dealing with an implicit delegate construction
            </summary>
            <param name="argExpr">This is the actual argument expression</param>
        </member>
        <member name="M:System.Compiler.Resolver.GetBestMatch(System.Compiler.MemberList,System.Compiler.ExpressionList,System.Compiler.TypeNode[],System.Compiler.TypeNodeList,System.Compiler.Member,System.Compiler.TypeNode@)">
            <summary>
            Go through eligible members (+ bestSoFar) returning the one with the best match to argTypes.
            Returns null if there is no single best match. Sets bestParamTypes to a signature
            that any other member (from a base class) has to equal or better to best overall.
            </summary>
        </member>
        <member name="T:System.Compiler.Passer">
            <summary>
            A passer is used to pass through nodes without acting on them.  All callback will
            be called for each child node of the passed-through node.
            </summary>
        </member>
    </members>
</doc>
