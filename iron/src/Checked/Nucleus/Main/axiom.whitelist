axiom (forall f: int, x: int, y: int :: { v2_u.Je(v2_u.Efl_Cmp(f, x, y)) } v2_u.Je(v2_u.Efl_Cmp(f, x, y)) <==> x == y);
axiom (forall f: int, x: int, y: int :: { v2_u.Jne(v2_u.Efl_Cmp(f, x, y)) } v2_u.Jne(v2_u.Efl_Cmp(f, x, y)) <==> x != y);
axiom (forall f: int, x: int, y: int :: { v2_u.Jbe(v2_u.Efl_Cmp(f, x, y)) } v2_u.Jbe(v2_u.Efl_Cmp(f, x, y)) <==> x <= y);
axiom (forall f: int, x: int, y: int :: { v2_u.Jb(v2_u.Efl_Cmp(f, x, y)) } v2_u.Jb(v2_u.Efl_Cmp(f, x, y)) <==> x < y);
axiom (forall f: int, x: int, y: int :: { v2_u.Jae(v2_u.Efl_Cmp(f, x, y)) } v2_u.Jae(v2_u.Efl_Cmp(f, x, y)) <==> x >= y);
axiom (forall f: int, x: int, y: int :: { v2_u.Ja(v2_u.Efl_Cmp(f, x, y)) } v2_u.Ja(v2_u.Efl_Cmp(f, x, y)) <==> x > y);
axiom (forall i1: int, i2: int :: {:expand false} { v2_u.add(i1, i2): int } v2_u.add(i1, i2): int == i1 + i2);
axiom (forall i1: int, i2: int :: {:expand false} { v2_u.sub(i1, i2): int } v2_u.sub(i1, i2): int == i1 - i2);
axiom (forall i1: int, i2: int :: {:expand false} { v2_u.mul(i1, i2): int } v2_u.mul(i1, i2): int == i1 * i2);
axiom (forall i1: int, i2: int :: {:expand false} { v2_u._div(i1, i2): int } v2_u._div(i1, i2): int == i1 div i2);
axiom (forall i1: int, i2: int :: {:expand false} { v2_u._mod(i1, i2): int } v2_u._mod(i1, i2): int == i1 mod i2);
axiom (forall i1: int, i2: int :: {:expand false} { v2_u.le(i1, i2): bool } v2_u.le(i1, i2): bool <==> i1 <= i2);
axiom (forall i1: int, i2: int :: {:expand false} { v2_u.lt(i1, i2): bool } v2_u.lt(i1, i2): bool <==> i1 < i2);
axiom (forall i1: int, i2: int :: {:expand false} { v2_u.ge(i1, i2): bool } v2_u.ge(i1, i2): bool <==> i1 >= i2);
axiom (forall i1: int, i2: int :: {:expand false} { v2_u.gt(i1, i2): bool } v2_u.gt(i1, i2): bool <==> i1 > i2);
axiom v2_u.EAX == 0;
axiom v2_u.ECX == 1;
axiom v2_u.EDX == 2;
axiom v2_u.EBX == 3;
axiom v2_u.ESI == 4;
axiom v2_u.EDI == 5;
axiom v2_u.EBP == 6;
axiom v2_u.ESP == 7;
axiom v2_u.TMP1 == 0 - 1;
axiom v2_u.TMP2 == 0 - 2;
axiom (forall r: int :: { v2_u.RegOk(r): bool } v2_u.RegOk(r): bool <==> v2_u.EAX <= r && r <= v2_u.ESP);
axiom (forall x: mem_opn :: { v2_u.._mconst(x): int } v2_u.._mconst(x): int == _mconst#MConst(x));
axiom (forall x: mem_opn :: { v2_u.._mreg(x): int } v2_u.._mreg(x): int == _mreg#MReg(x));
axiom (forall x: mem_opn :: { v2_u.._moffset(x): int } v2_u.._moffset(x): int == _moffset#MReg(x));
axiom (forall x: mem_opn :: { v2_u.._mbase(x): int } v2_u.._mbase(x): int == _mbase#MIndex(x));
axiom (forall x: mem_opn :: { v2_u.._mscale(x): int } v2_u.._mscale(x): int == _mscale#MIndex(x));
axiom (forall x: mem_opn :: { v2_u.._mindex(x): int } v2_u.._mindex(x): int == _mindex#MIndex(x));
axiom (forall x: mem_opn :: { v2_u.._moff(x): int } v2_u.._moff(x): int == _moff#MIndex(x));
axiom (forall x: opn :: { v2_u.._const(x): int } v2_u.._const(x): int == _const#OConst(x));
axiom (forall x: opn :: { v2_u.._reg(x): int } v2_u.._reg(x): int == _reg#OReg(x));
axiom (forall x: opn_mem :: { v2_u.._ptr(x): mem_opn } v2_u.._ptr(x): mem_opn == _ptr#OMem(x));
axiom (forall x: mem :: { v2_u..map(x): [int]int } v2_u..map(x): [int]int == map#mem(x));
axiom (forall x: mem :: { v2_u..dom(x): [int]bool } v2_u..dom(x): [int]bool == dom#mem(x));
axiom (forall mem: mem, ptr: int, val: int :: { v2_u.mem_update(mem, ptr, val): mem } v2_u.mem_update(mem, ptr, val): mem == mem(v2_u..map(mem)[ptr := val], v2_u..dom(mem)));
axiom (forall x: regs :: { v2_u.._regs(x): [int]int } v2_u.._regs(x): [int]int == _regs#regs(x));
axiom (forall x: regs :: { v2_u.._efl(x): int } v2_u.._efl(x): int == _efl#regs(x));
axiom (forall r: regs :: { v2_u..regs(r): [int]int } v2_u..regs(r): [int]int == v2_u.._regs(r));
axiom (forall r: regs :: { v2_u..efl(r): int } v2_u..efl(r): int == v2_u.._efl(r));
axiom (forall r: regs, m: mem_opn :: { v2_u.EvalMemOpn(r, m): int } v2_u.EvalMemOpn(r, m): int == (if is#MConst(m) then v2_u.._mconst(m) else (if is#MReg(m) then v2_u..regs(r)[v2_u.._mreg(m)] + v2_u.._moffset(m) else v2_u..regs(r)[v2_u.._mbase(m)] + v2_u.._mscale(m) * v2_u..regs(r)[v2_u.._mindex(m)] + v2_u.._moff(m))));
axiom (forall m: mem_opn :: { v2_u.EvalMemOpnOk(m): bool } v2_u.EvalMemOpnOk(m): bool <==> (if is#MConst(m) then true else (if is#MReg(m) then v2_u.RegOk(v2_u.._mreg(m)) else v2_u.RegOk(v2_u.._mbase(m)) && v2_u.RegOk(v2_u.._mindex(m)))));
axiom (forall r: regs, o: opn :: { v2_u.Eval(r, o): int } v2_u.Eval(r, o): int == (if is#OConst(o) then v2_u.._const(o) else v2_u..regs(r)[v2_u.._reg(o)]));
axiom (forall r: regs, o: opn_mem :: { v2_u.EvalPtr(r, o): int } v2_u.EvalPtr(r, o): int == v2_u.EvalMemOpn(r, v2_u.._ptr(o)));
axiom (forall o: opn_mem :: { v2_u.EvalPtrOk(o): bool } v2_u.EvalPtrOk(o): bool <==> v2_u.EvalMemOpnOk(v2_u.._ptr(o)));
axiom (forall o: opn :: { v2_u.SrcOk(o): bool } v2_u.SrcOk(o): bool <==> (if is#OConst(o) then v2_u.word(v2_u.._const(o)) else v2_u.RegOk(v2_u.._reg(o))));
axiom (forall o: opn :: { v2_u.DstOk(o): bool } v2_u.DstOk(o): bool <==> is#OReg(o) && v2_u.RegOk(v2_u.._reg(o)));
axiom (forall r: regs, c: core_state, m: mem, o: opn_mem :: { v2_u.MemSrcOk(r, c, m, o): bool } v2_u.MemSrcOk(r, c, m, o): bool <==> v2_u.SrcOkViaSegment(r, c, m, v2_u.DS, o));
axiom (forall r: regs, c: core_state, m: mem, o: opn_mem :: { v2_u.MemDstOk(r, c, m, o): bool } v2_u.MemDstOk(r, c, m, o): bool <==> v2_u.DstOkViaSegment(r, c, m, v2_u.DS, o));
axiom (forall r__BEAT: regs, core__BEAT: core_state, m__BEAT: mem, o__BEAT: opn_mem :: { v2_u.LogicalSrcOk(r__BEAT, core__BEAT, m__BEAT, o__BEAT): bool } v2_u.LogicalSrcOk(r__BEAT, core__BEAT, m__BEAT, o__BEAT): bool <==> v2_u.EvalPtrOk(o__BEAT) && v2_u.PhysPtrOk(m__BEAT, v2_u.EvalPtr(r__BEAT, o__BEAT)) && v2_u.word(v2_u.EvalPtr(r__BEAT, o__BEAT)) && (v2_u.paging_enabled(core__BEAT) ==> !v2_u.in_guard_region(v2_u.EvalPtr(r__BEAT, o__BEAT))));
axiom (forall init__BEAT: bool, r__BEAT: regs, core__BEAT: core_state, m__BEAT: mem, o__BEAT: opn_mem :: { v2_u.LogicalDstOk(init__BEAT, r__BEAT, core__BEAT, m__BEAT, o__BEAT): bool } v2_u.LogicalDstOk(init__BEAT, r__BEAT, core__BEAT, m__BEAT, o__BEAT): bool <==> v2_u.EvalPtrOk(o__BEAT) && v2_u.PhysPtrOk(m__BEAT, v2_u.EvalPtr(r__BEAT, o__BEAT)) && v2_u.word(v2_u.EvalPtr(r__BEAT, o__BEAT)) && (init__BEAT ==> !v2_u.in_guard_region(v2_u.EvalPtr(r__BEAT, o__BEAT)) && !v2_u.between(v2_u.?ptLo, v2_u.?ptHi, v2_u.EvalPtr(r__BEAT, o__BEAT))));
axiom (forall m__BEAT: mem, r__BEAT: regs, o__BEAT: opn_mem :: { v2_u.LogicalEval(m__BEAT, r__BEAT, o__BEAT): int } v2_u.LogicalEval(m__BEAT, r__BEAT, o__BEAT): int == map#mem(m__BEAT)[v2_u.EvalPtr(r__BEAT, o__BEAT)]);
axiom (forall stacksFrames__BEAT: [int]Frames, i__BEAT: int :: { v2_u.frameGet(stacksFrames__BEAT, i__BEAT): int } v2_u.frameGet(stacksFrames__BEAT, i__BEAT): int == Abss#Frames(stacksFrames__BEAT[0])[i__BEAT]);
axiom (forall n__BEAT: int, argRet__BEAT: int, sMem__BEAT: mem, $esp__BEAT: int, $RET__BEAT: ReturnTo :: { v2_u.SMemRequireGcRA(n__BEAT, argRet__BEAT, sMem__BEAT, $esp__BEAT, $RET__BEAT): bool } v2_u.SMemRequireGcRA(n__BEAT, argRet__BEAT, sMem__BEAT, $esp__BEAT, $RET__BEAT): bool <==> v2_u.SMemRequire(n__BEAT, sMem__BEAT, $esp__BEAT) && v2_u.?sLo + n__BEAT <= $esp__BEAT && $esp__BEAT + argRet__BEAT <= v2_u.?sHi - 4 && v2_u.ReturnToAddr(map#mem(sMem__BEAT)[$esp__BEAT]) == $RET__BEAT);
axiom (forall argRet__BEAT: int, sMem__BEAT: mem, oldSMem__BEAT: mem, $esp__BEAT: int, oldEsp__BEAT: int, sAbs__BEAT: [int]int, oldSAbs__BEAT: [int]int :: { v2_u.SMemInvGc(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, sAbs__BEAT, oldSAbs__BEAT): bool } v2_u.SMemInvGc(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, sAbs__BEAT, oldSAbs__BEAT): bool <==> $esp__BEAT == oldEsp__BEAT && map#mem(sMem__BEAT)[$esp__BEAT] == map#mem(oldSMem__BEAT)[$esp__BEAT] && (forall i__BEAT__BEAT: int :: { map#mem(sMem__BEAT)[i__BEAT__BEAT] } $esp__BEAT + argRet__BEAT <= i__BEAT__BEAT ==> map#mem(sMem__BEAT)[i__BEAT__BEAT] == map#mem(oldSMem__BEAT)[i__BEAT__BEAT]) && (forall i__BEAT__BEAT: int :: { sAbs__BEAT[i__BEAT__BEAT] } $esp__BEAT + argRet__BEAT + v2_u.stackGcOffset <= i__BEAT__BEAT ==> sAbs__BEAT[i__BEAT__BEAT] == oldSAbs__BEAT[i__BEAT__BEAT]));
axiom (forall argRet__BEAT: int, sMem__BEAT: mem, oldSMem__BEAT: mem, $esp__BEAT: int, oldEsp__BEAT: int, stacksFrames__BEAT: [int]Frames, oldStacksFrames__BEAT: [int]Frames :: { v2_u.SMemInvGcF(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, stacksFrames__BEAT, oldStacksFrames__BEAT): bool } v2_u.SMemInvGcF(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, stacksFrames__BEAT, oldStacksFrames__BEAT): bool <==> v2_u.SMemInvGc(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, Abss#Frames(stacksFrames__BEAT[v2_u.$S]), Abss#Frames(oldStacksFrames__BEAT[v2_u.$S])));
axiom (forall argRet__BEAT: int, sMem__BEAT: mem, oldSMem__BEAT: mem, $esp__BEAT: int, oldEsp__BEAT: int, sAbs__BEAT: [int]int, oldSAbs__BEAT: [int]int :: { v2_u.SMemEnsureGc(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, sAbs__BEAT, oldSAbs__BEAT): bool } v2_u.SMemEnsureGc(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, sAbs__BEAT, oldSAbs__BEAT): bool <==> $esp__BEAT == oldEsp__BEAT + 4 && (forall i__BEAT__BEAT: int :: { map#mem(sMem__BEAT)[i__BEAT__BEAT] } $esp__BEAT + argRet__BEAT <= i__BEAT__BEAT ==> map#mem(sMem__BEAT)[i__BEAT__BEAT] == map#mem(oldSMem__BEAT)[i__BEAT__BEAT]) && (forall i__BEAT__BEAT: int :: { sAbs__BEAT[i__BEAT__BEAT] } $esp__BEAT + argRet__BEAT + v2_u.stackGcOffset <= i__BEAT__BEAT ==> sAbs__BEAT[i__BEAT__BEAT] == oldSAbs__BEAT[i__BEAT__BEAT]));
axiom (forall argRet__BEAT: int, sMem__BEAT: mem, oldSMem__BEAT: mem, $esp__BEAT: int, oldEsp__BEAT: int, stacksFrames__BEAT: [int]Frames, oldStacksFrames__BEAT: [int]Frames :: { v2_u.SMemEnsureGcF(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, stacksFrames__BEAT, oldStacksFrames__BEAT): bool } v2_u.SMemEnsureGcF(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, stacksFrames__BEAT, oldStacksFrames__BEAT): bool <==> v2_u.SMemEnsureGc(argRet__BEAT, sMem__BEAT, oldSMem__BEAT, $esp__BEAT, oldEsp__BEAT, Abss#Frames(stacksFrames__BEAT[v2_u.$S]), Abss#Frames(oldStacksFrames__BEAT[v2_u.$S])));
