<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.PowerPack.Metadata</name></assembly>
<members>
<member name="T:FSharp.PowerPack.Metadata.FSharpAccessibility">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpAssembly.ReflectionAssembly">
<summary>
 Return the System.Reflection.Assembly object for the assembly
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpAssembly.QualifiedName">
<summary>
 Holds the full qualified assembly name
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpAssembly.FSharpLibrary">
<summary>
 Get the object representing the F# core library (FSharp.Core.dll) for the running program
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpAssembly.Entities">
<summary>
 A handle to the full specification of the contents of the module contained in this Assembly 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpAssembly.CodeLocation">
<summary>
 A hint as to where does the code for the CCU live (e.g what was the tcConfig.implicitIncludeDir at compilation time for this DLL?) 
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.FSharpAssembly.GetEntity(System.String)">
<summary>
 Return the System.Reflection.Assembly object for the assembly
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.FSharpAssembly.FromFile(System.String)">
<summary>
 This is one way of starting the loading process off. 
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.FSharpAssembly.FromAssembly(System.Reflection.Assembly)">
<summary>
 This is one way of starting the loading process off. Dependencies are automatically
 resolved by calling System.Reflection.Assembly.Load.
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpAssembly">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpAttribute.Value">

</member>
<member name="M:FSharp.PowerPack.Metadata.FSharpAttribute.GetReflectionType">

</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpAttribute">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.XmlDoc">
<summary>
 The declared documentation for the type or module 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.UsesPrefixDisplay">
<summary>
 Indicates the type prefers the "tycon&lt;a,b&gt;" syntax for display etc. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.UnionCases">
<summary>
 The cases of a discriminated union
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.RecordFields">
<summary>
 The fields of the class, struct or enum 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.Range">
<summary>
 The declaration location for the type constructor 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.QualifiedName">
<summary>
 Get the fully qualified name of the type or module
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.NestedEntities">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.Name">
<summary>
 The name of the type, possibly with `n mangling  
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.MembersOrValues">
<summary>
 Properties, methods etc. with implementations, also values in a module
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.IsStruct">
<summary>
 Indicates the type is a struct
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.IsModule">
<summary>
 Indicates the entity is an F# module definition
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.IsMeasure">
<summary>
 Indicates the entity is a measure definition
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.IsExternal">
<summary>
 If true, then this is a reference to something in some .NET assembly from another .NET language
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.IsExceptionDeclaration">
<summary>
 Indicates an F# exception declaration
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.IsAbbreviation">
<summary>
 Indicates the type is a measure, type or exception abbreviation
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.Implements">
<summary>
 Interface implementations - boolean indicates compiler-generated 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.HasFSharpModuleSuffix">
<summary>
 Indicates that a module is compiled to a class with the given mangled name. The mangling is reversed during lookup 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.HasAssemblyCodeRepresentation">
<summary>
 Indicates the type is implemented through a mapping to IL assembly code. THis is only
 true for types in FSharp.Core.dll
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.GenericParameters">
<summary>
 Get the generic parameters, possibly including unit-of-measure parameters
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.BaseType">
<summary>
 Base type, if any 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.Attributes">
<summary>
 The declared attributes for the type 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpEntity.AbbreviatedType">

</member>
<member name="M:FSharp.PowerPack.Metadata.FSharpEntity.GetReflectionType">
<summary>
 Return the System.Type for the type

 Raises InvalidOperationException if the type is an abbreviation or has an assembly code representation.
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.FSharpEntity.FromType(System.Type)">
<summary>
 Return the FSharpEntity corresponding to a .NET type
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpEntity">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpGenericParameter.XmlDoc">
<summary>
 The documentation for the type parameter. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpGenericParameter.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpGenericParameter.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpGenericParameter.IsSolveAtCompileTime">
<summary>
 Is this a ^a type variable
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpGenericParameter.IsMeasure">
<summary>
 Is this a measure variable
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpGenericParameter.Attributes">
<summary>
 The declared attributes of the type parameter. 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpGenericParameter">

</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpGenericParameterConstraint">
<summary>
 An F# discriminated union, as an object model
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpInlineAnnotation">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.XmlDoc">
<summary>
 XML documentation attached to a value.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.Type">
<summary>
 The full type of the member or value when used as a first class value
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.ReturnParameter">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.IsTypeFunction">
<summary>
 Is this an F# type function
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.IsMutable">
<summary>
 Is this a mutable value
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.IsModuleValueOrMember">
<summary>
 Is this a module or member value
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.IsImplicitConstructor">
<summary>
 Is this an implicit constructor?
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.IsExtensionMember">
<summary>
 Is this an extension member?
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.IsCompilerGenerated">
<summary>
 Is this a compiler generated value
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.InlineAnnotation">
<summary>
 Is this a must-inline value
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.GenericParameters">
<summary>
 The typars of the member or value
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.CurriedParameterGroups">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.CompiledName">
<summary>
 The member name in compiled code
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpMemberOrVal.Attributes">
<summary>
 Custom attributes attached to the value. These contain references to other values (i.e. constructors in types). Mutable to fixup  
 these value references after copying a colelction of values. 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpMemberOrVal">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpParameter.Type">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpParameter.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpParameter.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpParameter.Attributes">

</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpParameter">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpRecordField.XmlDoc">
<summary>
 Documentation for the field 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpRecordField.Type">
<summary>
 The type of the field, w.r.t. the generic parameters of the enclosing type constructor 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpRecordField.Range">
<summary>
 Declaration-location of the field 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpRecordField.PropertyAttributes">
<summary>
 Attributes attached to generated property 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpRecordField.Name">
<summary>
 Name of the field 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpRecordField.IsStatic">
<summary>
 Indicates a static field 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpRecordField.IsMutable">
<summary>
 Is the field declared in F#? 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpRecordField.IsCompilerGenerated">
<summary>
 Indicates a compiler generated field, not visible to Intellisense or name resolution 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpRecordField.FieldAttributes">
<summary>
 Attributes attached to generated field 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpRecordField">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpType.NamedEntity">
<summary>
 Get the named entity for a type constructed using a named entity
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpType.IsTuple">
<summary>
 Indicates the type is a tuple type. The GenericArguments property returns the elements of the tuple type.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpType.IsNamed">
<summary>
 Indicates the type is constructed using a named entity
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpType.IsGenericParameter">
<summary>
 Indicates the type is a variable type, whether declared, generalized or an inference type parameter  
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpType.IsFunction">
<summary>
 Indicates the type is a function type. The GenericArguments property returns the domain and range of the function type.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpType.GenericParameterIndex">
<summary>
 Get the index for a generic parameter type
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpType.GenericParameter">
<summary>
 Get the generic parameter data for a generic parameter type
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpType.GenericArguments">
<summary>
 Get the generic arguments for a tuple type, a function type or a type constructed using a named entity
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpType">

</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpUnionCase.XmlDoc">
<summary>
 Documentation for the case 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpUnionCase.ReturnType">
<summary>
 Return type constructed by the case. Normally exactly the type of the enclosing type, sometimes an abbreviation of it 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpUnionCase.Range">
<summary>
 Range of the name of the case 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpUnionCase.Name">
<summary>
 Name of the case 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpUnionCase.Fields">
<summary>
 Data carried by the case. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpUnionCase.CompiledName">
<summary>
 Name of the case in generated IL code 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.FSharpUnionCase.Attributes">
<summary>
 Attributes, attached to the generated static method to make instances of the case 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.FSharpUnionCase">

</member>
<member name="P:FSharp.PowerPack.Metadata.Range.StartLine">

</member>
<member name="P:FSharp.PowerPack.Metadata.Range.StartColumn">

</member>
<member name="P:FSharp.PowerPack.Metadata.Range.EndLine">

</member>
<member name="P:FSharp.PowerPack.Metadata.Range.EndColumn">

</member>
<member name="P:FSharp.PowerPack.Metadata.Range.Document">

</member>
<member name="T:FSharp.PowerPack.Metadata.Range">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.Alignment">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.AssemblyRefData">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ExportedTypesMap">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.Guid">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILArgumentConvention">
<summary>
 Calling conventions.  These are used in method pointer types.
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILArithInstr">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILArrayBound">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILArrayBounds">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILArrayShape.Rank">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILArrayShape">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyLongevity">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.Version">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.SecurityDecls">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.Retargetable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.PublicKey">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.Locale">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.JitTracking">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.ExportedTypes">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.EntrypointElsewhere">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.DisableJitOptimizations">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.CustomAttrs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.AuxModuleHashAlgorithm">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest.AssemblyLongevity">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyManifest">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef.Version">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef.Retargetable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef.QualifiedName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef.PublicKey">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef.Locale">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef.Hash">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef.FromAssembly(System.Reflection.Assembly)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef.Create(System.String,Microsoft.FSharp.Core.Option`1{System.Byte[]`1},Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PublicKey},System.Boolean,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Core.Tuple`4{System.UInt16,System.UInt16,System.UInt16,System.UInt16}},Microsoft.FSharp.Core.Option`1{System.String})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef..ctor(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.AssemblyRefData)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef">
<summary>
 Global state: table of all assembly references keyed by AssemblyRefData
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAttribute.Method">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAttribute.Data">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAttribute">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAttributeElement">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAttributeNamedArg">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAttributes">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILBasicBlock.Label">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILBasicBlock.Instructions">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILBasicBlock">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILBasicType">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILBoxity">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv.ThisConv">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv.Static">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv.IsStatic">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv.IsInstanceExplicit">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv.IsInstance">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv.Instance">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv.BasicConv">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingSignature.ReturnType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingSignature.CallingConv">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingSignature.ArgTypes">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingSignature">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCode">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCodeLabel">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILComparisonInstr">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILConstSpec">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILDebugMapping.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILDebugMapping.LocalVarIndex">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILDebugMapping">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILDefaultPInvokeEncoding">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDef.Type">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDef.RemoveMethod">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDef.OtherMethods">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDef.FireMethod">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDef.CustomAttrs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDef.AddMethod">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDefs">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExceptionBlock">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedType.ScopeRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedType.Nested">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedType.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedType.IsForwarder">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedType.CustomAttrs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedType.Access">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedType">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedTypes">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.Type">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.Offset">
<summary>
 The explicit offset in bytes when explicit layout is used.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.NotSerialized">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.Marshal">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.LiteralValue">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.IsStatic">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.IsLiteral">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.IsInitOnly">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.Data">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.CustomAttrs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.Access">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDefs">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldInit">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldRef.Type">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldRef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldRef.EnclosingTypeRef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldSpec.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldSpec.FormalType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldSpec.FieldRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldSpec.EnclosingTypeRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldSpec.EnclosingType">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldSpec.ToString">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldSpec">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFilterBlock">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericArgs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericParameterDef.Variance">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericParameterDef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericParameterDef.HasReferenceTypeConstraint">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericParameterDef.HasNotNullableValueTypeConstraint">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericParameterDef.HasDefaultConstructorConstraint">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericParameterDef.Constraints">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericParameterDef.ToString">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericParameterDef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericParameterDefs">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILGenericVariance">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILInstr">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMemberAccess">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodBody">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.SourceMarker">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.SecurityDecls">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.Return">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.Parameters">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.ParameterTypes">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.MethodBody">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.MaxStack">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.Locals">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsZeroInit">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsVirtual">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsUnmanagedExport">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsSynchronized">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsStatic">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsReqSecObj">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsPreserveSig">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsNonVirtualInstance">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsNoInline">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsNewSlot">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsMustRun">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsManaged">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsInternalCall">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsIL">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsHideBySig">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsForwardRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsFinal">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsEntrypoint">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsConstructor">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsClassInitializer">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsCheckAccessOnOverride">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.IsAbstract">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.HasSecurity">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.GenericParams">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.CustomAttrs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.Code">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.CallingConv">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef.Access">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodDefs">
<summary>
 Index table by name and arity. 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodImplDef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodImplDefs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.ReturnType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.GenericArity">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.EnclosingTypeRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.CallingSignature">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.CallingConv">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.ArgTypes">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.ArgCount">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef.Create(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv,System.String,System.Int32,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType},FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.MethodRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.GenericArity">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.GenericArgs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.FormalReturnType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.FormalArgTypes">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.EnclosingType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.CallingConv">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec.Create(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodVirtualInfo.IsNewSlot">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodVirtualInfo.IsFinal">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodVirtualInfo.IsCheckAccessOnOverride">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodVirtualInfo.IsAbstract">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodVirtualInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.VirtualAlignment">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.TypeDefs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.SubSystemFlags">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.Resources">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.Platform">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.PhysicalAlignment">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.NativeResources">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.ManifestOfAssembly">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.Manifest">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.IsILOnly">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.IsDLL">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.Is64Bit">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.Is32Bit">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.ImageBase">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef.CustomAttrs">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleDef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleRef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleRef.Hash">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleRef.HasMetadata">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleRef.Create(System.String,System.Boolean,Microsoft.FSharp.Core.Option`1{System.Byte[]`1})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleRef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILNativeType">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILNativeVariantType">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILNestedExportedType">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILNestedExportedTypes">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter.Type">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter.Marshal">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter.IsOut">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter.IsOptional">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter.IsIn">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter.Default">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter.CustomAttrs">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPermission">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPermissions">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPlatform">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPropertyDef.Type">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPropertyDef.SetMethod">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPropertyDef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPropertyDef.Init">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPropertyDef.GetMethod">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPropertyDef.CustomAttrs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPropertyDef.CallingConv">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPropertyDef.Args">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPropertyDef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILResource.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILResource.Location">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILResource.CustomAttrs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILResource.Access">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILResource">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILResourceAccess">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILResourceLocation">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILResources">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILReturnValue.Type">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILReturnValue.Marshal">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILReturnValue.CustomAttrs">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILReturnValue">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.QualifiedNameWithNoShortMscorlib">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.QualifiedName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.ModuleRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.Local">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.IsModuleRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.IsLocalRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.IsAssemblyRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.AssemblyRef">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.Module(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILModuleRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef.Assembly(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSecurityAction">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceDocument.Vendor">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceDocument.Language">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceDocument.File">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceDocument.DocumentType">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceDocument.Create(Microsoft.FSharp.Core.Option`1{System.Byte[]`1},Microsoft.FSharp.Core.Option`1{System.Byte[]`1},Microsoft.FSharp.Core.Option`1{System.Byte[]`1},System.String)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceDocument">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceMarker.Line">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceMarker.EndLine">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceMarker.EndColumn">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceMarker.Document">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceMarker.Column">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceMarker.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceMarker.Create(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceDocument,System.Int32,System.Int32,System.Int32,System.Int32)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILSourceMarker">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILThisConvention">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTokenSpec">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType.TypeSpec">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType.TypeRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType.QualifiedNameWithNoShortMscorlib">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType.IsTyvar">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType.IsNominal">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType.GenericArgs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType.Boxity">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType.BasicQualifiedName">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType.AddQualifiedNameExtensionWithNoShortMscorlib(System.String)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.SecurityDecls">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Properties">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.NestedTypes">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Methods">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.MethodImpls">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Layout">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsValueType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsSpecialName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsSerializable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsSealed">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsInterface">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsEnum">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsDelegate">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsComInterop">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsClass">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.IsAbstract">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.InitSemantics">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Implements">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.HasSecurity">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.GenericParams">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Fields">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Extends">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Events">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Encoding">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.CustomAttrs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef.Access">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefAccess">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefInitSemantics">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefKind">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefLayout">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefLayoutInfo.Size">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefLayoutInfo.Pack">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefLayoutInfo">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.Scope">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.QualifiedNameWithNoShortMscorlib">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.QualifiedName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.FullName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.Enclosing">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.BasicQualifiedName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.ApproxId">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.System-IComparable-CompareTo(System.Object)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.GetHashCode">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.Equals(System.Object)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.Create(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList`1{System.String},System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef.AddQualifiedNameExtensionWithNoShortMscorlib(System.String)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.TypeRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.Scope">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.GenericArgs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.Enclosing">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.BasicQualifiedName">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.Create(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.AddQualifiedNameExtensionWithNoShortMscorlib(System.String)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILVersionInfo">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.IlxExtensionInstr">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.IlxExtensionType">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.IlxExtensionTypeKind">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.LazyMethodBody">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.LazyOrderedMultiMap`2.Item(``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.LazyOrderedMultiMap`2.Filter(Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.LazyOrderedMultiMap`2.Entries">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.LazyOrderedMultiMap`2.Add(``1)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.LazyOrderedMultiMap`2..ctor(Microsoft.FSharp.Core.FastFunc`2{``1,``0},Microsoft.FSharp.Control.Lazy`1{Microsoft.FSharp.Collections.FSharpList`1{``1}})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.LazyOrderedMultiMap`2">
<summary>
 This is used to store event, property and field maps.

 Review: this is not such a great data structure.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.Local.Type">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.Local.IsPinned">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.Local">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.Locale">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.MethodBody">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.MethodCodeKind">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.MethodDefMap">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.MethodImplsMap">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.MethodKind">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.NamespaceAndTypename">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.NestedExportedTypesMap">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.OverridesSpec.MethodRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.OverridesSpec.EnclosingType">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.OverridesSpec">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeCallingConvention">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeCharBestFit">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeCharEncoding">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeMethod.Where">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeMethod.ThrowOnUnmappableChar">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeMethod.NoMangle">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeMethod.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeMethod.LastError">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeMethod.CharEncoding">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeMethod.CharBestFit">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeMethod.CallingConv">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeMethod">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PInvokeThrowOnUnmappableChar">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PropertyDefs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PublicKey.KeyToken">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PublicKey.Key">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PublicKey.IsKeyToken">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PublicKey.IsKey">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PublicKey.ToToken">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PublicKey.KeyAsToken(System.Byte[]`1)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PublicKey">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ReadonlySpec">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.Tailcall">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.TypeDefsMap">
<summary>
 keyed first on namespace then on type name.  The namespace is often a unique key for a given type map.
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.Volatility">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.varargs">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.b0(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.b1(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.b2(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.b3(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.callconv_eq(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_custom_attrs(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILAttributes)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_edefs(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDefs)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_exported_types(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedTypes)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_fdefs(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDefs)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_lazy_tdefs(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefs)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_mbody(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.LazyMethodBody)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_mimpls(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodImplDefs)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_mspec(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_nested_exported_types(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILNestedExportedTypes)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_pdefs(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PropertyDefs)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_resources(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILResources)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_security_decls(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILPermissions)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.dest_tdefs(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefs)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.emptyStringArray">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.find_edefs(System.String,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILEventDefs)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.find_exported_type(System.String,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILExportedTypes)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.find_fdefs(System.String,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDefs)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.find_pdefs(System.String,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.PropertyDefs)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.find_tdef(System.String,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDefs)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.instance_callconv">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.lazy_map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Control.Lazy`1{``0})">
<summary>
 A little ugly, but the idea is that if a data structure does not 
 contain lazy values then we don't add laziness.  So if the thing to map  
 is already evaluated then immediately apply the function.  
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.memoize_namespace_array_tab">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.memoize_namespace_tab">
<summary>
 Global State. All namespace splits
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.mk_callsig(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingConv,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType},FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.mk_empty_gactuals">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.mk_empty_gparams">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.mk_lazy_mbody(Microsoft.FSharp.Control.Lazy`1{FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.MethodBody})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.mk_mbody(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.MethodBody)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.notlazy``1(``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.qrescope_scoref(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.qrescope_tref(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.qrescope_tspec(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_callsig(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILCallingSignature)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_dloc(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_fref(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_fspec(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILFieldSpec)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_inst(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_mref(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_mspec(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILMethodSpec)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_ospec(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.OverridesSpec)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_scoref(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_tref(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_tspec(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.rescope_typ(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILType)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.sha1_hash_bytes(System.Byte[]`1)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.split_name_at(System.String,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.split_namespace(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.split_namespace_array(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.split_namespace_aux(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.split_namespace_memoized(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.split_type_name(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.split_type_name_array(System.String)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.static_callconv">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.typs_of_params(Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILParameter})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.unsplit_type_name(Microsoft.FSharp.Collections.FSharpList`1{System.String},System.String)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.chan">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_instream">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.f(System.Int32,System.Int32,System.Int32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.k(System.Int32)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.k0to19">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.k20to39">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.k40to59">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.k60to79">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.lsr(System.Int32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.rot_left32(System.Int32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha1_hash(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_instream)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha1_hash_bytes(System.Byte[]`1)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_after_eof(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_instream)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_eof(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_instream)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_read32(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_instream)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_read8(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1.sha_instream)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.SHA1">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.PickledDataWithReferences`1.OptionalFixup(Microsoft.FSharp.Core.FastFunc`2{System.String,Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk}})">
<summary>
 Like Fixup but loader may return None, in which case there is no fixup.
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.PickledDataWithReferences`1.Fixup(Microsoft.FSharp.Core.FastFunc`2{System.String,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.PickledDataWithReferences`1">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.osgn_inmap`2.Get(System.Int32)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.osgn_inmap`2">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.sizes">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.tbl`1">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.unpickler`1">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.UnpickleModuleInfo(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.add_entry``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.tbl`1{``0},``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.decode_ccuref``1(``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.decode_nlpath(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{System.String},System.Int32,System.Int32[]`1)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.decode_pubpath(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{System.String},System.Int32[]`1,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.decode_simpletyp``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{System.String},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath},System.Int32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.decode_string``1(``0)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.decode_tab">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.decoders">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.dummy``1(``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.encode_ccuref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.tbl`1{System.String},FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.encode_instr(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILInstr)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.encode_string``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.tbl`1{``0},``0)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.encode_table">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.encode_uniq``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.tbl`1{``0},``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ffailwith``1(System.String,System.String)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_Exprs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_FlatExprs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_FlatVals">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_Vals">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_attribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_binds">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_constraints">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_iltyp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_targets">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.fill_u_typ">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.find_or_add_entry``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.tbl`1{``0},``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.float32_of_bits(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.float_of_bits(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.get_tbl``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.tbl`1{``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.is_noarg_instr(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILInstr)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_add">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_add_ovf">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_add_ovf_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_and">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_arglist">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_beq">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_bge">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_bge_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_bgt">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_bgt_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ble">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ble_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_blt">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_blt_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_bne_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_box">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_br">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_break">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_brfalse">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_brtrue">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_call">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_callconstrained">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_calli">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_callvirt">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_castclass">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ceq">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_cgt">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_cgt_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ckfinite">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_clt">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_clt_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_constrained">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_conv">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_conv_ovf">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_conv_ovf_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_conv_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_cpblk">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_cpobj">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_div">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_div_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_dup">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_endfilter">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_endfinally">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ilzero">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_initblk">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_initobj">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_isinst">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_jmp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldarg">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldarga">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldc">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldelem">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldelem_any">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldelema">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldfld">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldflda">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldftn">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldind">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldlen">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldlen_multi">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldloc">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldloca">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldnull">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldobj">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldsfld">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldsflda">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldstr">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldtoken">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldunit">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ldvirtftn">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_leave">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_localloc">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_mkrefany">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_mul">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_mul_ovf">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_mul_ovf_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_neg">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_newarr">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_newobj">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_nop">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_not">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_or">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_pop">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_readonly">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_refanytype">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_refanyval">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_rem">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_rem_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_ret">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_rethrow">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_shl">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_shr">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_shr_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_sizeof">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_starg">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_stelem">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_stelem_any">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_stfld">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_stind">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_stloc">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_stobj">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_stsfld">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_sub">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_sub_ovf">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_sub_ovf_un">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_switch">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_tail">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_throw">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_unaligned">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_unbox">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_unbox_any">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_volatile">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itag_xor">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.lookup_ccuref``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{``0},System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.lookup_nlpath``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{``0},System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.lookup_pubpath``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{``0},System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.lookup_simpletyp``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{``0},System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.lookup_string``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{``0},System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.lookup_uniq``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.itbl`1{``0},System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.new_itbl``1(System.String,``0[]`1)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.new_osgn_inmap``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.String,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.new_tbl``1(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.prim_u_int32(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.simple_instrs">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.tbl_size``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.tbl`1{``0})">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_Exprs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_FlatExprs">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_FlatList``1(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_FlatVals">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_Map``2(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_MemberFlags(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_TopArgInfo(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_TopTyparInfo(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_Val(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ValData(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ValTopReprInfo(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_Vals">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_access(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_alignment(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_arg(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_array``1(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_array_revi``1(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_array_shape">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_assref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_attrib(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_attrib_arg(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_attrib_expr(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_attribkind(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_attribs">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_basethis(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_basic_callconv(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_bind(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_binds">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_bool(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_byte(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_bytes(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_callconv(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_callsig">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ccuref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_char(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_const(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_constraint(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_constraints">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_cpath(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_double(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_dtree(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_dtree_case(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_dtree_discrim(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_dummy_range(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_encoded_ccuref">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_encoded_nlpath">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_encoded_pubpath">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_encoded_simpletyp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_encoded_string">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_entity_spec_data(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_exnc_repr(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_exnc_spec(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_exnc_spec_data(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_expr(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_hasthis(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_hole``1">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ident(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ieee64(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ilfref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ilinstr(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ilmref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_iltref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_iltspec(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_iltyp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_iltyps">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_immutable_ref``1(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_int(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_int16(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_int32(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_int64(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_int8(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_intf(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_intfs(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ints">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_istype(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_kind(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_lazy``1(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ldc_info(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ldtoken_info(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_list``1(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_list_revi``1(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_local_item_ref``2(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.osgn_inmap`2{``0,``1},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_lval_op_kind(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_measure_expr(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_member_info(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_member_kind(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_method(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_methods(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_modref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_modul_typ(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_mustinline(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_namemap``1(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_nlpath(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_nonlocal_item_ref(Microsoft.FSharp.Core.Unit,FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_op(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_option``1(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_osgn_decl``2(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.osgn_inmap`2{``0,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_osgn_ref``2(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.osgn_inmap`2{``0,``1},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_parentref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_pos(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_prim_string(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_pubkey(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_pubpath(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_range(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ranges">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_readonly(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_recdInfo(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_recdfield_spec(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_rfield_table(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_rfref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_scoref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_simpletyp(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_single(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_slotparam(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_slotsig(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_string(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_strings">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tailness(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_target(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_targets">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tcaug(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tcref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tpref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_trait(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_trait_sln(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tup2``2(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tup3``3(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tup4``4(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tup5``5(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tup6``6(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tycon_objmodel_data(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tycon_objmodel_kind(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tycon_repr(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_tycon_spec(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_typ">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_typar_constraint(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_typar_constraints">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_typar_spec(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_typar_spec_data(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_typar_specs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_typs">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_ucref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_uint16(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_uint32(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_uint64(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_uint8(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_unioncase_spec(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_unit(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_val_repr(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_varargs">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_version(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_void(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_volatility(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_vref(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_vrefFlags(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_vrefs">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_wrap``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.u_xmldoc(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ubasic_type(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ufailwith``1(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.uilfspec(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.uilmspec(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.unpickle_modul_spec(FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.unpickle_obj_with_dangling_ccus``1(System.String,FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},System.Byte[]`1)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.utup10``10(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``6},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``7},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``8},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``9},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.utup11``11(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``6},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``7},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``8},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``9},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``10},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.utup12``12(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``6},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``7},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``8},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``9},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``10},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``11},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.utup13``13(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``6},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``7},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``8},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``9},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``10},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``11},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``12},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.utup14``14(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``6},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``7},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``8},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``9},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``10},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``11},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``12},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``13},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.utup15``15(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``6},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``7},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``8},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``9},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``10},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``11},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``12},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``13},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``14},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.utup7``7(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``6},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.utup8``8(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``6},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``7},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.utup9``9(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``0},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``1},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``2},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``3},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``4},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``5},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``6},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``7},Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState,``8},FSharp.PowerPack.Metadata.Reader.Internal.Pickle.ReaderState)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Pickle.verbose">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Pickle">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ExprData">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.FlatList`1">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.FreeVarsCache">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.LazyWithContext`2.NotLazy``1(``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.LazyWithContext`2.Force``1(``2)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.LazyWithContext`2.Create``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.LazyWithContext`2">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.MemberFlags">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.MemberKind">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap`1">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMultiMap`1">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SequencePointInfoForBinding">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SequencePointInfoForFinally">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SequencePointInfoForForLoop">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SequencePointInfoForSeq">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SequencePointInfoForTarget">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SequencePointInfoForTry">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SequencePointInfoForWhileLoop">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SequencePointInfoForWith">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SkipFreeVarsCache">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SynTypar">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.TyparStaticReq">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.XmlDoc">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.cache`1">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident.idText">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident.idRange">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident..ctor(System.String,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.nonnull_slot`1">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.pos">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Error``1(System.String,``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.InternalError``1(System.String,``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.MergeXmlDoc(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.XmlDoc,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.XmlDoc)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NoSequencePointAtFinally">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NoSequencePointAtForLoop">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NoSequencePointAtStickyBinding">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NoSequencePointAtTry">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NoSequencePointAtWhileLoop">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NoSequencePointAtWith">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SuppressSequencePointAtTarget">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SuppressSequencePointOnExprOfSequential">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.UnresolvedPathReferenceNoRange(System.String,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.UnresolvedReferenceNoRange(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.cacheOptRef``2(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``1})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.cached``2(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``1})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.dprintf``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.emptyXmlDoc">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.error``1(System.Exception)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.errorR``1(System.Exception)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.isSome``1(Microsoft.FSharp.Core.Option`1{``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.mk_pos(System.Int32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.mk_range(System.String,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.pos,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.pos)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.mksyn_id(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.new_cache``1">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.notlazy``1(``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.nullable_slot_empty``1">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.nullable_slot_full``1(``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.op_EqualsEqualsEquals``1(``0,``0)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range0">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.text_of_path(System.Collections.Generic.IEnumerable`1{System.String})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.t">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.clone_and_seek(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.t,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.of_bytes(System.Byte[]`1,System.Int32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.position(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.t)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.read_byte(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.t)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.read_bytes(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.t,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.read_utf8_bytes_as_string(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.t,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.skip(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream.t,System.Int32)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes.Bytestream">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.Bytes">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.List.frontAndBack``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.List.mapSquared``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Collections.FSharpList`1{``0}})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.List">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap.add``1(System.String,``0,Microsoft.FSharp.Collections.Map`2{System.String,``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap.empty``2">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap.find``1(System.String,Microsoft.FSharp.Collections.Map`2{System.String,``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap.foldRange``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.Map`2{System.String,``0},``1)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap.mem``1(System.String,Microsoft.FSharp.Collections.Map`2{System.String,``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap.of_keyed_list``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap.range``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap.tryfind``1(System.String,Microsoft.FSharp.Collections.Map`2{System.String,``0})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMap">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMultiMap.add``1(System.String,``0,Microsoft.FSharp.Collections.Map`2{System.String,Microsoft.FSharp.Collections.FSharpList`1{``0}})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMultiMap.empty``1">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMultiMap.find``1(System.String,Microsoft.FSharp.Collections.Map`2{System.String,Microsoft.FSharp.Collections.FSharpList`1{``0}})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMultiMap.range``1(Microsoft.FSharp.Collections.Map`2{System.String,Microsoft.FSharp.Collections.FSharpList`1{``0}})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.NameMultiMap">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.String.dropSuffix(System.String,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.String.hasSuffix(System.String,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.String.tryDropSuffix(System.String,System.String)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude.String">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Prelude">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.NameArityPair">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.ChopPropertyName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.ChopUnshowableInFsiGenerationPath(Microsoft.FSharp.Collections.FSharpList`1{System.String})">
<summary>
 Used when generating the secret paths used by FSI file generation
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.CompileOpName">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.CompilerGeneratedName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.CompilerGeneratedNameSuffix(System.String,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.DecodeGenericTypeName(System.String)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.DecompileOpName">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.DemangleExceptionName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.DemangleGenericTypeName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.DemangleOperatorName(System.String)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.FSharpModuleSuffix">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.GetBasicNameOfPossibleCompilerGeneratedName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.IsCompilerGeneratedName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.IsIdentifierPartCharacter(System.Char)">
<summary>
 The characters that are allowed to be in an identifier.
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.IsLongIdentifierPartCharacter(System.Char)">
<summary>
 Is this character a part of a long identifier 
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.IsMangledGenericName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.IsMangledOpName(System.String)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.IsOpName">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.IsPrefixOperator(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.JoinNamesForFsiGenerationPath(Microsoft.FSharp.Collections.FSharpList`1{System.String})">
<summary>
 Used when generating the secret paths used by FSI file generation
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.SplitNamesForFsiGenerationPath(System.String)">
<summary>
 Used when generating the secret paths used by FSI file generation
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.TryChopPropertyName(System.String)">
<summary>
 Try to chop "get_" or "set_" from a string
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.chopStringTo(System.String,System.Char)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.compilerGeneratedMarker">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.lparen_get">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.lparen_set">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.mangle_exception_name(System.String)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.mangledGenericTypeNameSym">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.opCharTranslateTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.opNameTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.opname_Cons">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.opname_Equals">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.opname_Nil">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.qmark">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.qmark_set">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.|Control|Equality|Relational|Indexer|FixedTypes|Other|(System.String)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ActivePatternElemRef.IsTotalActivePattern">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ActivePatternElemRef.CaseIndex">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ActivePatternElemRef.ActivePatternVal">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ActivePatternElemRef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ActivePatternInfo">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Attrib">
<summary>
 Attrib(kind,unnamedArgs,propVals)
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.AttribExpr">
<summary>
 We keep both source expression and evaluated expression around to help intellisense and signature printing
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.AttribKind">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.AttribNamedArg">
<summary>
 AttribNamedArg(name,type,isField,value)
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Attribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Binding.Var">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Binding.SequencePointInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Binding.Expr">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Binding">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Bindings">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuData">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuReference">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuResolutionResult">
<summary>
 The result of attempting to resolve an assembly name to a full ccu.
 UnresolvedCcu will contain the name of the assembly that could not be resolved.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.UsesQuotations(System.Boolean)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.UsesQuotations">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.TypeForwarders">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.TopTypeAndExceptionDefinitions">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.TopModulesAndNamespaces">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.Stamp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.SourceCodeDirectory">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.QualifiedName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.IsUnresolvedReference">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.IsFSharp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.ILScopeRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.FileName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.Deref">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.Contents">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.AssemblyName">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.TryForward(System.String[]`1,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.FixupOrphaned">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.Fixup(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.EnsureDerefable(System.String[]`1)">
<summary>
 Ensure the ccu is derefable in advance. Supply a path to attach to any resulting error message.
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.CreateDelayed(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk.Create(System.String,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuData)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk">
<summary>
 A relinkable handle to the contents of a compilation unit. Relinking is performed by mutation.
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuTypeForwarderTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath.ILScopeRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath.AccessPath">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath">
<summary>
 The information ILXGEN needs about the location of an item
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompiledTypeRepr">
<summary>
 Specifies the compiled representations of type and exception definitions.  
 Computed and cached by later phases (never computed type checking).  Cached at 
 type and exception definitions. Not pickled.
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Constant">
<summary>
 Constants in expressions
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.DecisionTree">
<summary>
 Decision trees. Pattern matching has been compiled down to
 a decision tree by this point.  The right-hand-sides (actions) of
 the decision tree are labelled by integers that are unique for that
 particular tree.
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.DecisionTreeCase">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.DecisionTreeDiscriminator">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.DecisionTreeTarget">
<summary>
 A target of a decision tree. Can be thought of as a little function, though is compiled as a local block. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.XmlDoc">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.UnionTypeInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.UnionInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.UnionCasesAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.UnionCasesArray">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.TypeReprInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.TypeReprAccessibility">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.TypeOrMeasureKind">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.TypeContents">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.TypeAbbrev">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.TyparsNoRange">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.TrueInstanceFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.TrueFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.Stamp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.PublicPath">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.ModuleOrNamespaceType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.MangledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsUnionTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsTypeAbbrev">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsStructTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsRecordTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsPrefixDisplay">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsNamespace">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsModuleOrNamespace">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsModule">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsMeasureableReprTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsLinked">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsILTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsILStructTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsHiddenReprTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsFSharpStructTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsFSharpObjectModelTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsFSharpInterfaceTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsFSharpEnumTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsFSharpDelegateTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsExceptionDecl">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.IsAsmReprTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.Id">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.ILTyconRawMetadata">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.ILTyconInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.FSharpObjectModelTypeInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.ExceptionInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.DisplayNameWithUnderscoreTypars">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.DisplayName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.DemangledExceptionName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.CompiledRepresentationForTyrepNamed">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.CompiledRepresentation">
<summary>
 From TAST TyconRef to IL ILTypeRef
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.CompiledReprCache">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.CompilationPathOpt">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.CompilationPath">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.Attribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.AllInstanceFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.AllFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.AllFieldsArray">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.AllFieldTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.Accessibility">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.Typars(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.NewUnlinked">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.New(System.String,FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityData)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.Link(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityData)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.GetUnionCaseByName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.GetFieldByName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity.GetFieldByIndex(System.Int32)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityData">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.XmlDoc">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.UnionTypeInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.UnionInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.UnionCasesAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.UnionCasesArray">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.TypeReprInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.TypeReprAccessibility">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.TypeOrMeasureKind">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.TypeContents">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.TypeAbbrev">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.TyparsNoRange">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.TryDeref">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.TrueInstanceFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.TrueFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.Stamp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.ResolvedTarget">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.PublicPath">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.PrivateTarget">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.ModuleOrNamespaceType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.MangledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsUnionTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsTypeAbbrev">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsStructTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsResolved">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsRecordTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsPrefixDisplay">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsNamespace">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsModuleOrNamespace">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsModule">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsMeasureableReprTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsLocalRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsILTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsILStructTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsHiddenReprTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsFSharpStructTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsFSharpObjectModelTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsFSharpInterfaceTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsFSharpEnumTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsFSharpDelegateTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsExceptionDecl">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.IsAsmReprTycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.Id">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.ILTyconRawMetadata">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.ILTyconInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.FSharpObjectModelTypeInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.ExceptionInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.DisplayNameWithUnderscoreTypars">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.DisplayName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.Deref">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.DemangledExceptionName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.CompiledRepresentationForTyrepNamed">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.CompiledRepresentation">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.CompiledReprCache">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.CompilationPathOpt">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.CompilationPath">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.Attribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.AllInstanceFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.AllFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.AllFieldsArray">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.AllFieldTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.Accessibility">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.Typars(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.Resolve">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.GetUnionCaseByName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.GetFieldByName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef.GetFieldByIndex(System.Int32)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ExceptionInfo">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ExprOpSpec">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Exprs">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.FlatExprs">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.FlatVals">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ForLoopStyle">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.LValueOperation">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespace">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceBinding">
<summary>
 A named module-or-namespace-fragment definition 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceExpr">
<summary>
 The module_typ is a binder. However it is not used in the ModuleOrNamespaceExpr: it is only referenced from the 'outside' 
 The contents of a module-or-namespace-fragment definition 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceExprWithSig">
<summary>
 A type for a module-or-namespace-fragment and the actual definition of the module-or-namespace-fragment
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceKind">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceRef">
<summary>
 note: ModuleOrNamespaceRef and TyconRef are type equivalent 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.TypesByMangledNameLookupTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.TypesByMangledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.TypesByDemangledNameAndArityLookupTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.TypesByAccessNamesLookupTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.TypesByAccessNames">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.TypeDefinitions">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.TypeAndExceptionDefinitions">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.ModulesAndNamespacesLookupTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.ModulesAndNamespacesByDemangledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.ModuleOrNamespaceKind">
<summary>
 Namespace or module-compiled-as-type? 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.ModuleAndNamespaceDefinitions">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.FSharpExceptionsLookupTable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.ExceptionDefinitionsByDemangledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.ExceptionDefinitions">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.AllValuesAndMembers">
<summary>
 Values, including members in F# types in this module-or-namespace-fragment. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.AllEntities">
<summary>
 Type, mapping mangled name to Tycon, e.g. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.ActivePatternsLookupTable">
<summary>
 Lookup tables keyed the way various clients expect them to be keyed.
 We attach them here so we don't need to store lookup tables via any other technique 
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.TypesByDemangledNameAndArity(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.AddVal(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.AddModuleOrNamespaceByMutation(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">
<summary>
 Mutation used during compilation of FSharp.Core.dll
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.AddEntity(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType..ctor(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceKind,Microsoft.FSharp.Collections.Map`2{System.String,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val},Microsoft.FSharp.Collections.Map`2{System.String,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity})">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef">
<summary>
 Non-local references indirect via a CCU
 The lookup into the CCU is a NonLocalPath, which is a series of strings
 We cache the result of dereferencing
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath.TryModuleOrNamespaceType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath.TryDeref">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath.ModuleOrNamespaceType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath.DisplayName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath.Deref">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath.AssemblyName">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath">
<summary>
 Index into the namespace/module structure of a particular CCU 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ObjExprMethod.Id">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ObjExprMethod">
<summary>
 A representation of a method in an object expression. 
 Note: Methods associated with types are represented as val declarations
 Note: We should probably use val_specs for object expressions, as then the treatment of members 
 in object expressions could be more unified with the treatment of members in types 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ParentRef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.PickledModuleInfo">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.PublicPath">
<summary>
 A public path records where a construct lives within the global namespace
 of a CCU.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.PropertyAttribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.LiteralValue">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.IsZeroInit">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.IsStatic">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.IsMutable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.IsCompilerGenerated">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.Id">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.FormalType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.FieldAttribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField.Accessibility">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdFieldRef.TyconRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdFieldRef.Tycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdFieldRef.RecdField">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdFieldRef.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdFieldRef.PropertyAttribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdFieldRef.FieldName">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdFieldRef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecordConstructionInfo">
<summary>
 This ModuleOrNamespace that represents the compilation of a module as a class. 
 The same set of tycons etc. are bound in the ModuleOrNamespace as in the ModuleOrNamespaceExpr
 This is the body of the module/namespace 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SequentialOpKind">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SlotParam.Type">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SlotParam">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SlotSig.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SlotSig.MethodTypars">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SlotSig.ImplementedType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SlotSig.FormalReturnType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SlotSig.FormalParams">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SlotSig.ClassTypars">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SlotSig">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.StaticOptimization">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TcGlobals">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopArgInfo">
<summary>
 The extra metadata stored about typars for top-level definitions. Any information here is propagated from signature through
 to the compiled code.
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopTyparInfo">
<summary>
 The extra metadata stored about typars for top-level definitions. Any information here is propagated from signature through
 to the compiled code.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TraitConstraintInfo.Solution(Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.TraitConstraintSln})">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TraitConstraintInfo.Solution">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TraitConstraintInfo.ReturnType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TraitConstraintInfo.MemberName">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TraitConstraintInfo">
<summary>
 The specification of a member constraint that must be solved 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TraitConstraintSln">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Tycon">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconAugmentation">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconObjModelData">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconObjModelKind">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconRecdFields.TrueInstanceFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconRecdFields.TrueFieldsAsList">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconRecdFields.AllFieldsAsList">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconRecdFields.FieldByName(System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconRecdFields.FieldByIndex(System.Int32)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconRecdFields">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconRef">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconRepresentation">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconUnionCases.UnionCasesAsList">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconUnionCases.GetUnionCaseByIndex(System.Int32)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconUnionCases">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconUnionData.UnionCasesAsList">
<summary>
 The ILX data structure representing the discriminated union. 
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconUnionData">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.StaticReq">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Stamp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Solution">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Rigidity">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Name">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Kind">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.IsLinked">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.IsFromError">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.IsErased">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.IsCompilerGenerated">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Id">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.DynamicReq">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.DisplayName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Constraints">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Attribs">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.NewUnlinked">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.New(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparData)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar.Link(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparData)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparConstraint">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparData">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparDynamicReq">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparKind.AttrName">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparKind.ToString">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparKind">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparRigidity">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase.RecdFieldsArray">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase.RecdFields">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase.IsNullary">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase.Id">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase.DisplayName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase.Attribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase.Accessibility">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase.GetFieldByName(System.String)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCaseRef.UnionCase">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCaseRef.TyconRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCaseRef.Tycon">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCaseRef.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCaseRef.CaseName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCaseRef.Attribs">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCaseRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.XmlDoc">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.UniqueCompiledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.TypeScheme">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.Type">
<summary>
 The type of the value. 
 May be a Type_forall for a generic value. 
 May be a type variable or type containing type variables during type inference. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.Typars">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.TopValInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.TauType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.Stamp">
<summary>
 A unique stamp within the context of this invocation of the compiler process 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.ReflectedDefinition">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.RecursiveValInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.Range">
<summary>
 The place where the value was defined. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.PublicPath">
<summary>
 What is the public path to the value, if any? Should be set if and only if
 IsMemberOrModuleBinding is set.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.MustInline">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.MemberInfo">
<summary>
 Is this a member, if so some more data about the member.

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body.
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.MemberApparentParent">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.MemberActualParent">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.MangledName">
<summary>
 The internal name the value. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.MakesNoCriticalTailcalls">
<summary>
 Was the value inferred to be a method or function that definitely makes no critical tailcalls?
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.LiteralValue">
<summary>
 The value of a value or member marked with [&lt;LiteralAttribute&gt;] 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsTypeFunction">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsOverride">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsNonExtensionMember">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsMutable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsModuleBinding">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsMemberOrModuleBinding">
<summary>
 Is this a member definition or module definition?
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsMember">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsLinked">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsInstanceMember">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsIncrClassGeneratedMember">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsIncrClassConstructor">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsExtensionMember">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsConstructor">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsCompilerGenerated">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsCompiledIntoModule">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.IsCompiledAsTopLevel">
<summary>
 Is this represented as a "top level" static binding (i.e. a static field, static member,
 instance member), rather than an "inner" binding that may result in a closure.

 This is implied by IsMemberOrModuleBinding, however not vice versa, for two reasons.
 Some optimizations mutate this value when they decide to change the representation of a 
 binding to be IsCompiledAsTopLevel. Second, even immediately after type checking we expect
 some non-module, non-member bindings to be marked IsCompiledAsTopLevel, e.g. 'y' in 
 'let x = let y = 1 in y + y' (NOTE: check this, don't take it as gospel)
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.InlineInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.Id">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.DisplayName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.DefinitionRange">
<summary>
 Range of the definition (implementation) of the value, used by Visual Studio 
 Updated by mutation when the implementation is matched against the signature. 
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.CoreDisplayName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.CompiledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.BaseOrThisInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.Attribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.ApparentParent">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.ActualParent">
<summary>
 The parent type or module, if any (None for expression bindings and parameters)
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.Accessibility">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.ToString">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.NewUnlinked">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.New(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValData)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val.Link(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValData)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValBaseOrThisInfo">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValData">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValInlineInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValMemberInfo.PropertyName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValMemberInfo.LogicalName">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValMemberInfo">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValMutability">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRecursiveScopeInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.XmlDoc">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.UniqueCompiledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.TypeScheme">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.Type">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.Typars">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.TryDeref">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.TopValInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.TauType">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.Stamp">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.ResolvedTarget">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.ReflectedDefinition">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.RecursiveValInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.Range">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.PublicPath">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.PrivateTarget">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.MustInline">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.MemberInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.MemberApparentParent">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.MemberActualParent">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.MangledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.MakesNoCriticalTailcalls">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.LiteralValue">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsTypeFunction">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsResolved">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsMutable">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsModuleBinding">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsMemberOrModuleBinding">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsMember">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsLocalRef">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsInstanceMember">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsIncrClassGeneratedMember">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsIncrClassConstructor">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsExtensionMember">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsConstructor">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsCompilerGenerated">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.IsCompiledAsTopLevel">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.InlineInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.Id">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.DisplayName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.Deref">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.DefinitionRange">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.CoreDisplayName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.CompiledName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.BaseOrThisInfo">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.Attribs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.ApparentParent">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.ActualParent">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.Accessibility">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef.ToString">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef">
<summary>
 References are either local or nonlocal
</summary>
</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValTopReprInfo.NumTypars">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValTopReprInfo.NumCurriedArgs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValTopReprInfo.KindsOfTypars">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValTopReprInfo.HasNoArgs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValTopReprInfo.AritiesOfArgs">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValTopReprInfo.ArgInfos">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValTopReprInfo">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValUseFlag">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.Vals">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ccu">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.expr">
<summary>
 The big type of expressions.  
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.measure">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.stamp">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.tinst">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.typ">
<summary>
 The algebra of types
</summary>
</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.typars">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.uniq">
<summary>
 Unique name generator for stamps attached to lambdas and object expressions
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.AddTyconsByAccessNames``1(System.String,``0,Microsoft.FSharp.Collections.Map`2{System.String,Microsoft.FSharp.Collections.FSharpList`1{``0}})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.AddTyconsByDemangledNameAndArity``1(System.String,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar},``0,Microsoft.FSharp.Collections.Map`2{FSharp.PowerPack.Metadata.Reader.Internal.PrettyNaming.NameArityPair,``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CopyTypar(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.CopyTypars(Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ERef_nonlocal(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ERef_nonlocal_preresolved(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity,FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ERef_private(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.FSharpOptimizationDataResourceName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.FSharpSignatureDataResourceName">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.IsLessAccessible(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.MakeRecdFieldsTable(Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.MakeUnionCases(Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.MakeUnionCasesTable(Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.MakeUnionRepr(Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewCcuContents(FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range,System.String,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewClonedModuleOrNamespace(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewClonedTycon(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewExn(Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ExceptionInfo,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Attrib},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.XmlDoc)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewFreeVarsCache``1">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewILTycon(Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath},System.String,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.LazyWithContext`2{Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range},FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef},FSharp.PowerPack.Metadata.Reader.Internal.AbstractIL.IL.ILTypeDef,Microsoft.FSharp.Control.Lazy`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewModifiedModuleOrNamespace(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType},FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">
<summary>
 Create a module Tycon based on an existing one using the function 'f'. 
 We require that we be given the parent for the new module. 
 We pass the new module to 'f' in case it needs to reparent the 
 contents of the module. 
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewModifiedTycon(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityData,FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityData},FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">
<summary>
 Create a tycon based on an existing one using the function 'f'. 
 We require that we be given the new parent for the new tycon. 
 We pass the new tycon to 'f' in case it needs to reparent the 
 contents of the tycon. 
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewModifiedVal(Microsoft.FSharp.Core.FastFunc`2{FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValData,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValData},FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">
<summary>
 Create a Val based on an existing one using the function 'f'. 
 We require that we be given the parent for the new Val. 
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewModuleOrNamespace(Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath},FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.XmlDoc,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Attrib},Microsoft.FSharp.Control.Lazy`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewModuleOrNamespaceType(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceKind,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity},Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewRecdField(System.Boolean,Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Constant},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident,FSharp.PowerPack.Metadata.Reader.Internal.Tast.typ,System.Boolean,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Attrib},Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Attrib},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.XmlDoc,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility,System.Boolean)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewTycon(Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath},System.String,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility,FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparKind,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.LazyWithContext`2{Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.XmlDoc,System.Boolean,Microsoft.FSharp.Control.Lazy`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewTypar(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparKind,FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparRigidity,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.SynTypar,System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparDynamicReq,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Attrib})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewUnionCase(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident,System.String,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField},FSharp.PowerPack.Metadata.Reader.Internal.Tast.typ,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Attrib},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.XmlDoc,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NewVal(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident,FSharp.PowerPack.Metadata.Reader.Internal.Tast.typ,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValMutability,System.Boolean,Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValTopReprInfo},Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath},FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRecursiveScopeInfo,Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValMemberInfo},FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValBaseOrThisInfo,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Attrib},FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValInlineInfo,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.XmlDoc,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Constant},FSharp.PowerPack.Metadata.Reader.Internal.Tast.ParentRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SkipCacheCompute``1(Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.SkipFreeVarsCache">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.VRef_nonlocal(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.VRef_nonlocal_preresolved(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val,FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.VRef_private(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.access_subst_paths(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility)">
<summary>
 Given (newPath,oldPath) replace oldPath by newPath in the TAccess.
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.arity_of_val(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.array_path_eq(System.String[]`1,System.String[]`1)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.attribs_of_tycon(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.can_access_cpath_from(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.can_access_cpath_from_one_of(Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath},FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.can_access_from(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.can_access_from_everywhere(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.can_access_from_somewhere(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ccu_eq(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk)">
<summary>
 Equality on CCUs, implemented as reference equality
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ccu_of_nlpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ccu_of_nlref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ccu_of_tcref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ccu_of_vref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.combineAccess(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Accessibility)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.combine_entites(Microsoft.FSharp.Collections.FSharpList`1{System.String},FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.combine_entitiesl(Microsoft.FSharp.Collections.FSharpList`1{System.String},Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.combine_maps``3(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Collections.FSharpList`1{``0},``1},Microsoft.FSharp.Collections.Map`2{``2,``0},Microsoft.FSharp.Collections.Map`2{``2,``0})">
<summary>
 Combine module types when multiple namespace fragments contribute to the
 same namespace, making new module specs as we go.
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.combine_msigtyps(Microsoft.FSharp.Collections.FSharpList`1{System.String},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.combine_mtyps(Microsoft.FSharp.Collections.FSharpList`1{System.String},FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.cpath_of_ccu(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.data_of_val(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.demangled_name_of_entity_name(System.String,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceKind)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.demangled_name_of_modref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.demangled_name_of_modul(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.demangled_path_of_cpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.deref_modul(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef)">
<summary>
 Identical to tcref.Deref and deref_tycon, just used to help distinguish what kind of entity we expect here
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.deref_tycon(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.deref_val(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.empty_mtype(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceKind)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.enclosing_nlpath_of_pubpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.PublicPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.fixup_typar_constraints(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar,Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparConstraint})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.fslib_nlpath_eq_pubpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.PublicPath)">
<summary>
 Compiler-internal references to items in fslib are generated as Ref_nonlocal even when compiling fslib 
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.fslib_refs_eq``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.PublicPath}},``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.Choice`2{``0,FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef}},FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,``2,``2)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.full_cpath_of_modul(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.id_of_tycon(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.id_of_val(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.item_of_nlref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.local_tcref_eq(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mangled_path_of_cpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_byref_typ(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TcGlobals,FSharp.PowerPack.Metadata.Reader.Internal.Tast.typ)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_cpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath,System.String,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ModuleOrNamespaceKind)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_exnconstr_namemap">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_local_tcref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_multi_dim_array_typ(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TcGlobals,System.Int32,FSharp.PowerPack.Metadata.Reader.Internal.Tast.typ)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_namemap``1(System.String,Microsoft.FSharp.Core.FastFunc`2{``0,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_nativeint_typ(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TcGlobals)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_nativeptr_typ(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TcGlobals,FSharp.PowerPack.Metadata.Reader.Internal.Tast.typ)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_nlpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_nlr(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_nonlocal_tcref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_nonlocal_tcref_preresolved(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity,FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_nonlocal_vref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_nonlocal_vref_preresolved(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val,FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_rfref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_rigid_typar(System.String,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.range)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_tycon_namemap">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_typar_ty(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_ucref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef,System.String)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_unit_typ(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TcGlobals)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mk_val_namemap">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.mustinline(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValInlineInfo)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.name_of_rfield(FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.name_of_val(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.new_ccu(System.String,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuData)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.new_stamp">
<summary>
 Unique name generator for stamps attached to to val_specs, tycon_specs etc.
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.new_tcaug">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.new_uniq">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.nlpath_definitely_not_eq(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath,FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath)">
<summary>
 This predicate tests if non-local resolution paths are definitely known to resolve
 to different entities. All references with different named paths always resolve to 
 different entities. Two references with the same named paths may resolve to the same 
 entities even if they reference through different CCUs, because one reference
 may be forwarded to another via a .NET TypeForwarder.
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.nlpath_eq(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath,FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.nlpath_of_ccu(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.nlpath_of_modul(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.nlpath_of_nlref(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.nlpath_of_pubpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.PublicPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.nlref_definitely_not_eq(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef)">
<summary>
 See nlpath_definitely_not_eq
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.nlref_eq(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalItemRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.nlref_of_pubpath``1(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.PublicPath,``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.parent_cpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.path_of_nlpath(FSharp.PowerPack.Metadata.Reader.Internal.Tast.NonLocalPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.prim_tcref_eq(System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.prim_ucref_eq(System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCaseRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCaseRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.prim_vref_eq(System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.pubpath_of_cpath(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.ident,FSharp.PowerPack.Metadata.Reader.Internal.Tast.CompilationPath)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.pubpath_of_tycon(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.pubpath_of_val(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.rescope_tycon_pubpath``1(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.PublicPath,``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.rescope_val_pubpath``1(FSharp.PowerPack.Metadata.Reader.Internal.Tast.CcuThunk,FSharp.PowerPack.Metadata.Reader.Internal.Tast.PublicPath,``0)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.rfref_of_rfield(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.RecdField)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_compgen_of_tpdata(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparData,System.Boolean)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_dynamic_req_of_tpdata(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparData,FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparDynamicReq)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_from_error_of_tpdata(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparData,System.Boolean)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_is_topbind_of_vflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValData,System.Boolean)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_kind_of_tpdata(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparData,FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparKind)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_notailcall_hint_of_vflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValData,System.Boolean)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_rigid_of_tpdata(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparData,FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparRigidity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_static_req_of_tpdata(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparData,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.TyparStaticReq)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_tcaug_compare(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconAugmentation,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_tcaug_compare_withc(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconAugmentation,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_tcaug_equals(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconAugmentation,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_tcaug_hasObjectGetHashCode(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconAugmentation,System.Boolean)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_tcaug_hash_and_equals_withc(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyconAugmentation,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.set_vrec_of_vflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValData,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRecursiveScopeInfo)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.stamp_of_tycon(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Entity)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.strip_tpeqns(FSharp.PowerPack.Metadata.Reader.Internal.Tast.typ)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.strip_tpeqnsA(System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.typ)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.strip_upeqns(FSharp.PowerPack.Metadata.Reader.Internal.Tast.measure)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.strip_upeqnsA(System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.measure)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.taccessPublic">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.tcref_in_this_assembly(System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.tpref_is_solved(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.tpspec_eq(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar)">
<summary>
 Equality on type varialbes, implemented as reference equality
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.try_deref_val(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.try_shortcut_solved_upref(System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.typar_ref_eq(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.type_of_val(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.types_of_vals(Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ucref_of_ucase(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef,FSharp.PowerPack.Metadata.Reader.Internal.Tast.UnionCase)">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.unassignedTyparName">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.verboseStamps">
<summary>
verboseStamps: print #stamp on each id -- very verbose - but sometimes useful. Turn on using '--stamps'
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.vref_in_this_assembly(System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.vspec_eq(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val,FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">
<summary>
 Equality on value specs, implemented as reference equality
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.|ERef_private|ERef_nonlocal|(FSharp.PowerPack.Metadata.Reader.Internal.Tast.EntityRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.|VRef_private|VRef_nonlocal|(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.|ValDeref|(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRef)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.DuplicateException">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.FullAbstractionException">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.InternalUndefinedItemRefException">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.InternalUndefinedTyconItemException">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.NameClashException">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.UndefinedNameException">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.HasNoArgs(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValTopReprInfo)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.InferTopArgInfo(FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.InferTopArgInfos(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Val}})">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.InferTyparInfo(Microsoft.FSharp.Collections.FSharpList`1{FSharp.PowerPack.Metadata.Reader.Internal.Tast.Typar})">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.emptyValData">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.selfMetadata">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.unitArgData``1">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.unnamedRetVal">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.unnamedTopArg">

</member>
<member name="P:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo.unnamedTopArg1">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TopValInfo">
<summary>
 Metadata on values (names of arguments etc. 
</summary>
</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.compgen_of_tpflags(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.dynamic_req_of_tpflags(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.encode(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparKind,FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparRigidity,System.Boolean,System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Prelude.TyparStaticReq,FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparDynamicReq)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.encode_compgen_of_tpflags(System.Boolean,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.encode_dynamic_req_of_tpflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparDynamicReq,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.encode_from_error_of_tpflags(System.Boolean,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.encode_kind_of_tpflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparKind,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.encode_rigid_of_tpflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparRigidity,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.encode_static_req_of_tpflags(FSharp.PowerPack.Metadata.Reader.Internal.Prelude.TyparStaticReq,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.from_error_of_tpflags(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.kind_of_tpflags(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.rigid_of_tpflags(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags.static_req_of_tpflags(System.Int32)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.TyparFlags">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.base_of_vflags(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRecursiveScopeInfo,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValBaseOrThisInfo,System.Boolean,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValInlineInfo,FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValMutability,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_base_of_vflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValBaseOrThisInfo,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_compgen_of_vflags(System.Boolean,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_is_incr_class_of_vflags(System.Boolean,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_is_topbind_of_vflags(System.Boolean,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_is_tyfunc_of_vflags(System.Boolean,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_isext_of_vflags(System.Boolean,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_mustinline_of_vflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValInlineInfo,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_mutability_of_vflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValMutability,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_notailcall_hint_of_vflags(System.Boolean,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.encode_vrec_of_vflags(FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValRecursiveScopeInfo,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.inline_info_of_vflags(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.is_compgen_of_vflags(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.is_extension_member_of_vflags(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.is_incr_class_of_vflags(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.is_notailcall_hint_of_vflags(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.is_topbind_of_vflags(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.is_tyfunc_of_vflags(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.mutability_of_vflags(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags.vrec_of_vflags(System.Int64)">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast.ValFlags">

</member>
<member name="T:FSharp.PowerPack.Metadata.Reader.Internal.Tast">

</member>
<member name="P:Internal.Utilities.FSharpEnvironment.FSharpRunningBinFolder">
<summary>
 The default location of FSharp.Core.dll and fsc.exe based on the version of fsc.exe that is running
</summary>
</member>
<member name="P:Internal.Utilities.FSharpEnvironment.FSharpRunningVersion">

</member>
<member name="P:Internal.Utilities.FSharpEnvironment.location">

</member>
<member name="T:Internal.Utilities.FSharpEnvironment">

</member>
</members>
</doc>
