<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Core</name></assembly>
<members>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Tail">
<summary>
 Gets the tail of the list, which is a list containing all the elements of the list, excluding the first element 
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Length">
<summary>
 Gets the number of items contained in the list
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Item(System.Int32)">
<summary>
 Get the element of the list at the given position. Note lists are represented
 as linked lists so this is an O(n) operation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.IsEmpty">
<summary>
 Gets a value indicating if the list contains no entries
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Head">
<summary>
 Gets the first element of the list
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Empty">
<summary>
 Returns an empty list of a particular type
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpList`1.Cons(``0,Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Returns a list with <c>head</c> as its first element and <c>tail</c> as its subsequent elements
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpList`1">
<summary>
 The type of immutable singly-linked lists.  

 Use the constructors <c>[]</c> and <c>::</c> (infix) to create values of this type, or
 the notation <c>[1;2;3]</c>.   Use the values in the <c>List</c> module to manipulate 
 values of this type, or pattern match against the values directly.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.List`1">
<summary>
 An abbreviation for the type of immutable singly-linked lists.  
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.Item(``0)">
<summary>
 Lookup an element in the map. Raise <c>KeyNotFoundException</c> if no binding
 exists in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.IsEmpty">
<summary>
 Return true if there are no bindings in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.Empty">
<summary>
 The empty map
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.Count">
<summary>
 The number of bindings in the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.TryFind(``0)">
<summary>
 Lookup an element in the map, returning a <c>Some</c> value if the element is in the domain 
 of the map and <c>None</c> if not.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Remove(``0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.ContainsKey(``0)">
<summary>
 Test if an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Add(``0,``1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2..ctor(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Map`2">
<summary>
 Immutable maps.  Keys are ordered by F# generic comparison.

 <performance> 
   Maps based on generic comparison are efficient for small keys. They are not a suitable choice if keys are recursive data structures 
   or if keys require bespoke comparison semantics.
 </performance>
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray`1">
<summary>
 An abbreviation for the .NET type <c>System.Collections.Generic.List&lt;_&gt;</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.op_Subtraction(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.op_Addition(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.MinimumElement">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.MaximumElement">
<summary>
 Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.IsEmpty">
<summary>
 A useful shortcut for Set.isEmpty.  See the Set module for further operations on sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.Empty">
<summary>
 The empty set for the type 'T.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.Count">
<summary>
 The number of elements in the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Subtract(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Remove(``0)">
<summary>
 A useful shortcut for Set.remove.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.IsSupersetOf(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Evaluates to "true" if all elements of the first set are in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.IsSubsetOf(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Evaluates to "true" if all elements of the second set are in the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.GetPreviousElement(``0)">
<summary>
 Returns the greatest element in the set that is less than the given key 
 according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.GetNextElement(``0)">
<summary>
 Returns the least element in the set that is greater than the given key 
 according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Contains(``0)">
<summary>
 A useful shortcut for Set.contains.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Add(``0)">
<summary>
 A useful shortcut for Set.add.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1..ctor(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Create a set containing elements drawn from the given sequence.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Set`1">
<summary>
 Immutable sets based on binary trees, where comparison is the
 F# structural comparison function, potentially using implementations
 of the IComparable interface on key values.

 See the Set module for further operations on sets.

 These sets can be used with elements of any type, but you should check that
 structural hashing and equality on the element type are correct for your type.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.list`1">
<summary>
 An abbreviation for the type of immutable singly-linked lists.  

 Use the constructors <c>[]</c> and <c>::</c> (infix) to create values of this type, or
 the notation <c>[1;2;3]</c>.   Use the values in the <c>List</c> module to manipulate 
 values of this type, or pattern match against the values directly.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.seq`1">
<summary>
 An abbreviation for the .NET type <c>System.Collections.Generic.IEnumerable&lt;_&gt;</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.base1``1(``0[,]`1)">
<summary>
 Fetch the base-index for the first dimension of the array.

 See notes on the Array2D module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.base2``1(``0[,]`1)">
<summary>
 Fetch the base-index for the second dimension of the array.

 See notes on the Array2D module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.blit``1(``0[,]`1,System.Int32,System.Int32,``0[,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.copy``1(``0[,]`1)">
<summary>
 Build a new array whose elements are the same as the input array.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.create``1(System.Int32,System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.createBased``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Create a based array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.create_based``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.get``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 Fetch an element from a 2D array. You can also use the syntax 'array.[index1,index2]' 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.init``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">
<summary>
 Create an array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.initBased``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">
<summary>
 Create a based array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.init_based``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[,]`1)">
<summary>
 Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}}},``0[,]`1)">
<summary>
 Apply the given function to each element of the array.  The integer indicies passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.length1``1(``0[,]`1)">
<summary>
 Return the length of an array in the first dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.length2``1(``0[,]`1)">
<summary>
 Return the length of an array in the second dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}}},``0[,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.rebase``1(``0[,]`1)">
<summary>
 Build a new array whose elements are the same as the input array but
 where a non-zero-based input array generates a corresponding zero-based 
 output array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.set``1(``0[,]`1,System.Int32,System.Int32,``0)">
<summary>
 Set the value of an element in an array. You can also use the syntax 'array.[index1,index2] &lt;- value' 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.sub``1(``0[,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.zeroCreate``1(System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially Unchecked.defaultof&lt;'T&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.zeroCreateBased``1(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Create a based array where the entries are initially Unchecked.defaultof&lt;'T&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.zero_create``1(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2D.zero_create_based``1(System.Int32,System.Int32,System.Int32,System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Collections.Array2D">
<summary>
 Basic operations on 2-dimensional arrays. 

 F# and .NET multi-dimensional arrays are typically zero-based. 
 However, .NET multi-dimensional arrays used in conjunction with external
 libraries (e.g. libraries associated with Visual Basic) be 
 non-zero based, using a potentially different base for each dimension.
 The operations in this module will accept such arrays, and
 the basing on an input array will be propogated to a matching output
 array on the <c>Array2D.map</c> and <c>Array2D.mapi</c> operations.
 Non-zero-based arrays can also be created using <c>Array2D.zero_create_based</c>, 
 <c>Array2D.create_based</c> and <c>Array2D.init_based</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.create``1(System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.get``1(``0[,,]`1,System.Int32,System.Int32,System.Int32)">
<summary>
 Fetch an element from a 3D array.  You can also use the syntax 'array.[index1,index2,index3]'
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.init``1(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}}})">
<summary>
 Create an array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[,,]`1)">
<summary>
 Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}}}},``0[,,]`1)">
<summary>
 Apply the given function to each element of the array.  The integer indicies passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.length1``1(``0[,,]`1)">
<summary>
 Return the length of an array in the first dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.length2``1(``0[,,]`1)">
<summary>
 Return the length of an array in the second dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.length3``1(``0[,,]`1)">
<summary>
 Return the length of an array in the third dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[,,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}}}},``0[,,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.set``1(``0[,,]`1,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Set the value of an element in an array.  You can also 
 use the syntax 'array.[index1,index2,index3] &lt;- value'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.zeroCreate``1(System.Int32,System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially the "default" value. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3D.zero_create``1(System.Int32,System.Int32,System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Collections.Array3D">
<summary>
 Basic operations on rank 3 arrays.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4D.create``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4D.get``1(``0[,,,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Fetch an element from a 4D array.  You can also use the syntax 'array.[index1,index2,index3,index4]'
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4D.init``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}}}})">
<summary>
 Create an array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4D.length1``1(``0[,,,]`1)">
<summary>
 Return the length of an array in the first dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4D.length2``1(``0[,,,]`1)">
<summary>
 Return the length of an array in the second dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4D.length3``1(``0[,,,]`1)">
<summary>
 Return the length of an array in the third dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4D.length4``1(``0[,,,]`1)">
<summary>
 Return the length of an array in the fourth dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4D.set``1(``0[,,,]`1,System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Set the value of an element in an array.  You can also 
 use the syntax 'array.[index1,index2,index3,index4] &lt;- value'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4D.zeroCreate``1(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially the "default" value. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array4D">
<summary>
 Basic operations on rank 4 arrays.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.append``1(``0[]`1,``0[]`1)">
<summary>
 Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.average``1(``0[]`1)">
<summary>
 Return the average of the elements in the array. If the array is empty an ArgumentException is thrown.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.averageBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the average of the elements generated by applying the function to each element of the array.
 If the array is empty an ArgumentException is thrown.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.average_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.blit``1(``0[]`1,System.Int32,``0[]`1,System.Int32,System.Int32)">
<summary>
 Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``0[]`1)">
<summary>
 Apply the given function to each element of the array. Return
 the array comprised of the results "x" for each element where
 the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.collect``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1[]`1},``0[]`1)">
<summary>
 For each element of the array, apply the given function. Concatenate all the results and return the combined array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.combine``2(``0[]`1,``1[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.concat``1(System.Collections.Generic.IEnumerable`1{``0[]`1})">
<summary>
 Build a new array that contains the elements of each of the given sequence of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.copy``1(``0[]`1)">
<summary>
 Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.empty``1">
<summary>
 Return an empty array of the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Test if any element of the array satisfies the given predicate.

 The predicate is applied to the elements of the input array. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.exists2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},``0[]`1,``1[]`1)">
<summary>
 Test if any pair of corresponding elements of the arrays satisfies the given predicate.

 The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fill``1(``0[]`1,System.Int32,System.Int32,``0)">
<summary>
 Fill a range of elements of the array with the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the first element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.findIndex``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.find_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.find_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f s i0)...) iN</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,``1[]`1,``2[]`1)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.foldBack``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN s))</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.foldBack2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},``0[]`1,``1[]`1,``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_left2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,``1[]`1,``2[]`1)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN s))</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_right2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},``0[]`1,``1[]`1,``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.for_all2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},``0[]`1,``1[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.forall``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Test if all elements of the array satisfy the given predicate.

 The predicate is applied to the elements of the input collection. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.forall2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},``0[]`1,``1[]`1)">
<summary>
 Test if all corresponding elements of the array satisfy the given predicate pairwise.

 The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.get``1(``0[]`1,System.Int32)">
<summary>
 Get an element from an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create an array given the dimension and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.isEmpty``1(``0[]`1)">
<summary>
 Return true if the given array is empty, otherwise false
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.is_empty``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[]`1)">
<summary>
 Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},``0[]`1,``1[]`1)">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays. The
 two arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},``0[]`1)">
<summary>
 Apply the given function to each element of the array.  The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iteri2``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}}},``0[]`1,``1[]`1)">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an <c>ArgumentException</c> is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.length``1(``0[]`1)">
<summary>
 Return the length of an array.  You can also use property arr.Length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.make``1(System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},``0[]`1,``1[]`1)">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},``0[]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.mapi2``3(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}}},``0[]`1,``1[]`1)">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise, also passing the index of 
 the elements.  The two input arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.max``1(``0[]`1)">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.maxBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.max_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.min``1(``0[]`1)">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.minBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.min_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_list``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Build an array from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_seq``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new array from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Split the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.permute``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Int32},``0[]`1)">
<summary>
 Returns an array with all elements permuted according to the
 specified permutation
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.pick``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``0[]`1)">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>KeyNotFoundException</c> is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.reduce``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.reduceBack``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.
 Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.reduce_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.reduce_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.rev``1(``0[]`1)">
<summary>
 Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.scan``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">
<summary>
 Like <c>fold_left</c>, but return the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.scanBack``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">
<summary>
 Like <c>fold_right</c>, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.scan_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.scan_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.set``1(``0[]`1,System.Int32,``0)">
<summary>
 Set an element of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sort``1(``0[]`1)">
<summary>
 Sort the elements of an array, returning a new array. Elements are compared using Operators.compare. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sortBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Sort the elements of an array, using the given projection for the keys and returning a new array. Elements are compared using Operators.compare. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sortInPlace``1(``0[]`1)">
<summary>
 Sort the elements of an array by mutating the array in-place, using the given comparison function. Elements are compared using Operators.compare.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sortInPlaceBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Sort the elements of an array by mutating the array in-place, using the given projection for the keys. Elements are compared using Operators.compare.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sortInPlaceWith``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},``0[]`1)">
<summary>
 Sort the elements of an array by mutating the array in-place, using the given comparison function as the order 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sortWith``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},``0[]`1)">
<summary>
 Sort the elements of an array, using the given comparison function as the order, returning a new array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sort_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Sort the elements of an array, using the given projection for the keys. Elements are compared using Operators.compare.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.split``2(Microsoft.FSharp.Core.Tuple`2{``0,``1}[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.sub``1(``0[]`1,System.Int32,System.Int32)">
<summary>
 Build a new array that contains the given subrange specified by
 starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sum``1(``0[]`1)">
<summary>
 Return the sum of the elements in the array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sumBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the sum of the results generated by applying the function to each element of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sum_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_list``1(``0[]`1)">
<summary>
 Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_seq``1(``0[]`1)">
<summary>
 View the given array as a sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryFind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryFindIndex``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryPick``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``0[]`1)">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>None</c> is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryfind_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryfind_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.unzip``2(Microsoft.FSharp.Core.Tuple`2{``0,``1}[]`1)">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.unzip3``3(Microsoft.FSharp.Core.Tuple`3{``0,``1,``2}[]`1)">
<summary>
 Split an array of triples into three arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.zeroCreate``1(System.Int32)">
<summary>
 Create an array where the entries are initially the default value Unchecked.defaultof&lt;'T&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.zero_create``1(System.Int32)">
<summary>
 Create an array where the entries are initially the default value Unchecked.defaultof&lt;'T&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.zip``2(``0[]`1,``1[]`1)">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.zip3``3(``0[]`1,``1[]`1,``2[]`1)">
<summary>
 Combine three arrays into an array of pairs. The three arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array">
<summary>
 Basic operations on arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.FromFunction``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}})">
<summary>
 Compare using the given comparer function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.GetFastComparisonFunction``1(System.Collections.Generic.IComparer`1{``0})">
<summary>
 Convert an existing IComparer object into a comparison function with a fast entry point
 If comparer was originally built using ComparisonIdentity.FromFunction then the original function will be
 returned
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.GetFastStructuralComparisonFunction``1">
<summary>
 Convert an existing IComparer object into a comparison function with a fast entry point
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.Structural``1">
<summary>
 Structural comparison.  Compare using Operators.compare.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ComparisonIdentity">
<summary>
 Common notions of comparison identity used with sorted data structures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.FromFunctions``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}})">
<summary>
 Hash using the given hashing and equality functions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.LimitedStructural``1(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Reference``1">
<summary>
 Physical hashing (hash on reference identity of objects, and the contents of value types).  
 Hash using LanguagePrimitives.PhysicalEquality and LanguagePrimitives.PhysicalHash,
 That is, for value types use GetHashCode and Object.Equals (if no other optimization available),
 and for reference types use System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode and 
 reference equality. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Structural``1">
<summary>
 Structural hashing.  Hash using Operators.(=) and Operators.hash.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashIdentity">
<summary>
 Common notions of value identity used with hash tables.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.append``1(Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return a new list that contains the elements of the first list
 followed by elements of the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.average``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the average of the elements in the list.
 If the list is empty an ArgumentException is thrown.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.averageBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the average of the elements generated by applying the function to each element of the list.
 If the list is empty an ArgumentException is thrown.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.average_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Apply the given function to each element of the list. Return
 the list comprised of the results <c>x</c> for each element where
 the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.collect``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Collections.FSharpList`1{``1}},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 For each element of the list, apply the given function. Concatenate all the results and return the combined list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.combine``2(Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.concat``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.FSharpList`1{``0}})">
<summary>
 Return a new list that contains the elements of each the lists in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.empty``1">
<summary>
 Return an empty list of the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Test if any element of the list satisfies the given predicate.

 The predicate is applied to the elements of the input list. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.exists2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">
<summary>
 Test if any pair of corresponding elements of the lists satisfies the given predicate.

 The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.findIndex``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the index of the first element in the list
 that satisfies the given predicate.
 Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.find_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.flatten``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.FSharpList`1{``0}})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.fold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.FSharpList`1{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list.  Then feed this result into the function along
 with the second element and so on.  Return the final result.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f (... (f s i0) i1 ...) iN</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,Microsoft.FSharp.Collections.FSharpList`1{``1},Microsoft.FSharp.Collections.FSharpList`1{``2})">
<summary>
 Apply a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f (... (f s i0 j0)...) iN jN</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.foldBack``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpList`1{``0},``1)">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f i0 (...(f iN s))</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.foldBack2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1},``2)">
<summary>
 Apply a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f i0 j0 (...(f iN jN s))</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.FSharpList`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_left2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,Microsoft.FSharp.Collections.FSharpList`1{``1},Microsoft.FSharp.Collections.FSharpList`1{``2})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpList`1{``0},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_right2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.List.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.for_all2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.forall``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Test if all elements of the collection satisfy the given predicate.

 The predicate is applied to the elements of the input list. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.forall2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">
<summary>
 Test if all corresponding elements of the collection satisfy the given predicate pairwise.

 The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.hd``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the first element of the list.  Raise (Invalid_argument "hd") if undefined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create a list by calling the given generator on each index
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.isEmpty``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return true if the list contains no elements, false otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.is_empty``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">
<summary>
 Apply the given function to two collections simultaneously. The
 collections must have identical size.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Apply the given function to each element of the collection. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iteri2``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">
<summary>
 Apply the given function to two collections simultaneously. The
 collections must have identical size. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.length``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the length of the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map3``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1},Microsoft.FSharp.Collections.FSharpList`1{``2})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the three collections simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map_concat``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Collections.FSharpList`1{``1}},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.mapi2``3(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">
<summary>
 Like mapi, but mapping corresponding elements from two lists of equal length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.max``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the greatest of all elements of the list, compared via Operators.max
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.maxBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.max_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.min``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the lowest of all elements of the list, compared via Operators.min
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.minBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.min_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.nth``1(Microsoft.FSharp.Collections.FSharpList`1{``0},System.Int32)">
<summary>
 Index into the list.  The first element has index 0.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_array``1(``0[]`1)">
<summary>
 Build a collection from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_seq``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Split the collection into two collections, containing the 
 elements for which the given predicate returns <c>true</c> and <c>false</c>
 respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.permute``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Int32},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Returns a list with all elements permuted according to the
 specified permutation
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.pick``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some x. If no such
 element exists then raise <c>System.Collections.Generic.KeyNotFoundException</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.reduce``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Apply the function to the first two elements of the list.
 Then feed this result into the function along with the third element and so on.  
 Return the final result. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f i0 i1) i2 ...) iN</c>.
 Raises ArgumentException if the list has no elements.      
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.reduceBack``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN-1 iN))</c>.
 Raises ArgumentException if the list has no elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.reduce_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.reduce_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.replicate``1(System.Int32,``0)">
<summary>
 Create a list by calling the given generator on each index
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.rev``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return a new list with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.scan``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.FSharpList`1{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list.  Then feed this result into the function along
 with the second element and so on.  Return the list of intermediate results and the final result.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.scanBack``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpList`1{``0},``1)">
<summary>
 Like <c>foldBack</c>, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.scan_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.FSharpList`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.scan_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpList`1{``0},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sort``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Sort the given list using the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sortBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Sort the given list using keys given by the given projection. Keys are compared using Operators.compare. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sortWith``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Sort the given list using the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sort_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.split``2(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.stable_sort``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sum``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the sum of the elements in the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sumBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the sum of the results generated by applying the function to each element of the list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sum_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.tl``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the tail of the list.  Raise (Invalid_argument "tl") if undefined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_array``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Build an array from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_seq``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryFind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryFindIndex``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Return the index of the first element in the list
 that satisfies the given predicate.
 Return <c>None</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryPick``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Apply the given function to successive elements, returning <c>Some(x)</c> the first
 result where function returns <c>Some(x)</c> for some x. If no such element 
 exists then return <c>None</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.tryfind_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.unzip``2(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Split a list of pairs into two lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.unzip3``3(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Core.Tuple`3{``0,``1,``2}})">
<summary>
 Split a list of triples into three lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.zip``2(Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">
<summary>
 Combine the two lists into a list of pairs. The two lists must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.zip3``3(Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1},Microsoft.FSharp.Collections.FSharpList`1{``2})">
<summary>
 Combine the three lists into a list of triples. The lists must have equal lengths.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.List">
<summary>
 Basic operations on lists.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.add``2(``0,``1,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.contains``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Test is an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.empty``2">
<summary>
 The empty map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.exists``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Return true if the given predicate returns true for one of the
 bindings in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Build a new map containing only the bindings for which the given predicate returns 'true'
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.find``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Lookup an element in the map, raising <c>KeyNotFoundException</c> if no binding
 exists in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.findIndex``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Evaluates the function on each mapping in the collection. Returns the key for the first mapping
 where the function returns 'true'. Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.find_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.first``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{``2}}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Search the map looking for the first element where the given function returns a <c>Some</c> value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.fold``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,Microsoft.FSharp.Collections.Map`2{``1,``2})">
<summary>
 Fold over the bindings in the map 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.foldBack``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},Microsoft.FSharp.Collections.Map`2{``0,``1},``2)">
<summary>
 Fold over the bindings in the map 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.fold_left``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,Microsoft.FSharp.Collections.Map`2{``1,``2})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.fold_right``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},Microsoft.FSharp.Collections.Map`2{``0,``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.for_all``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.forall``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Return true if the given predicate returns true for all of the
 bindings in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.isEmpty``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.is_empty``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.iter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.map``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.mapi``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.mem``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_array``2(Microsoft.FSharp.Core.Tuple`2{``0,``1}[]`1)">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_list``2(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_seq``2(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.partition``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Build two new maps, one containing the bindings for which the given predicate returns 'true',
 and the other the remaining bindings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.pick``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{``2}}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Search the map looking for the first element where the given function returns a <c>Some</c> value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.remove``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.to_array``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Returns an array of all key-value pairs in the mappinng
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.to_list``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Returns a list of all key-value pairs in the mappinng
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.to_seq``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 View the collection as an enumerable sequence. This collection
 type is also directly compatible with 'seq&lt;KeyValuePair&lt;_,_&gt; &gt;'.

 Note this function returns a sequence of tuples, whereas the collection
 itself is compatible with the logically equivalent sequence of KeyValuePairs.
 Using sequences of tuples tends to be more convenient in F#, however the
 collection itself must enumerate KeyValuePairs to conform to the .NET
 design guidelines and the IDictionary interface.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.tryFind``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Lookup an element in the map, returning a <c>Some</c> value if the element is in the domain 
 of the map and <c>None</c> if not.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.tryFindIndex``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Return the key of the first mapping in the collection that satisfies the given predicate. 
 Return 'None' if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.tryPick``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{``2}}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Search the map looking for the first element where the given function returns a <c>Some</c> value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.tryfind``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.tryfind_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="T:Microsoft.FSharp.Collections.Map">
<summary>
 Functional programming operators related to the <c>Map&lt;_,_&gt;</c> type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.append``1(System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Wrap the two given enumeration-of-enumerations as a single concatenated
 enumeration.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.average``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the average of the elements in the sequence

 The elements are averaged using the '+' operator, 'DivideByInt' method and 'Zero' property 
 associated with the element type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.averageBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the average of the results generated by applying the function to each element of the sequence.

 The elements are averaged using the '+' operator, 'DivideByInt' method and 'Zero' property 
 associated with the generated type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.average_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.cache``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that corresponds to a cached version of the input sequence.
 This result sequence will have the same elements as the input sequence. The result 
 can be enumerated multiple times. The input sequence will be enumerated at most 
 once and only as far as is necessary.

 Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
 values may be used simultaneously from different threads (accesses to 
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not typically thread safe and should not be accessed concurrently.

 Note, once enumeration of the input sequence has started,
 it's enumerator will be kept live by this object until the enumeration has completed.
 At that point, the enumerator will be disposed. 

 The enumerator may be disposed and underlying cache storage released by 
 converting the returned sequence object to type IDisposable, and calling the Dispose method
 on this object. The sequence object may then be re-enumerated and a fresh enumerator will
 be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.cast``1(System.Collections.IEnumerable)">
<summary>
 Wrap a loosely-typed System.Collections sequence as a typed sequence.

 The use of this function usually requires a type annotation.
 An incorrect type annotation may result in runtime type
 errors.

 Individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply the given function to each element of the list. Return
 the list comprised of the results "x" for each element where
 the function returns Some(x)

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.collect``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 For each element of the enumeration apply the given function and concatenate all the results.

 Remember sequence is lazy, effects are delayed until it is enumerated.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.compare``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Compare two sequence's using generic comparison, element by element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.compareWith``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Compare two sequence's using the given comparison function, element by element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.concat``2(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Wrap the given enumeration-of-enumerations as a single concatenated
 enumeration.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.countBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply a key-generating function to each element of a sequence and return a sequence yielding unique
 keys and their number of occurences in the original sequence.  
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.count_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.delay``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable`1{``0}})">
<summary>
 Return a sequence that is built from the given delayed specification of an
 Seq. The input function is evaluated each time an IEnumerator for the sequence 
 is requested.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.distinct``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.distinctBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.distinct_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.empty``1">
<summary>
 Create an empty sequence 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Test if any element of the sequence satisfies the given predicate.

 The predicate is applied to the elements of the input sequence. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.exists2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Test if any pair of corresponding elements of the input sequences satisfies the given predicate.

 The predicate is applied to matching elements in the two sequences up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, false is returned. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns "true"

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.      
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.findIndex``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the index of the first element in the sequence of pairs
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.find_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``1,``0}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.find_indexi``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.fold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f s i0)...) iN</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.for_all2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.forall``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Test if all elements of the sequence satisfy the given predicate.

 The predicate is applied to the elements of the input sequence. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.forall2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Test the all pairs of elements drawn from the two sequences satisfies the
 given predicate. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.groupBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply a key-generating function to each element of a sequence and yields a sequence of 
 unique keys. Each unique key has also contains a sequence of all elements that match 
 to this key. 
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.group_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.hd``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the first element of the sequence.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Generate a new sequence which, when iterated, will return successive
 elements by calling the given function, up to the given count.  The results of calling the function
 will not be saved, i.e. the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.initInfinite``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Generate a new sequence which, when iterated, will return successive
 elements by calling the given function.  The results of calling the function
 will not be saved, i.e. the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.init_finite``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.init_infinite``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.isEmpty``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return true if the sequence contains no elements, false otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.is_empty``1(System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Apply the given function to two collections simultaneously. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply the given function to each element of the collection. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.length``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the length of the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.  The given function will be applied
 as elements are demanded using the 'MoveNext' method on enumerators retrieved from the
 object.  

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map_concat``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.max``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the greatest of all elements of the sequence, compared via Operators.max
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.maxBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.max_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.min``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the lowest of all elements of the sequence, compared via Operators.min
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.minBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.min_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.nth``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Compute the nth element in the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.of_array``1(``0[]`1)">
<summary>
 Build a collection from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.of_list``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Build a collection from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.pairwise``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence of each element in the input sequence and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.pick``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 'x' where the function returns "Some(x)".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.readonly``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new sequence object that delegates to the given sequence object. This ensures 
 the original sequence can't be rediscovered and mutated by a type cast. For example, 
 if given an array the returned sequence will return the elements of the array, but
 you can't cast the returned sequence object to an array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.reduce``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply a function to each element of the sequence, threading an accumulator argument
 through the computation. Begin by applying the function to the first two elements.
 Then feed this result into the function along with the third element and so on.  
 Return the final result.
 Raises ArgumentException if the sequence has no elements.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.scan``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Like fold, but compute on-demand and return the sequence of intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.singleton``1(``0)">
<summary>
 Return a sequence that yields one item only.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.skip``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that skips N elements of the underlying sequence and then yields the
 remaining elements of the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.skipWhile``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that, when iterated, skips elements of the underlying sequence while the 
 given predicate returns 'true', and then yields the remaining elements of the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.skip_while``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sort``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Yield a sequence ordered by keys.  
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sortBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply a key-generating function to each element of a sequence and yield a sequence ordered
 by keys.  The keys are compared using generic comparison as implemented by <c>Operators.compare</c>. 
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sort_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sum``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the sum of the elements in the sequence.

 The elements are summed using the '+' operator and 'Zero' property associated with the generated type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sumBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the sum of the results generated by applying the function to each element of the sequence.
 The generated elements are summed using the '+' operator and 'Zero' property associated with the generated type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sum_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.take``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the first N elements of the sequence.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.takeWhile``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that, when iterated, yields elements of the underlying sequence while the 
 given predicate returns 'true', and returns no further elements 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.take_while``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.to_array``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build an array from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.to_list``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a list from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.truncate``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that when enumerated returns at most N elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryFind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryFindIndex``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the index of the first element in the sequence 
 that satisfies the given predicate. Return 'None' if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryPick``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 result where the function returns "Some(x)".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryfind_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``1,``0}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryfind_indexi``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.unfold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Core.Tuple`2{``1,``0}}},``0)">
<summary>
 Return a sequence that contains the elements generated by the given computation.
 The given initial 'state' argument is passed to the element generator.
 For each IEnumerator elements in the stream are generated on-demand by applying the element
 generator, until a None value is returned by the element generator. Each call to the element
 generator returns a new residual 'state'.

 Note the stream will be recomputed each time an IEnumerator is requested and iterated for the Seq.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.windowed``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that yields 'sliding windows' of containing elements drawn from the input
 sequence. Each window is returned as a fresh array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.zip``2(System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Combine the two sequences into a list of pairs. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.zip3``3(System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1},System.Collections.Generic.IEnumerable`1{``2})">
<summary>
 Combine the three sequences into a list of triples. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Seq">
<summary>
 Basic operations on IEnumerables.  
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.SequenceExpressionHelpers.GeneratedSequenceBase`1.LastGenerated">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.SequenceExpressionHelpers.GeneratedSequenceBase`1.CheckClose">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SequenceExpressionHelpers.GeneratedSequenceBase`1.GetFreshEnumerator">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SequenceExpressionHelpers.GeneratedSequenceBase`1.GenerateNext(Microsoft.FSharp.Core.byref`1{System.Collections.Generic.IEnumerable`1{``0}})">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SequenceExpressionHelpers.GeneratedSequenceBase`1.Close">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SequenceExpressionHelpers.GeneratedSequenceBase`1..ctor">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.SequenceExpressionHelpers.GeneratedSequenceBase`1">
<summary>
 The F# compiler emits implementations of this type for compiled sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SequenceExpressionHelpers.EnumerateFromFunctions``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 The F# compiler emits calls to this function to implement the compiler-intrinsic
 conversions from untyped System.Collections.IEnumerable sequences to typed sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SequenceExpressionHelpers.EnumerateThenFinally``1(System.Collections.Generic.IEnumerable`1{``0},Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 The F# compiler emits calls to this function to 
 implement the 'try/finally' operator for F# sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SequenceExpressionHelpers.EnumerateUsing``3(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 The F# compiler emits calls to this function to implement the 'use' operator for F# sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SequenceExpressionHelpers.EnumerateWhile``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 The F# compiler emits calls to this function to 
 implement the 'while' operator for F# sequence expressions
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.SequenceExpressionHelpers">
<summary>
 A group of functions used as part of the compiled representation of F# sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.add``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new set with an element added to the set.  No exception is raised if
 the set already contains the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.choose``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Returns the minimum element of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.compare``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.contains``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Evaluates to "true" if the given element is in the given set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.count``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return the number of elements in the set.  Same as <c>size</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.diff``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.empty``1">
<summary>
 The empty set for the type 'T .
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Test if any element of the collection satisfies the given predicate.
If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
then computes <c>p i0 or ... or p iN</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns <c>true</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.fold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.Set`1{``1})">
<summary>
 Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.foldBack``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.Set`1{``0},``1)">
<summary>
 Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.Set`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.Set`1{``0},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.forall``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and "j0...jN"
 then computes <c>p i0 &amp;&amp; ... &amp;&amp; p iN</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.intersect``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.intersectMany``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">
<summary>
Compute the intersection of a sequence of sets. The sequence must be non-empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.intersect_all``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.isEmpty``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return "true" if the set is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.is_empty``1(Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Apply the given function to each element of the set, in order according
to the comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new collection containing the results of applying the
 given function to each element of the input set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.max_elt``1(Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.mem``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Evaluates to "true" if the given element is in the given set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.min_elt``1(Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.next_elt``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_array``1(``0[]`1)">
<summary>
 Build a set that contains the same elements as the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_list``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Build a set that contains the same elements as the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_seq``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Split the set into two sets containing the elements for which the given predicate
returns true and false respectively
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.prev_elt``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.remove``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new set with the given element removed.  No exception is raised in 
the set doesn't contain the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.singleton``1(``0)">
<summary>
 The set containing the given one element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.size``1(Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set.subset``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Evaluates to "true" if all elements of the second set are in the first        
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_array``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Build an array that contains the elements of the set in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_list``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Build a list that contains the elements of the set in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_seq``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.union``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compute the union of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.unionMany``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">
<summary>
Compute the union of a sequence of sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.union_all``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">

</member>
<member name="T:Microsoft.FSharp.Collections.Set">
<summary>
 Functional programming operators related to the <c>Set&lt;_&gt;</c> type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Async.DefaultGroup">
<summary>
 Get the default group for executing asynchronous computations
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.TryCancelled``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})">
<summary>
 Specify an asynchronous computation that, when run, executes <c>computation</c>,
 If <c>p</c> is effectively cancelled before its termination then
 the process <c>f exn</c> is executed. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.SwitchToThreadPool">
<summary>
 Specify an asynchronous computation that, when run, queues a CPU-intensive work in the thread pool item that runs
 its continutation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.SwitchToNewThread">
<summary>
 Specify an asynchronous computation that, when run, creates a new thread and runs
 its continutation in that thread
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.SwitchToGuiThread(System.Threading.SynchronizationContext)">
<summary>
 Specify an asynchronous computation that, when run, runs
 its continuation using syncContext.Post. If syncContext is null 
 then the asynchronous computation is equivalent to SwitchToThreadPool().
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.StartChild``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Start a child computation within an asynchronous workflow. 
 This allows multiple asynchronous computations to be executed simultaneously.
 
 This method should normally be used as the immediate 
 right-hand-side of a 'let!' binding in an F# asynchronous workflow, i.e.,
 
        async { ...
                let! completor1 = childComputation1 |&gt; Async.StartChild  
                let! completor2 = childComputation2 |&gt; Async.StartChild  
                ... 
                let! result1 = completor1 
                let! result2 = completor2 
                ... }
 
 When used in this way, each use of <c>StartChild</c> starts an instance of <c>childComputation</c> 
 and returns a completor object representing a computation to wait for the completion of the operation.
 When executed, the completor awaits the completion of <c>childComputation</c>. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Start(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">
<summary>
 Start the asynchronous computation in the thread pool. Do not await its result.

 Run as part of the default AsyncGroup
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.SpawnThenPostBack``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.SpawnFuture``1(Microsoft.FSharp.Control.Async`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.SpawnChild(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.Spawn(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.RunWithContinuations``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Run an asynchronous computation, initially as a work item.

 Run as part of the default AsyncGroup
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.RunSynchronously``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Run the asynchronous computation and await its result.

 If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.

 Run as part of the default AsyncGroup
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Run``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.Option`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.Primitive``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.Primitive``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`3{Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">
<summary>
 Specify an asynchronous computation that, when run, executes the given callback. 
 The callback must eventually call either the continuation,
 the exception continuation or the cancel exception.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Parallel3``3(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Control.Async`1{``1},Microsoft.FSharp.Control.Async`1{``2})">
<summary>
 Specify an asynchronous computation that, when run, executese the three asynchronous computations, starting each in the thread pool.
 If any raise an exception then the overall computation will raise an exception, and attempt to cancel the others.
 All the sub-computations belong to an AsyncGroup that is a subsidiary of the AsyncGroup of the outer computations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Parallel2``2(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Control.Async`1{``1})">
<summary>
 Specify an asynchronous computation that, when run, executes the two asynchronous computations, starting each in the thread pool.
 If any raise an exception then the overall computation will raise an exception, and attempt to cancel the others.
 All the sub-computations belong to an AsyncGroup that is a subsidiary of the AsyncGroup of the outer computations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Parallel``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Control.Async`1{``0}})">
<summary>
 Specify an asynchronous computation that, when run, executes all the given asynchronous computations, initially
 queueing each as work items and using a fork/join pattern. If any raise an exception then the 
 overall computation will raise the first detected exception, and attempt to cancel the others.
 All the sub-computations belong to an AsyncGroup that is a subsidiary of the AsyncGroup of the outer computations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.OnCancel(Microsoft.FSharp.Core.FastFunc`2{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Generate a scoped, cooperative cancellation handler for use within an asynchronous workflow. 

 <c>async { use! holder = Async.OnCancel f ... }</c> generates an asynchronous computation where, 
 if a cancellation happens any time during the execution of the asynchronous computation in the scope of 'holder',
 then action 'f' is executed on the thread that is performing the cancellation. You can use
 this to arrange for your own computation to be asynchronously notified that a cancellation has occurred, e.g.
 by setting a flag, or deregistering a pending I/O action.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Ignore``1(Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p', ignoring the result and
 returning the result '()'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Generate``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Control.Async`1{``0}},Microsoft.FSharp.Core.Option`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.Catch``1(Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Get the default group for executing asynchronous computations
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.CancelDefaultGroup(Microsoft.FSharp.Core.Option`1{System.String})">
<summary>
 Raise the cancellation condition for the most recent set of Async computations started without any specific AsyncGroup.
 Replace the global group with a new global group for any asynchronous computations created after this point without 
 any specific AsyncGroup.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.CancelCheck">

</member>
<member name="M:Microsoft.FSharp.Control.Async.BuildPrimitive``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`2{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FastFunc`2{System.IAsyncResult,``0})">
<summary>
 Specify an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET APIs where the overall operation is not qualified by any arguments. For example, 
     <c>Async.BuildPrimitive(ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, the 'Begin' half of the operation is executed, and
 an asynchronous computation is returned that, when run, awaits the completion 
 of the computation and fetches its overall result using the 'End' operation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.BuildPrimitive``2(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`3{``0,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FastFunc`2{System.IAsyncResult,``1})">
<summary>
 Specify an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET APIs where the
 overall operation is qualified by one argument. For example, 
     <c>Async.BuildPrimitive(place,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, the 'Begin' half of the operation is executed, and
 an asynchronous computation is returned that, when run, awaits the completion 
 of the computation and fetches its overall result using the 'End' operation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.BuildPrimitive``3(``0,``1,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`4{``0,``1,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FastFunc`2{System.IAsyncResult,``2})">
<summary>
 Specify an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET APIs where the
 overall operation is qualified by two arguments. For example, 
     <c>Async.BuildPrimitive(arg1,arg2,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, the 'Begin' half of the operation is executed, and
 an asynchronous computation is returned that, when run, awaits the completion 
 of the computation and fetches its overall result using the 'End' operation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.BuildPrimitive``4(``0,``1,``2,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FastFunc`2{System.IAsyncResult,``3})">
<summary>
 Specify an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET APIs where the overall operation is qualified by three arguments. For example, 
     <c>Async.BuildPrimitive(arg1,arg2,arg3,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, the 'Begin' half of the operation is executed, and
 an asynchronous computation is returned that, when run, awaits the completion 
 of the computation and fetches its overall result using the 'End' operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Async">
<summary>
 This static class holds members for creating and manipulating asynchronous computations
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Zero">
<summary>
 Specify an asynchronous computation that, when run, just returns '()'
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.While(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p' repeatedly 
 until 'gd()' becomes false.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Using``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">
<summary>
 Specify an asynchronous computation that, when run, runs 'f(resource)'. 
 The action 'resource.Dispose()' is executed as this computation yields its result
 or if the asynchronous computation exits by an exception or by cancellation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.TryWith``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Control.Async`1{``0}})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p' and returns its result.
 If an exception happens then 'f(exn)' is called and the resulting computation executed instead.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.TryFinally``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p'. The action 'f' is executed 
 after 'p' completes, whether 'p' exits normally or by an exception. If 'f' raises an exception itself
 the original exception is discarded and the new exception becomes the overall result of the computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Return``1(``0)">
<summary>
 Specify an asynchronous computation that, when run, returns the result 'v'
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.For``1(System.Collections.Generic.IEnumerable`1{``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit}})">
<summary>
 Specify an asynchronous computation that, when run, enumerates the sequence 'seq'
 on demand and runs 'f' for each element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Delay``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.Async`1{``0}})">
<summary>
 Specify an asynchronous computation that, when run, runs 'f()'
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Combine``1(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Specify an asynchronous computation that, when run, first runs 'p1' and then runs 'p2', returning the result of 'p2'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Bind``2(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p', and when 
 'p' generates a result 'T', runs 'f res'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder..ctor">
<summary>
 Generate an object used to build asynchronous computations using F# computation expressions. The value
 'async' is a pre-defined instance of this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncBuilder">
<summary>
 The type of the 'async' operator, used to build workflows for asynchronous computations.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.AsyncFuture`1.Value">
<summary>
 Wait for the completion of the operation and get its result
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncFuture`1">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.TriggerCancel(Microsoft.FSharp.Core.Option`1{System.String})">
<summary>
 Raise the cancellation condition for this group of computations
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.Start(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">
<summary>
 Start the asynchronous computation as a work item. Do not await its result.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.SpawnFuture``1(Microsoft.FSharp.Control.Async`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.Spawn(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.RunWithContinuations``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Start the asynchronous computation as a work item. 
 Return a handle to the computation as an AsyncFuture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.RunSynchronously``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Run the asynchronous computation and await its result.

 If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.Run``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.Option`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup..ctor">
<summary>
 Generate a new asynchronous group
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncGroup">
<summary>
 A handle to a capability to cancel a set of asynchronous computations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncReplyChannel`1.Reply(``0)">
<summary>
 Send a reply to a PostAndReply message
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncReplyChannel`1">
<summary>
 A handle to a capability to reply to a PostAndReply message
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Async`1">
<summary>
 An asynchronous computation, which, when run, will eventually produce a value 
 of the given type, or else raise an exception. The value and/or exception is not returned 
 to the caller immediately, but is rather passed to a success continuation, exception continuation 
 or cancellation continuation. 

 Asynchronous computations are normally specified using the F# 'workflow' syntax for building 
 computations.

 When run, asynchronous computations can normally be thought of as running run in one of
 two modes: 'work item mode' or 'waiting mode'.

    - 'work item mode' indicates that the computation is executing as a work item,
      e.g. in the .NET Thread Pool via ThreadPool.QueueUserWorkItem, or is running
      a brief event-response action on the GUI thread. 

    - 'waiting mode' indicates the computations a waiting for asynchronous I/O completions,
      typically suspended as thunks using ThreadPool.RegisterWaitForSingleObject. 

 Asynchronous computations running as 'work items' should not generally perform blocking
 operations, e.g. long running synchronous loops. However, some asynchronous 
 computations may, out of necessity, need to execute blocking I/O operations: 
 these should be run on new threads or a user-managed pool of threads specifically 
 dedicated to resolving blocking conditions. For example, System.IO.OpenFile is, by 
 design, a blocking operation. However frequently it is important to code as 
 if this is asynchronous. This can be done by executing Async.SwitchToNewThread
 as part of the workflow.

 When run, asynchronous computations belong to an AsyncGroup. This can usually be specified 
 when the async computation is started. The only action on an AsyncGroup is to raise a cancellation 
 condition for the AsyncGroup. Async values check the cancellation condition for their AsyncGroup 
 regularly, though synchronous computations within an asynchronous computation will not automatically 
 check this condition. This gives a user-level cooperative cancellation protocol.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.DelegateEvent`1.Publish">
<summary>
 Publish the event as a first class event value
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.DelegateEvent`1.Trigger(System.Object[]`1)">
<summary>
 Trigger the event using the given parameters
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.DelegateEvent`1..ctor">
<summary>
 Create an event object suitable for implementing an arbitrary type of delegate
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.DelegateEvent`1">
<summary>
 Event implementations for an arbitrary type of delegate
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Event`1.Publish">
<summary>
 Publish the event as a first class event value
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event`1.Trigger(``0)">
<summary>
 Trigger the event using the given parameters
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event`1..ctor">
<summary>
 Create an event object suitable for implementing for the IEvent&lt;_&gt; type
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Event`1">
<summary>
 Event implementations for the IEvent&lt;_&gt; type
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Event`2.Publish">
<summary>
 Publish the event as a first class event value
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event`2.Trigger(System.Object,``1)">
<summary>
 Trigger the event using the given sender object and parameters. The sender object may be <c>null</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event`2..ctor">
<summary>
 Create an event object suitable for delegate types following the standard .NET Framework convention of a first 'sender' argument
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Event`2">
<summary>
 Event implementations for a delegate types following the standard .NET Framework convention of a first 'sender' argument
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Handler`1.Invoke(System.Object,``0)">

</member>
<member name="T:Microsoft.FSharp.Control.Handler`1">
<summary>
 A delegate type associated with the F# event type <c>IEvent&lt;_&gt;</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.RemoveHandler(``0)">
<summary>
 Remove a listener delegate from an event listener store
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.AddHandler(``0)">
<summary>
 Connect a handler delegate object to the event.  A handler can
 be later removed using RemoveHandler.  The listener will
 be invoked when the event is fired.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IDelegateEvent`1">
<summary>
 F# gives special status to non-virtual instance member properties compatible with type IDelegateEvent, 
 generating approriate .NET metadata to make the member appear to other .NET languages as a
 .NET event.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`1">
<summary>
 First-class listening points (i.e. objects that permit you to register a 'callback'
 activated when the event is triggered). See the module <c>Event</c>
 for functions to create events.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent`2.Add(Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit})">
<summary>
 Connect a listener function to the event. The listener will
 be invoked when the event is fired.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`2">
<summary>
The family of first class event values for delegate types that satisfy the F# delegate constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.Value">
<summary>
 Force the execution of this value and return its result. Same as Value. Mutual exclusion is used to 
 prevent other threads also computing the value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.IsForced">
<summary>
 Indicates if the lazy value has been successfully computed
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.IsException">
<summary>
 Indicates if the lazy value is being computed or the computation raised an exception
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.IsDelayed">
<summary>
 Indicates if the lazy value has yet to be computed 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.UnsynchronizedForce">
<summary>
 Same as Force, except no lock is taken. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.SynchronizedForce">
<summary>
 Same as Force
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.Force">
<summary>
 Force the execution of this value and return its result. Same as Value. Mutual exclusion is used to 
 prevent other threads also computing the value. If the value is re-forced during its own computation
 the <c>Undefined</c> exception is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.CreateFromValue(``0)">
<summary>
 Create a lazy computation that evaluates to the given value when forced
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.Create(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Create a lazy computation that evaluates to the result of the given function when forced
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Lazy`1">
<summary>
 The type of delayed computations.
 
 Use the values in the <c>Lazy</c> module to manipulate 
 values of this type, and the notation 'lazy expr' to create values
 of this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.MailboxProcessor`1.DefaultTimeout(System.Int32)">
<summary>
 Raise a timeout exception if a message not received in this amount of time. Default infinite.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.MailboxProcessor`1.DefaultTimeout">
<summary>
 Raise a timeout exception if a message not received in this amount of time. Default infinite.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.TryScan``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.Async`1{``1}}},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 look through messages in arrival order until 'scanner' returns a Some value. No thread
 is blocked while waiting for further messages. Return None
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.TryReceive(Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 consume the first message in arrival order. No thread
 is blocked while waiting for further messages. Return None
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.TryPostAndReply``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Like PostAndReply, but return None if no reply within the timeout period. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Start(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.MailboxProcessor`1{``0},Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">
<summary>
 Create and start an instance of a MailboxProcessor. The asynchronous computation executed by the
 processor is the one returned by the 'initial' function. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Start">
<summary>
 Start the MailboxProcessor
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Scan``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.Async`1{``1}}},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 look through messages in arrival order until 'scanner' returns a Some value. No thread
 is blocked while waiting for further messages. Raise a TimeoutException
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Receive(Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 consume the first message in arrival order. No thread
 is blocked while waiting for further messages. Raise a TimeoutException
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.PostAndReply``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Post a message to the message queue of the MailboxProcessor and await a reply on the channel synchronously.
 The message is produced by a single call to the first function which must build a message
 containing the reply channel. The receiving MailboxProcessor must process this message and
 invoke the Reply method on the reply channel precisly once.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Post(``0)">
<summary>
 Post a message to the message queue of the MailboxProcessor, asynchronously
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.AsyncTryPostAndReply``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Like AsyncPostAndReply, but return None if no reply within the timeout period. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.AsyncPostAndReply``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Post a message to the message queue of the MailboxProcessor and await a reply on the channel asynchronously.
 The message is produced by a single call to the first function which must build a message
 containing the reply channel. The receiving MailboxProcessor must process this message and
 invoke the Reply method on the reply channel precisly once.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1..ctor(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.MailboxProcessor`1{``0},Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">
<summary>
 Create an instance of a MailboxProcessor. The asynchronous computation executed by the
 processor is the one returned by the 'initial' function. This function is not executed until
 'Start' is called.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.MailboxProcessor`1">
<summary>
 A MailboxProcessor is a message-processing agent defined using an asynchronous workflow. 
 The agent encapsulates a message queue that supports multiple-writers and the single reader agent.
 Writers send messages to the agent by using the Post, PostAndReply or AsyncPostAndReply methods.

 The reader agent is specified when creating the MailboxProcessor. The 
 agent is usually an asychronous workflow that waits for messages
 by using the Receive or TryReceive methods. 
 A MailboxProcessor may also scan through all available messages by using the 
 Scan or TryScan method. The encapsulated message queue only 
 supports a single active reader, thus at most one concurrent call to Receive, TryReceive,
 Scan and/or TryScan may be active at any one time.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.lazy`1">
<summary>
 The type of delayed computations.
 
 Use the values in the <c>Lazy</c> module to manipulate 
 values of this type, and the notation 'lazy expr' to create values
 of this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.UndefinedException">
<summary>
 An exeption type raised when the evaluation of a lazy value recursively depend upon itself
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.CommonExtensions">
<summary>
 A module of extension members that provide asynchronous operations for some basic .NET types related to concurrency and I/O.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.choose``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Control.IEvent`2{``2,``0})">
<summary>
 Return a new event which fires on a selection of messages from the original event.
 The selection function takes an original message to an optional new message.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.create``1">
<summary>
 Create an IEvent with no initial listeners. Two items are returned: 
 a function to invoke (trigger) the event, and the event that clients 
 can plug listeners into.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent`2{``1,``0})">
<summary>
 Return a new event that listens to the original event and triggers the resulting
 event only when the argument to the event passes the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.listen``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.IEvent`2{``1,``0})">
<summary>
 Run the given function each time the given event is triggered.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Control.IEvent`2{``2,``0})">
<summary>
 Return a new event that passes values transformed by the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.merge``3(Microsoft.FSharp.Control.IEvent`2{``0,``1},Microsoft.FSharp.Control.IEvent`2{``2,``1})">
<summary>
 Fire the output event when either of the input events fire
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.pairwise``2(Microsoft.FSharp.Control.IEvent`2{``0,``1})">
<summary>
 Return a new event that triggers on the second and subsequent triggerings of the input event.
 The Nth triggering of the input event passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
 Nth triggering occurs.

 You should ensure that the contents of the values being sent down the event are
 not mutable. Note that many EventArgs types are mutable, e.g. MouseEventArgs, and
 each firing of an event using this argument type may reuse the same physical 
 argument obejct with different values. In this case you should extract the necessary
 information from the argument before using this combinator.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.partition``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent`2{``1,``0})">
<summary>
 Return a new event that listens to the original event and triggers the 
 first resulting event if the application of the predicate to the event arguments
 returned true, and the second event if it returned false
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.scan``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Control.IEvent`2{``2,``1})">
<summary>
 Return a new event consisting of the results of applying the given accumulating function
 to successive values triggered on the input event.  An item of internal state
 records the current value of the state parameter.  The internal state is not locked during the
 execution of the accumulation function, so care should be taken that the 
 input IEvent not triggered by multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.split``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Choice`2{``1,``2}},Microsoft.FSharp.Control.IEvent`2{``3,``0})">
<summary>
 Return a new event that listens to the original event and triggers the 
 first resulting event if the application of the function to the event arguments
 returned a Choice1Of2, and the second event if it returns a Choice2Of2
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Event">
<summary>
 Basic operations on first class event objects.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AbstractClassAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AbstractClassAttribute">
<summary>
 Adding this attribute to class definition makes it abstract, which means it need not
 implement all its methods. Instances of abstract classes may not be constructed directly.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.AutoOpenAttribute.Path">
<summary>
 Indicates the namespace or module to be automatically opened when an assembly is referenced
 or an enclosing module opened.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute..ctor">
<summary>
 Create an attribute used to mark a module as 'automatically opened' when the enclosing namespace is opened
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute..ctor(System.String)">
<summary>
 Create an attribute used to mark a namespace or module path to be 'automatically opened' when an assembly is referenced
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AutoOpenAttribute">
<summary>
 This attribute is used for two purposes. When applied to an assembly, it must be given a string
 argument, and this argument must indicate a valid module or namespace in that assembly. Source
 code files compiled with a reference to this assembly are processed in an environment
 where the given path is automatically oepned.

 When applied to a module within an assembly, then the attribute must not be given any arguments.
 When the enclosing namespace is opened in user source code, the module is also implicitly opened.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.AutoSerializableAttribute.Value">
<summary>
 The value of the attribute, indicating whether the type is automatically marked serializable or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoSerializableAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AutoSerializableAttribute">
<summary>
 Adding this attribute to a type with value 'false' disables the behaviour where F# makes the
 type Serializable by default.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CLIEventAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CLIEventAttribute">
<summary>
 Adding this attribute to a property with event type causes it to be compiled with as a .NET 
 Common Language Infrastructure metadata event, through a syntactic translation to a pair of
 'add_EventName' and 'remove_EventName' methods.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`2">
<summary>
 Helper types for active patterns with 2 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`3">
<summary>
 Helper types for active patterns with 3 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`4">
<summary>
 Helper types for active patterns with 4 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`5">
<summary>
 Helper types for active patterns with 5 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`6">
<summary>
 Helper types for active patterns with 6 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`7">
<summary>
 Helper types for active patterns with 7 choices.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ClassAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ClassAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a .NET class.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.VariantNumber">
<summary>
 Indicates the variant number of the entity, if any, in a linear sequence of elements with F# source code
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SourceConstructFlags">
<summary>
 Indicates the relationship between the compiled entity and F# source code
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SequenceNumber">
<summary>
 Indicates the sequence number of the entity, if any, in a linear sequence of elements with F# source code
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceConstructFlags)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32,System.Int32)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationMappingAttribute">
<summary>
 This attribute is inserted automatically by the F# compiler to tag 
 types and methods in the gneerated .NET code with flags indicating the correspondence with
 original source constructs.  It is used by the functions in the
 Microsoft.FSharp.Reflection library to reverse-map compiled constructs
 to their original forms.  It is not intended for use from use code.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationRepresentationAttribute.Flags">
<summary>
 Indicates one or more adjustments to the compiled representation of an F# type or member
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationRepresentationAttribute..ctor(Microsoft.FSharp.Core.CompilationRepresentationFlags)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationAttribute">
<summary>
 This attribute is used to adjust the runtime representation for a type. 
 For example, it may be used to note that the <c>null</c> representation
 may be used for a type.  This affects how some constructs are compiled.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationFlags">
<summary>
 Indicates one or more adjustments to the compiled representation of an F# type or member
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultAugmentationAttribute.Value">
<summary>
 The value of the attribute, indicating whether the type has a default augmentation or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultAugmentationAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultAugmentationAttribute">
<summary>
 Adding this attribute to a discriminated union with value false
 turns off the generation of standard helper member tester, constructor 
 and accessor members for the generated .NET class for that type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultValueAttribute.Check">
<summary>
 Indicates if a constraint is asserted that the field type supports 'null'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultValueAttribute">
<summary>
 Adding this attribute to a field declaration means that the field is 
 not initialized. During type checking a constraint is asserted that the field type supports 'null'. 
 If the 'check' value is false then the constraint is not asserted. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.EntryPointAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.EntryPointAttribute">
<summary>
 Adding this attribute to a function indicates it is the entrypoint for an application.
 If this absent is not speficied for an EXE then the initialization implicit in the
 module bindings in the last file in the compilation sequence are used as the entrypoint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ExperimentalAttribute.Message">
<summary>
 Indicates the warning message to be emitted when F# source code uses this construct
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExperimentalAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ExperimentalAttribute">
<summary>
 This attribute is used to tag values that are part of an experimental library
 feature
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Release">
<summary>
 The release number of the F# version associated with the attribute
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Minor">
<summary>
 The minor version number of the F# version associated with the attribute
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Major">
<summary>
 The major version number of the F# version associated with the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute..ctor(System.Int32,System.Int32,System.Int32)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute">
<summary>
 This attribute is added to generated assemblies to indicate the 
 version of the data schema used to encode additional F#
 specific information in the resource attached to compiled F# libraries.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.op_Implicit(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Convert an F# first class function value to a value of type <c>System.Converter</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.op_Implicit(System.Converter`2{``0,``1})">
<summary>
 Convert an value of type <c>System.Converter</c> to a F# first class function value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.ToConverter(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Convert an F# first class function value to a value of type <c>System.Converter</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.FastFunc`2{``3,Microsoft.FSharp.Core.FastFunc`2{``4,``5}}}}},``0,``1,``2,``3,``4)">
<summary>
 Invoke an F# first class function value with five curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.FastFunc`2{``3,``4}}}},``0,``1,``2,``3)">
<summary>
 Invoke an F# first class function value with four curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}},``0,``1,``2)">
<summary>
 Invoke an F# first class function value with three curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},``0,``1)">
<summary>
 Invoke an F# first class function value with two curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.Invoke(``0)">
<summary>
 Invoke an F# first class function value with one argument
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.FromConverter(System.Converter`2{``0,``1})">
<summary>
 Convert an value of type <c>System.Converter</c> to a F# first class function value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2..ctor">
<summary>
 Construct an instance of an F# first class function value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FastFunc`2">
<summary>
 The .NET type used to represent F# function values.  This type is not
 typically used directly, though may be used from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``1(System.Action`1{``0})">
<summary>
 Convert the given Action delegate object to an F# function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``2(System.Converter`2{``0,``1})">
<summary>
 Convert the given Converter delegate object to an F# function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``3(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`2{``0,``1},``2})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``4(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`3{``0,``1,``2},``3})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``5(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`4{``0,``1,``2,``3},``4})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``6(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,``3,``4},``5})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FuncConvert">
<summary>
 Helper functions for converting F# first class function values to and from .NET representaions
 of functions using delegates.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.GeneralizableValueAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.GeneralizableValueAttribute">
<summary>
 Adding this attribute to a non-function value with generic parameters indicates that 
 uses of the construct can give rise to generic code through type inference. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)">

</member>
<member name="T:Microsoft.FSharp.Core.IStructuralComparable">

</member>
<member name="M:Microsoft.FSharp.Core.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)">

</member>
<member name="M:Microsoft.FSharp.Core.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)">

</member>
<member name="T:Microsoft.FSharp.Core.IStructuralEquatable">

</member>
<member name="M:Microsoft.FSharp.Core.InterfaceAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.InterfaceAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a .NET interface.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LiteralAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LiteralAttribute">
<summary>
 Adding this attribute to a value causes it to be compiled as a .NET constant literal.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute">
<summary>
 Adding this attribute to a type causes it to be interpreted as a refined type, currently limited to measure-parameterized types.
 This may only be used under very limited conditions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAttribute">
<summary>
 Adding this attribute to a type causes it to be interpreted as a unit of measure.
 This may only be used under very limited conditions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoDynamicInvocationAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NoDynamicInvocationAttribute">
<summary>
 This attribute is used to tag values that may not be dynamically invoked at runtime. This is
 typically added to inlined functions whose implementations include unverifiable code. It
 causes the method body emitted for the inlined function to raise an exception if 
 dynamically invoked, rather than including the unverifiable code in the generated
 assembly.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.OCamlCompatibilityAttribute.Message">
<summary>
 Indicates the warning message to be emitted when F# source code uses this construct
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OCamlCompatibilityAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OCamlCompatibilityAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OCamlCompatibilityAttribute">
<summary>
 This attribute is used to tag values, modules and types that are only
 present in F# to permit a degree of code-compatibility and cross-compilation
 with other implementations of ML-familty languages, in particular OCaml. The
 use of the construct will give a warning unless the --ml-compatibility flag
 is specified.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.Value">
<summary>
 Get the value of a 'Some' option. A NullReferenceException is raised if the option is 'None'.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.None">
<summary>
 Create an option value that is a 'None' value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.IsSome">
<summary>
 Return 'true' if the option is a 'Some' value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.IsNone">
<summary>
 Return 'true' if the option is a 'None' value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option`1.Some(``0)">
<summary>
 Create an option value that is a 'Some' value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Option`1">
<summary>
 The type of optional values.  When used from other .NET languages the
 empty option is the <c>null</c> value.  

 Use the constructors <c>Some</c> and <c>None</c> to create values of this type.
 Use the values in the <c>Option</c> module to manipulate values of this type,
 or pattern match against the values directly.

 <c>None</c> values will appear as the value <c>null</c> to other .NET languages.
 Instance methods on this type will appear as static methods to other .NET languages
 due to the use of <c>null</c> as a value representation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptionalArgumentAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptionalArgumentAttribute">
<summary>
 This attribute is added automatically for all optional arguments
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.OverloadIDAttribute.UniqueName">
<summary>
 A unique identifier for this overloaded member within a given overload set
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OverloadIDAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OverloadIDAttribute">
<summary>
 Adding the OverloadID attribute to a member permits it to
 be part of a group overloaded by the same name and arity.  The string
 must be a unique name amongst those in the overload set.  Overrides
 of this method, if permitted, must be given the same OverloadID,
 and the OverloadID must be specified in both signature and implementation
 files if signature files are used.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Ref`1.Value(``0)">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Ref`1.Value">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Ref`1">
<summary>
 The type of mutable references.  Use the functions [:=] and [!] to get and
 set values of this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ReferenceEqualityAttribute.Value">

</member>
<member name="M:Microsoft.FSharp.Core.ReferenceEqualityAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReferenceEqualityAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ReferenceEqualityAttribute">
<summary>
 Adding this attribute to a record or union type disables the automatic generation
 of overrides for 'System.Object.Equals(obj)', 'System.Object.GetHashCode()' 
 and 'System.IComparable' for the type. The type will by default use reference equality.
 This is identical to adding attributes StructuralEquality(false) and StructuralComparison(false).
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReflectedDefinitionAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ReflectedDefinitionAttribute">
<summary>
 Adding this attribute to the let-binding for the definition of a top-level 
 value makes the quotation expression that implements the value available
 for use at runtime.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute">
<summary>
 This attribute is used to indicate that references to a the elements of a module, record or union 
 type require explicit qualified access.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute">
<summary>
 Adding this attribute to a type, value or member requires that 
 uses of the construct must explicitly instantiate any generic type parameters.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SealedAttribute.Value">
<summary>
 The value of the attribute, indicating whether the type is sealed or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.SealedAttribute">
<summary>
 Adding this attribute to class definition makes it sealed, which means it may not
 be extended or implemented.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.SourceConstructFlags">
<summary>
 Indicates the relationship between a compiled entity in a CLI binary and an element in F# source code
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.StructAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a .NET struct.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.StructuralComparisonAttribute.Value">
<summary>
 The value of the attribute, indicating whether the type uses structural comparison or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralComparisonAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralComparisonAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralComparisonAttribute">
<summary>
 Adding this attribute to a record, union or struct type with value 'false' disables the automatic generation
 of implementations for 'System.IComparable' for the type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.StructuralEqualityAttribute.Value">
<summary>
 The value of the attribute, indicating whether the type uses structural equality or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralEqualityAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralEqualityAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralEqualityAttribute">
<summary>
 Adding this attribute to a record, union or struct type with value 'false' 
 confirms the automatic generation of overrides for 'System.Object.Equals(obj)' 
 and 'System.Object.GetHashCode()' for the type. This attribute is usually used in 
 conjunction with StructuralComparison(false) to generate a type that supports
 structural equality but not structural comparison.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute.Value">
<summary>
 Indicates the text to display by default when objects of this type are displayed 
 using '%A' printf formatting patterns and other two-dimensional text-based display 
 layouts. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute">
<summary>
 This attribute is used to mark how a type is displayed by default when using 
 '%A' printf formatting patterns and other two-dimensional text-based display layouts. 
 In this version of F# the only valid values are of the form <c>PreText {PropertyName} PostText</c>.
 The property name indicates a property to evaluate and to display instead of the object itself. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Tuple`1.Item1">

</member>
<member name="M:Microsoft.FSharp.Core.Tuple`1..ctor(``0)">

</member>
<member name="T:Microsoft.FSharp.Core.Tuple`1">
<summary>
 Compiled versions of F# tuple types.  These are not used directly, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Tuple`2.Item2">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`2.Item1">

</member>
<member name="M:Microsoft.FSharp.Core.Tuple`2..ctor(``0,``1)">

</member>
<member name="T:Microsoft.FSharp.Core.Tuple`2">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`3.Item3">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`3.Item2">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`3.Item1">

</member>
<member name="M:Microsoft.FSharp.Core.Tuple`3..ctor(``0,``1,``2)">

</member>
<member name="T:Microsoft.FSharp.Core.Tuple`3">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`4.Item4">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`4.Item3">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`4.Item2">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`4.Item1">

</member>
<member name="M:Microsoft.FSharp.Core.Tuple`4..ctor(``0,``1,``2,``3)">

</member>
<member name="T:Microsoft.FSharp.Core.Tuple`4">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`5.Item5">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`5.Item4">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`5.Item3">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`5.Item2">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`5.Item1">

</member>
<member name="M:Microsoft.FSharp.Core.Tuple`5..ctor(``0,``1,``2,``3,``4)">

</member>
<member name="T:Microsoft.FSharp.Core.Tuple`5">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`6.Item6">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`6.Item5">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`6.Item4">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`6.Item3">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`6.Item2">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`6.Item1">

</member>
<member name="M:Microsoft.FSharp.Core.Tuple`6..ctor(``0,``1,``2,``3,``4,``5)">

</member>
<member name="T:Microsoft.FSharp.Core.Tuple`6">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`7.Item7">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`7.Item6">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`7.Item5">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`7.Item4">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`7.Item3">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`7.Item2">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`7.Item1">

</member>
<member name="M:Microsoft.FSharp.Core.Tuple`7..ctor(``0,``1,``2,``3,``4,``5,``6)">

</member>
<member name="T:Microsoft.FSharp.Core.Tuple`7">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`8.Rest">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`8.Item7">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`8.Item6">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`8.Item5">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`8.Item4">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`8.Item3">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`8.Item2">

</member>
<member name="P:Microsoft.FSharp.Core.Tuple`8.Item1">

</member>
<member name="M:Microsoft.FSharp.Core.Tuple`8..ctor(``0,``1,``2,``3,``4,``5,``6,``7)">

</member>
<member name="T:Microsoft.FSharp.Core.Tuple`8">

</member>
<member name="M:Microsoft.FSharp.Core.TypeFunc.Specialize``1">
<summary>
 Specialize the type function at a given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.TypeFunc..ctor">
<summary>
 Construct an instance of an F# first class type function value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.TypeFunc">
<summary>
 The .NET type used to represent F# first-class type function values.  This type is for use
 by compiled F# code.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Unit">
<summary>
 The type 'unit', which has only one value "()". This value is special and
 always uses the representation 'null'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.UnverifiableAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.UnverifiableAttribute">
<summary>
 This attribute is used to tag values whose use will result in the generation
 of unverifiable code. These values are inevitably marked 'inline' to ensure that
 the unverifiable constructs are not present in the actual code for the F# library,
 but are rather copied to the source code of the caller.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,,]`1">
<summary>
 Four dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.

 Use the values in the <c>Array4D</c> module
 to manipulate values of this type, or the notation 'arr.[x1,x2,x3,x4]' to get and set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,]`1">
<summary>
 Three dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.

 Use the values in the <c>Array3D</c> module
 to manipulate values of this type, or the notation 'arr.[x1,x2,x3]' to get and set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,]`1">
<summary>
 Two dimensional arrays, typically zero-based. 

 Use the values in the <c>Array2D</c> module
 to manipulate values of this type, or the notation 'arr.[x,y]' to get/set array
 values.   

 Non-zero-based arrays can also be created using methods on the System.Array type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[]`1">
<summary>
 Single dimensional, zero-based arrays, written 'int[]', 'string[]' etc.
 Use the values in the <c>Array</c> module to manipulate values 
 of this type, or the notation 'arr.[x]' to get/set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.array`1">
<summary>
 Single dimensional, zero-based arrays, written 'int[]', 'string[]' etc.
 Use the values in the <c>Array</c> module to manipulate values 
 of this type, or the notation 'arr.[x]' to get/set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.bigint">
<summary>
 An abbreviation for the type <c>Microsoft.FSharp.Math.BigInt</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.bool">
<summary>
 An abbreviation for the .NET type <c>System.Boolean</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byref`1">
<summary>
 Represents a managed pointer in F# code.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byte">
<summary>
 An abbreviation for the .NET type <c>System.Byte</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.char">
<summary>
 An abbreviation for the .NET type <c>System.Char</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.decimal">
<summary>
 An abbreviation for the .NET type <c>System.Decimal</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.decimal`1">
<summary>
 The type of decimal numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Decimal</c>.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.double">
<summary>
 An abbreviation for the .NET type <c>System.Double</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.exn">
<summary>
 An abbreviation for the .NET type <c>System.Exception</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float">
<summary>
 An abbreviation for the .NET type <c>System.Double</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float32">
<summary>
 An abbreviation for the .NET type <c>System.Single</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float32`1">
<summary>
 The type of floating point numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Single</c>.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float`1">
<summary>
 The type of floating point numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Double</c>.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ilsigptr`1">
<summary>
 This type is for internal use by the F# code generator
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int">
<summary>
 An abbreviation for the .NET type <c>System.Int32</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int16">
<summary>
 An abbreviation for the .NET type <c>System.Int16</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int16`1">
<summary>
 The type of 16-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Int16</c>.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int32">
<summary>
 An abbreviation for the .NET type <c>System.Int32</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int64">
<summary>
 An abbreviation for the .NET type <c>System.Int64</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int64`1">
<summary>
 The type of 64-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Int64</c>.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int8">
<summary>
 An abbreviation for the .NET type <c>System.SByte</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int8`1">
<summary>
 The type of 8-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.SByte</c>.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int`1">
<summary>
 The type of 32-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Int32</c>.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.nativeint">
<summary>
 An abbreviation for the .NET type <c>System.IntPtr</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.nativeptr`1">
<summary>
 Represents an unmanaged pointer in F# code.

 This type should only be used when writing F# code that interoperates
 with native code.  Use of this type in F# code may result in
 unverifiable code being generated.  Conversions to and from the 
 <c>nativeint</c> type may be required. Values of this type can be generated
 by the functions in the <c>NativeInterop.NativePtr</c> module.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.obj">
<summary>
 An abbreviation for the .NET type <c>System.Object</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.option`1">
<summary>
 The type of optional values.  When used from other .NET languages the
 empty option is the <c>null</c> value.  

 Use the constructors <c>Some</c> and <c>None</c> to create values of this type.
 Use the values in the <c>Option</c> module to manipulate values of this type,
 or pattern match against the values directly.

 'None' values will appear as the value <c>null</c> to other .NET languages.
 Instance methods on this type will appear as static methods to other .NET languages
 due to the use of <c>null</c> as a value representation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ref`1">
<summary>
 The type of mutable references.  Use the functions [:=] and [!] to get and
 set values of this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte">
<summary>
 An abbreviation for the .NET type <c>System.SByte</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.single">
<summary>
 An abbreviation for the .NET type <c>System.Single</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.string">
<summary>
 An abbreviation for the .NET type <c>System.String</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint16">
<summary>
 An abbreviation for the .NET type <c>System.UInt16</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint32">
<summary>
 An abbreviation for the .NET type <c>System.UInt32</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint64">
<summary>
 An abbreviation for the .NET type <c>System.UInt64</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint8">
<summary>
 An abbreviation for the .NET type <c>System.Byte</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.unativeint">
<summary>
 An abbreviation for the .NET type <c>System.UIntPtr</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.unit">
<summary>
 The type 'unit', which has only one value "()". This value is special and
 always uses the representation 'null'.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.DynamicInvocationNotSupportedException">
<summary>
 Dynamic invocations of functions marked with the NoDynamicInvocationAttribute attribute raise this exception
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FailureException">
<summary>
 This exception is raised by 'failwith'
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.MatchFailureException">
<summary>
 Non-exhaustive match failures will raise the MatchFailure exception
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.Array2">

</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.Array3">

</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.IEvent">

</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.any_to_string``1(``0)">

</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.async">
<summary>
 Build an aysnchronous workflow using computation expression syntax
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.dict``2(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Builds a lookup table from a sequence of key/value pairs. The key objects are indexed using generic hashing and equality.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.eprintf``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to <c>stderr</c> using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.eprintfn``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to <c>stderr</c> using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.failwithf``2(Microsoft.FSharp.Text.PrintfFormat`4{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Print to a string buffer and raise an exception with the given
 result.   Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.fprintf``1(System.IO.TextWriter,Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a file using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.fprintfn``1(System.IO.TextWriter,Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a file using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.op_Splice``1(Microsoft.FSharp.Quotations.Expr`1{``0})">
<summary>
 Special prefix operator for splicing typed expressions into quotation holes
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.op_SpliceUntyped``1(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Special prefix operator for splicing untyped expressions into quotation holes
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.output_any``1(System.IO.TextWriter,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.print_any``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.printf``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to <c>stdout</c> using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.printfn``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to <c>stdout</c> using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.seq``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Builds a sequence using sequence expression syntax
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.set``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Builds a set from a sequence of objects. The key objects are indexed using generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.sprintf``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
 Print to a string using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.|Lazy|``1(Microsoft.FSharp.Control.Lazy`1{``0})">
<summary>
 An active pattern to force the execution of values of type <c>Lazy&lt;_&gt;</c>
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ExtraTopLevelOperators">
<summary>
Pervasives: Additional bindings available at the top level 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.AdditionDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the '+' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedAdditionDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the checked '+' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedMultiplyDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the checked '+' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DefaultValue``1">
<summary>
 Generate a null value for reference types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByInt``1(``0,System.Int32)">
<summary>
 Divide a floating point value by an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByIntDynamic``1(``0,System.Int32)">
<summary>
 A compiler intrinsic that implements dynamic invocations for the DivideByInt primitive
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumOfValue``2(``0)">
<summary>
 Build an enum value from an underlying value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumToValue``2(``0)">
<summary>
 Get the underlying value for an enum value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FSharpComparer">
<summary>
 A static F# comparer object
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FSharpEqualityComparer">
<summary>
 Return an F# comparer object suitable for hashing and equality. This hashing behaviour
 of the returned comparer is not limited by an overall node count when hashing F#
 records, lists and union types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparer``1">
<summary>
 Make an F# comparer object for the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericEqualityComparer``1">
<summary>
 Make an F# hash/equality object for the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastLimitedGenericEqualityComparer``1(System.Int32)">
<summary>
 Make an F# hash/equality object for the given type using node-limited hashing when hashing F#
 records, lists and union types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparison``1(``0,``0)">
<summary>
 Compare two values 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparisonWithComparer``1(System.Collections.IComparer,``0,``0)">
<summary>
 Compare two values. May be called as a recursive case from an implementation of System.IComparable to
 ensure consistent NaN comparison semantics.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEquality``1(``0,``0)">
<summary>
 Compare two values for equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityWithComparer``1(System.Collections.IEqualityComparer,``0,``0)">
<summary>
 Compare two values for equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterOrEqual``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterThan``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHash``1(``0)">
<summary>
 Hash a value according to its structure.  This hash is not limited by an overall node count when hashing F#
 records, lists and union types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHashWithComparer``1(System.Collections.IEqualityComparer,``0)">
<summary>
 Recursively hash a part of a value according to its structure.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessOrEqual``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessThan``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLimitedHash``1(System.Int32,``0)">
<summary>
 Hash a value according to its structure.  Use the given limit to restrict the hash when hashing F#
 records, lists and union types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMaximum``1(``0,``0)">
<summary>
 Take the maximum of two values structurally according to the order given by GenericComparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMinimum``1(``0,``0)">
<summary>
 Take the minimum of two values structurally according to the order given by GenericComparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOne``1">
<summary>
 Resolves to the one value for any primitive numeric type or any type with a static member called 'One'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOneDynamic``1">
<summary>
 Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZero``1">
<summary>
 Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZeroDynamic``1">
<summary>
 Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.MultiplyDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the '+' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt32(System.String)">
<summary>
 Parse an int32 according to the rules used by the overloaded 'int32' conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt64(System.String)">
<summary>
 Parse an int64 according to the rules used by the overloaded 'int64' conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt32(System.String)">
<summary>
 Parse an uint32 according to the rules used by the overloaded 'uint32' conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt64(System.String)">
<summary>
 Parse an uint64 according to the rules used by the overloaded 'uint64' conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalEquality``1(``0,``0)">
<summary>
 Reference/physical equality. 
 True if boxed versions of the inputs are reference-equal, OR if
 both are primitive numeric types and the implementation of Object.Equals for the type
 of the first argument returns true on the boxed versions of the inputs.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalHash``1(``0)">
<summary>
 The physical hash.  Hashes on the object identity, except for value types,
 where we hash on the contents.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple2``2(System.Collections.IComparer,Microsoft.FSharp.Core.Tuple`2{``0,``1},Microsoft.FSharp.Core.Tuple`2{``0,``1})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple3``3(System.Collections.IComparer,Microsoft.FSharp.Core.Tuple`3{``0,``1,``2},Microsoft.FSharp.Core.Tuple`3{``0,``1,``2})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple4``4(System.Collections.IComparer,Microsoft.FSharp.Core.Tuple`4{``0,``1,``2,``3},Microsoft.FSharp.Core.Tuple`4{``0,``1,``2,``3})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple5``5(System.Collections.IComparer,Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,``3,``4})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple2``2(System.Collections.IEqualityComparer,Microsoft.FSharp.Core.Tuple`2{``0,``1},Microsoft.FSharp.Core.Tuple`2{``0,``1})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple3``3(System.Collections.IEqualityComparer,Microsoft.FSharp.Core.Tuple`3{``0,``1,``2},Microsoft.FSharp.Core.Tuple`3{``0,``1,``2})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple4``4(System.Collections.IEqualityComparer,Microsoft.FSharp.Core.Tuple`4{``0,``1,``2,``3},Microsoft.FSharp.Core.Tuple`4{``0,``1,``2,``3})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple5``5(System.Collections.IEqualityComparer,Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,``3,``4})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple2``2(System.Collections.IEqualityComparer,Microsoft.FSharp.Core.Tuple`2{``0,``1})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple3``3(System.Collections.IEqualityComparer,Microsoft.FSharp.Core.Tuple`3{``0,``1,``2})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple4``4(System.Collections.IEqualityComparer,Microsoft.FSharp.Core.Tuple`4{``0,``1,``2,``3})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple5``5(System.Collections.IEqualityComparer,Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,``3,``4})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonWithComparerIntrinsic``1(System.Collections.IComparer,``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterOrEqualIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterThanIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashIntrinsic``1(``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessOrEqualIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessThanIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.LimitedGenericHashIntrinsic``1(System.Int32,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalEqualityIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalHashIntrinsic``1(``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare">
<summary>
 The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CreateInstance``1">
<summary>
 This function implements calls to default constructors
 acccessed by 'new' constraints.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.Dispose``1(``0)">
<summary>
 A compiler intrinsic for the efficeint compilation of sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray``1(``0[]`1,System.Int32)">
<summary>
 The standard overloaded associative (indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray2D``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 The standard overloaded associative (2-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray3D``1(``0[,,]`1,System.Int32,System.Int32,System.Int32)">
<summary>
 The standard overloaded associative (3-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray4D``1(``0[,,,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 The standard overloaded associative (4-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetString(System.String,System.Int32)">
<summary>
 Primitive used by pattern match compilation 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.MakeDecimal(System.Int32,System.Int32,System.Int32,System.Boolean,System.Byte)">
<summary>
 This function implements parsing of decimal constants
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray``1(``0[]`1,System.Int32,``0)">
<summary>
 The standard overloaded associative (indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray2D``1(``0[,]`1,System.Int32,System.Int32,``0)">
<summary>
 The standard overloaded associative (2-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray3D``1(``0[,,]`1,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 The standard overloaded associative (3-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray4D``1(``0[,,,]`1,System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 The standard overloaded associative (4-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestFast``1(System.Object)">
<summary>
 A compiler intrinsic that implements the ':?' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestGeneric``1(System.Object)">
<summary>
 A compiler intrinsic that implements the ':?' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxFast``1(System.Object)">
<summary>
 A compiler intrinsic that implements the ':?>' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric``1(System.Object)">
<summary>
 A compiler intrinsic that implements the ':?>' operator
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions">
<summary>
 The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_AddressOf``1(``0)">
<summary>
 Address-of. Uses of this value may result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_Amp(System.Boolean,System.Boolean)">
<summary>
 Binary 'and'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanAnd(System.Boolean,System.Boolean)">
<summary>
 Binary 'and'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanOr(System.Boolean,System.Boolean)">
<summary>
 Binary 'or'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_IntegerAddressOf``1(``0)">
<summary>
 Address-of. Uses of this value may result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.or(System.Boolean,System.Boolean)">
<summary>
 Binary 'or'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators">
<summary>
 The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives">
<summary>
 Language primitives associated with the F# language
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt32(System.Int32)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form 'dddI' 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt64(System.Int64)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form 'dddI' 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromOne">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form 'dddI' 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromString(System.String)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form 'dddI' 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromZero">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form 'dddI' 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form 'dddI' 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromInt32``1(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromInt64``1(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromOne``1">

</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromString``1(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromZero``1">

</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN">
<summary>
 Provide a default implementation of the F# numeric literal syntax 'dddN' 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form 'dddI' 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.InvalidArgumentException">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidArgument(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.abs``1(``0)">
<summary>
 Absolute value of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.acos``1(``0)">
<summary>
 Inverse cosine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.asin``1(``0)">
<summary>
 Inverse sine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.atan``1(``0)">
<summary>
 Inverse tangent of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.atan2``2(``0,``0)">
<summary>
 Inverse tangent of <c>x/y</c> where <c>x</c> and <c>y</c> are specified separately
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.box``1(``0)">
<summary>
 Boxes a strongly typed value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.byte``1(``0)">
<summary>
 Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Byte.Parse()</c> on strings and otherwise requires a <c>ToByte</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ceil``1(``0)">
<summary>
 Ceiling of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.char``1(``0)">
<summary>
 Converts the argument to character. Numeric inputs are converted according to the UTF-16 
 encoding for characters. String inputs must be exactly one character long.
 For other types a static member ToChar must exist on the type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.compare``1(``0,``0)">
<summary>
 Generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.cos``1(``0)">
<summary>
 Cosine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.cosh``1(``0)">
<summary>
 Hyperbolic cosine  of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.decimal``1(``0)">
<summary>
 Converts the argument to System.Decimal using a direct conversion for all 
 primitive numeric types and requiring a <c>ToDecimal</c> method otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.decr(Microsoft.FSharp.Core.Ref`1{System.Int32})">
<summary>
 Decrement a mutable reference cell containing an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.defaultArg``1(Microsoft.FSharp.Core.Option`1{``0},``0)">
<summary>
 Used to specify a default value for an optional argument in the implementation of a function
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.double``1(``0)">
<summary>
 Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToDouble</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.enum``1(System.Int32)">
<summary>
 Converts the argument to a particular enum type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.exit``1(System.Int32)">
<summary>
 Exit the current hardware isolated process, if security settings permit,
 otherwise raise an exception.  Calls <c>System.Environment.Exit</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.exp``1(``0)">
<summary>
 Exponential of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.failwith``1(System.String)">
<summary>
 Throw a <c>FailureException</c> exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.float``1(``0)">
<summary>
 Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToDouble</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.float32``1(``0)">
<summary>
 Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToSingle</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.floor``1(``0)">
<summary>
 Floor of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.fst``2(Microsoft.FSharp.Core.Tuple`2{``0,``1})">
<summary>
 Return the first element of a tuple, <c>fst (a,b) = a</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.hash``1(``0)">
<summary>
 A generic hash function, designed to return equal hash values for items that are 
 equal according to the "=" operator. By default it will use structural hashing
 for F# union, record and tuple types, hashing the complete contents of the 
 type. The exact behaviour of the function can be adjusted on a 
 type-by-type basis by implementing GetHashCode for each type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.id``1(``0)">
<summary>
 The identity function
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ignore``1(``0)">
<summary>
 Ignore the passed value. This is often used to throw away results of a computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.incr(Microsoft.FSharp.Core.Ref`1{System.Int32})">
<summary>
 Increment a mutable reference cell containing an integer
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.infinity">
<summary>
 Equivalent to <c>System.Double.PositiveInfinity</c>
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.infinityf">
<summary>
 Equivalent to <c>System.Single.PositiveInfinity</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.int``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToInt32</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.int16``1(``0)">
<summary>
 Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int16.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToInt16</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.int32``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToInt32</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.int64``1(``0)">
<summary>
 Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int64.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToInt64</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.invalidArg``1(System.String,System.String)">
<summary>
 Throw an <c>ArgumentException</c> exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.invalidOp``1(System.String)">
<summary>
 Throw an <c>InvalidOperationException</c> exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.invalid_arg``1(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.invalid_op``1(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.limitedHash``1(System.Int32,``0)">
<summary>
 A generic hash function. This function has the same behaviour as 'hash', 
 however the default structural hashing for F# union, record and tuple 
 types stops when the given limit of nodes is reached. The exact behaviour of 
 the function can be adjusted on a type-by-type basis by implementing 
 GetHashCode for each type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.lock``2(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Execute the function as a mutual-exlcusion region using the input value as a lock. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.log``1(``0)">
<summary>
 Natural logarithm of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.log10``1(``0)">
<summary>
 Logarithm to base 10 of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.max``1(``0,``0)">
<summary>
 Maximum based on generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.min``1(``0,``0)">
<summary>
 Minimum based on generic comparison
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.nan">
<summary>
 Equivalent to <c>System.Double.NaN</c>
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.nanf">
<summary>
 Equivalent to <c>System.Single.NaN</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.nativeint``1(``0)">
<summary>
 Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types and <c>ToIntPtr</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.not(System.Boolean)">
<summary>
 Negate a logical value. <c>not true</c> equals <c>false</c> and <c>not false</c> equals <c>true</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.not_found``1">
<summary>
 Throw an <c>KeyNotFoundException</c> exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.nullArg``1(System.String)">
<summary>
 Throw an <c>ArgumentNullException</c> exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Addition``3(``0,``1)">
<summary>
 Overloaded addition operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Append``1(Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Concatenate two lists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BarBarBarGreater``4(``0,``1,``2,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}})">
<summary>
 Apply a function to three values, the values being a triple on the left, the function on the right
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BarBarGreater``3(``0,``1,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}})">
<summary>
 Apply a function to two values, the values being a pair on the left, the function on the right
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseAnd``1(``0,``0)">
<summary>
 Overloaded logical-AND operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseOr``1(``0,``0)">
<summary>
 Overloaded logical-OR operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ColonEquals``1(Microsoft.FSharp.Core.Ref`1{``0},``0)">
<summary>
 Assign to a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeLeft``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.FastFunc`2{``2,``0})">
<summary>
 Compose two functions, the function on the right being applied first
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeRight``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.FastFunc`2{``1,``2})">
<summary>
 Compose two functions, the function on the left being applied first
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Concatenate(System.String,System.String)">
<summary>
 Concatenate two strings.  The overlaoded operator '+' may also be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Dereference``1(Microsoft.FSharp.Core.Ref`1{``0})">
<summary>
 Dereference a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Division``3(``0,``1)">
<summary>
 Overloaded division operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Equality``1(``0,``0)">
<summary>
Structural equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ExclusiveOr``1(``0,``0)">
<summary>
 Overloaded logical-XOR operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Exponentiation``1(``0,``0)">
<summary>
 Overloaded power operator.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThan``1(``0,``0)">
<summary>
 Structural greater-than
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThanOrEqual``1(``0,``0)">
<summary>
Structural greater-than-or-equal
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LeftShift``1(``0,System.Int32)">
<summary>
 Overloaded byte-shift left operator by a specified number of bits
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessBarBar``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},``0,``1)">
<summary>
 Apply a function to two values, the values being a pair on the right, the function on the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessBarBarBar``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}},``0,``1,``2)">
<summary>
 Apply a function to three values, the values being a triple on the right, the function on the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessGreater``1(``0,``0)">
<summary>
Structural inequality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThan``1(``0,``0)">
<summary>
 Structural less-than comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThanOrEqual``1(``0,``0)">
<summary>
Structural less-than-or-equal comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LogicalNot``1(``0)">
<summary>
 Overloaded logical-NOT operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Modulus``3(``0,``1)">
<summary>
 Overloaded modulo operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Multiply``3(``0,``1)">
<summary>
 Overloaded multiplication operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0)">
<summary>
 Apply a function to a value, the value being on the right, the function on the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Apply a function to a value, the value being on the left, the function on the right
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Range``1(``0,``0)">
<summary>
 The standard overloaded range operator, e.g. <c>[n..m]</c> for lists, <c>seq {n..m}</c> for sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RangeStep``2(``0,``1,``0)">
<summary>
 The standard overloaded skip range operator, e.g. <c>[n..skip..m]</c> for lists, <c>seq {n..skip..m}</c> for sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RightShift``1(``0,System.Int32)">
<summary>
 Overloaded byte-shift right operator by a specified number of bits
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Subtraction``3(``0,``1)">
<summary>
 Overloaded subtraction operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryNegation``1(``0)">
<summary>
 Overloaded unary negation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryPlus``1(``0)">
<summary>
 Overloaded prefix=plus operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.pown``1(``0,System.Int32)">
<summary>
 Overloaded power operator. If <c>n > 0</c> then equivalent to <c>x*...*x</c> for <c>n</c> occurrences of <c>x</c>. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.raise``1(System.Exception)">
<summary>
 Raises an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ref``1(``0)">
<summary>
 Create a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.rethrow``1">
<summary>
 Rethrows an exception. This should only be used when handling an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.round``1(``0)">
<summary>
 Round the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sbyte``1(``0)">
<summary>
 Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>SByte.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToSByte</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sign``1(``0)">
<summary>
 Sign of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sin``1(``0)">
<summary>
 Sine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.single``1(``0)">
<summary>
 Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToSingle</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sinh``1(``0)">
<summary>
 Hyperbolic sine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sizeof``1">
<summary>
 Returns the internal size of a type in bytes. For example, <c>sizeof&lt;int&gt;</c> returns 4.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.snd``2(Microsoft.FSharp.Core.Tuple`2{``0,``1})">
<summary>
 Return the second element of a tuple, <c>snd (a,b) = b</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sqrt``2(``0)">
<summary>
 Square root of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.stderr``1">
<summary>
 Reads the value of the property <c>System.Console.Error</c>. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.stdin``1">
<summary>
 Reads the value of the property <c>System.Console.In</c>. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.stdout``1">
<summary>
 Reads the value of the property <c>System.Console.Out</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.string``1(``0)">
<summary>
 Converts the argument to a string using <c>ToString</c>.
 For standard integer and floating point values the <c>ToString</c> conversion uses <c>CultureInfo.InvariantCulture</c>.
 Note, native integer <c>ToString</c> does not support specifying <c>CultureInfo</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.tan``1(``0)">
<summary>
 Tangent of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.tanh``1(``0)">
<summary>
 Hyperbolic tangent of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.truncate``1(``0)">
<summary>
 Overloaded truncate operator.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.typedefof``1">
<summary>
 Generate a System.Type representation for a type definition. If the
 input type is a generic type instantiation then return the 
 generic type definition associated with all such instantiations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.typeof``1">
<summary>
 Generate a System.Type runtime represenation of a static type.
 The static type is still maintained on the value returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.uint16``1(``0)">
<summary>
 Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt16.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToUInt16</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.uint32``1(``0)">
<summary>
 Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt32.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToUInt32</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.uint64``1(``0)">
<summary>
 Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToUInt64</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.unativeint``1(``0)">
<summary>
 Converts the argument to unsigned native integer using a direct conversion for all 
 primitive numeric types and requiring a <c>ToUintPtr</c> method otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.unbox``1(System.Object)">
<summary>
 Unboxes a strongly typed value. This is the inverse of <c>box</c>, unbox&lt;t&gt;(box&lt;t&gt; a) equals a.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.using``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Clean up resources associated with the input object after the completion of the given function.
 Cleanup occurs even when an exception is raised by the protected
 code. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.|InvalidArgument|_|(System.Exception)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.|KeyValue|``2(System.Collections.Generic.KeyValuePair`2{``0,``1})">
<summary>
 An active pattern to match values of type <c>System.Collections.Generic.KeyValuePair</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.byte``1(``0)">
<summary>
 Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types and <c>ToByte</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.char``1(``0)">
<summary>
 Converts the argument to unicode character based on UTF16 encoding (a direct conversion for all 
 primitive numeric types and <c>ToUIntPtr</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToInt32</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int16``1(``0)">
<summary>
 Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToInt16</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int32``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToInt32</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int64``1(``0)">
<summary>
 Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToInt64</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.nativeint``1(``0)">
<summary>
 Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types and <c>ToIntPtr</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Addition``3(``0,``1)">
<summary>
 Overloaded addition operator (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Multiply``3(``0,``1)">
<summary>
 Overloaded multiplication operator (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Subtraction``3(``0,``1)">
<summary>
 Overloaded subtraction operator (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_UnaryNegation``1(``0)">
<summary>
 Overloaded unary negation (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.sbyte``1(``0)">
<summary>
 Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types and <c>ToSByte</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.uint16``1(``0)">
<summary>
 Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToUInt16</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.uint32``1(``0)">
<summary>
 Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToUInt32</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.uint64``1(``0)">
<summary>
 Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToUInt64</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.unativeint``1(``0)">
<summary>
 Converts the argument to unsigned native integer. This is a direct conversion for all 
 primitive numeric types and <c>ToUIntPtr</c> method otherwise)
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Checked">
<summary>
 This module contains the basic arithmetic operations with overflow checks.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AbsDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AcosDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AsinDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Atan2Dynamic``2(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AtanDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CeilingDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CosDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CoshDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.ExpDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.FloorDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice``1(``0[]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Get a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice2D``1(``0[,]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Get a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3D``1(``0[,,]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Get a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4D``1(``0[,,,]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Get a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetStringSlice(System.String,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Get a slice from a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Log10Dynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.LogDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowByte(System.Byte,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'byte'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDecimal(System.Decimal,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'decimal'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDouble(System.Double,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'float'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDynamic``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowGeneric``1(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt16(System.Int16,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int16'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt32(System.Int32,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int32'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt64(System.Int64,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int64'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowIntPtr(System.IntPtr,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'nativeint'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSByte(System.SByte,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'sbyte'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSingle(System.Single,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'float32'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt16(System.UInt16,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint16'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt32(System.UInt32,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint32'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt64(System.UInt64,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint64'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUIntPtr(System.UIntPtr,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'unativeint'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeByte(System.Byte,System.Byte,System.Byte)">
<summary>
 Generate a range of byte values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeChar(System.Char,System.Char)">
<summary>
 Generate a range of char values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeDouble(System.Double,System.Double,System.Double)">
<summary>
 Generate a range of float values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeGeneric``1(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0,``0)">
<summary>
 Generate a range of values using the given zero, add, start, step and stop values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt16(System.Int16,System.Int16,System.Int16)">
<summary>
 Generate a range of int16 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt32(System.Int32,System.Int32,System.Int32)">
<summary>
 Generate a range of integers  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt64(System.Int64,System.Int64,System.Int64)">
<summary>
 Generate a range of int64 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeIntPtr(System.IntPtr,System.IntPtr,System.IntPtr)">
<summary>
 Generate a range of nativeint values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSByte(System.SByte,System.SByte,System.SByte)">
<summary>
 Generate a range of sbyte values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSingle(System.Single,System.Single,System.Single)">
<summary>
 Generate a range of float32 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeStepGeneric``2(``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},``1,``0,``1)">
<summary>
 Generate a range of values using the given zero, add, start, step and stop values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt16(System.UInt16,System.UInt16,System.UInt16)">
<summary>
 Generate a range of uint16 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt32(System.UInt32,System.UInt32,System.UInt32)">
<summary>
 Generate a range of uint32 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt64(System.UInt64,System.UInt64,System.UInt64)">
<summary>
 Generate a range of uint64 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUIntPtr(System.UIntPtr,System.UIntPtr,System.UIntPtr)">
<summary>
 Generate a range of unativeint values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RoundDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice``1(``0[]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},``0[]`1)">
<summary>
 Set a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice2D``1(``0[,]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},``0[,]`1)">
<summary>
 Set a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3D``1(``0[,,]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},``0[,,]`1)">
<summary>
 Set a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4D``1(``0[,,,]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},``0[,,,]`1)">
<summary>
 Set a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SignDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinhDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SqrtDynamic``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanhDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TruncateDynamic``1(``0)">

</member>
<member name="T:Microsoft.FSharp.Core.Operators.OperatorIntrinsics">
<summary>
 A module of compiler intrinsic functions for efficient implementations of F# integer ranges
 and dynamic invocations of other F# operators
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.defaultof``1">
<summary>
 Generate a defult value for any type. This is null for reference types, 
 For structs, this is struct value where all fields have the default value. 
 This function is unsafe in the sense that some F# values do not have proper <c>null</c> values.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Unchecked">
<summary>
 This module contains basic operations which do not apply runtime and/or static checks
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators">
<summary>
 Basic F# Operators. This module is automatically opened in all F# code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3.Invoke(``0,``1)">
<summary>
 Invoke the optimized function value with two curried arguments 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3.Adapt(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}})">
<summary>
 Adapt an F# first class function value to be an optimized function value that can 
 accept two curried arguments without intervening execution. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3..ctor">
<summary>
 Construct an optimized function value that can accept two curried 
 arguments without intervening execution.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3">
<summary>
 The .NET type used to represent F# function values that accept
 two iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4.Invoke(``0,``1,``2)">
<summary>
 Invoke an F# first class function value that accepts three curried arguments 
 without intervening execution
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4.Adapt(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}})">
<summary>
 Adapt an F# first class function value to be an optimized function value that can 
 accept three curried arguments without intervening execution. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4..ctor">
<summary>
 Construct an optimized function value that can accept three curried 
 arguments without intervening execution.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4">
<summary>
 The .NET type used to represent F# function values that accept
 three iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5.Invoke(``0,``1,``2,``3)">
<summary>
 Invoke an F# first class function value that accepts four curried arguments 
 without intervening execution
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5.Adapt(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.FastFunc`2{``3,``4}}}})">
<summary>
 Adapt an F# first class function value to be an optimized function value that can 
 accept four curried arguments without intervening execution. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5..ctor">
<summary>
 Construct an optimized function value that can accept four curried 
 arguments without intervening execution.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5">
<summary>
 The .NET type used to represent F# function values that accept
 four iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6.Invoke(``0,``1,``2,``3,``4)">
<summary>
 Invoke an F# first class function value that accepts five curried arguments 
 without intervening execution
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6.Adapt(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.FastFunc`2{``3,Microsoft.FSharp.Core.FastFunc`2{``4,``5}}}}})">
<summary>
 Adapt an F# first class function value to be an optimized function value that can 
 accept five curried arguments without intervening execution. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6..ctor">
<summary>
 Construct an optimized function value that can accept five curried 
 arguments without intervening execution.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6">
<summary>
 The .NET type used to represent F# function values that accept
 five iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures">
<summary>
 An implementation module used to hold some private implementations of function
 value invocation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.bind``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Core.Option`1{``0})">
 <c>bind f inp</c> evaluates to <c>match inp with None -> None | Some x -> f x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.count``1(Microsoft.FSharp.Core.Option`1{``0})">
 <c>length inp</c> evaluates to <c>match inp with None -> 0 | Some _ -> 1</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
 <c>exists p inp</c> evaluates to <c>match inp with None -> false | Some x -> p x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
 <c>filter p inp</c> evaluates to <c>match inp with None -> None | Some x -> if p x then inp else None</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.fold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.Option`1{``1})">
 <c>fold_left f s inp</c> evaluates to <c>match inp with None -> s | Some x -> f s x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.foldBack``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Core.Option`1{``0},``1)">
 <c>fold_right f inp s</c> evaluates to "match inp with None -> s | Some x -> f x s"
</member>
<member name="M:Microsoft.FSharp.Core.Option.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.Option`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Core.Option.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Core.Option`1{``0},``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Option.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Core.Option.forall``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
 <c>forall p inp" evaluates to "match inp with None -> true | Some x -> p x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.get``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Gets the value associated with the option.  If the option is None then
 raises ArgumentException
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.isNone``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Returns true if the option is None
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.isSome``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Returns true if the option is not None
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.is_none``1(Microsoft.FSharp.Core.Option`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Core.Option.is_some``1(Microsoft.FSharp.Core.Option`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Core.Option.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Option`1{``0})">
 <c>iter f inp</c> executes <c>match inp with None -> () | Some x -> f x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.length``1(Microsoft.FSharp.Core.Option`1{``0})">
 <c>filter p inp</c> evaluates to <c>match inp with None -> None | Some x -> if p x then inp else None</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.Option`1{``0})">
 <c>map f inp</c> evaluates to <c>match inp with None -> None | Some x -> Some (f x)</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
 <c>partition p inp</c> evaluates to 
 <c>match inp with None -> None,None | Some x -> if p x then inp,None else None,inp</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.to_array``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Convert the option to an array of length 0 or 1
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.to_list``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Convert the option to a list of length 0 or 1
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Option">
<summary>
 Basic operations on options.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.collect(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.String},System.String)">
<summary>
 Build a new string whose characters are the results of applying the function <c>mapping</c>
 to each of the characters of the input string and concatenating the resulting
 strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.concat(System.String,System.Collections.Generic.IEnumerable`1{System.String})">
<summary>
 Return a new string made by concatenating the given strings
 with separator 'sep', i.e. 'a1 + sep + ... + sep + aN'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.exists(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 Test if any character of the string satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.for_all(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Boolean},System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.String.forall(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 Test if all characters in the string satisfy the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.init(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.String})">
<summary>
 Build a new string whose characters are the results of applying the function <c>mapping</c>
 to each index from <c>0</c> to <c>count-1</c> and concatenating the resulting
 strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.iter(Microsoft.FSharp.Core.FastFunc`2{System.Char,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
 Apply the function <c>action</c> to each character in the string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.iteri(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Char,Microsoft.FSharp.Core.Unit}},System.String)">
<summary>
 Apply the function <c>action</c> to the index of each character in the string and the character itself.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.length(System.String)">
<summary>
 Return the length of the string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.map(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Char},System.String)">
<summary>
 Build a new string whose characters are the results of applying the function <c>mapping</c>
 to each of the characters of the input string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.map_concat(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.String},System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.String.mapi(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Char}},System.String)">
<summary>
 Build a new string whose characters are the results of applying the function <c>mapping</c>
 to each character in the string and the character itself.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.replicate(System.Int32,System.String)">
<summary>
 Return a string by concatenating <c>count</c> instances of <c>str</c>.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.String">
<summary>
 Functional programming operators for string processing.  Further string operations
 are available via the member functions on strings and other functionality in
  <a href="http://msdn2.microsoft.com/en-us/library/system.string.aspx">System.String</a> 
 and <a href="http://msdn2.microsoft.com/library/system.text.regularexpressions.aspx">System.Text.RegularExpressions</a> types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_UnaryPlus(Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the given big integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_UnaryNegation(Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the negation of a big integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Subtraction(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the difference of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_RangeStep(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Generate a range of big integers, with a step
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Range(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Generate a range of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Multiply(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the product of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Modulus(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the modulus of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_LessThanOrEqual(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_LessThan(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Inequality(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_GreaterThanOrEqual(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_GreaterThan(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Equality(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Division(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the ratio of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Addition(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the sum of two big integers
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigInt.Zero">
<summary>
 Get the big integer for zero
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigInt.Sign">
<summary>
 Return the sign of a big integer: 0, +1 or -1
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigInt.One">
<summary>
 Get the big integer for one
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigInt.IsZero">
<summary>
 Return true if a big integer is 'zero'
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigInt.IsOne">
<summary>
 Return true if a big integer is 'one'
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.ToString">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.ToInt64(Microsoft.FSharp.Math.BigInt)">
<summary>
 Convert a big integer to a 64-bit signed integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.ToInt32(Microsoft.FSharp.Math.BigInt)">
<summary>
 Convert a big integer to a 32-bit signed integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.ToDouble(Microsoft.FSharp.Math.BigInt)">
<summary>
 Convert a big integer to a floating point number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Pow(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return n^m for two big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Parse(System.String)">
<summary>
 Parse a big integer from a string format
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.GetHashCode">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Gcd(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the greatest common divisor of two big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Factorial(Microsoft.FSharp.Math.BigInt)">
<summary>
 Compute the factorial function as a big integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.DivRem(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Compute the ratio and remainder of two big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Abs(Microsoft.FSharp.Math.BigInt)">
<summary>
 Compute the absolute value of a big integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt..ctor(System.Int32)">
<summary>
 Construct a BigInt value for the given integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt..ctor(System.Int64)">
<summary>
 Construct a BigInt value for the given 64-bit integer
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.BigInt">
<summary>
 The type of arbitrary-sized integers
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.BigNat">
<summary>
 Abstract internal type
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.bigint">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.IsZero(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.add(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.bits(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.compare(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.div(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.divmod(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.equal(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.factorial(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.get_small(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.gt(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.gte(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.hash(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.hcf(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.isOne(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.isZero(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.is_small(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.lt(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.lte(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.max(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.min(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.mul(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.of_int64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.of_string(System.String)">

</member>
<member name="P:Microsoft.FSharp.Math.BigNatModule.one">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.pow(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.powi(Microsoft.FSharp.Math.BigNat,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.rem(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.scale(System.Int32,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.sub(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.to_float(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.to_string(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.to_uint32(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.to_uint64(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="P:Microsoft.FSharp.Math.BigNatModule.two">

</member>
<member name="P:Microsoft.FSharp.Math.BigNatModule.zero">

</member>
<member name="T:Microsoft.FSharp.Math.BigNatModule">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.add``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32)">
<summary>
 Return a typed native pointer by adding index * sizeof&lt;'T&gt; to the 
 given input pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.get``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32)">
<summary>
 Dereference the typed native pointer computed by adding index * sizeof&lt;'T&gt; to the 
 given input pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.of_array``1(``0[]`1,System.Int32)">
<summary>
 Get the address of an element of a pinned array
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.of_array2``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 Get the address of an element of a pinned 2-dimensional array
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.of_nativeint``1(System.IntPtr)">
<summary>
 Return a typed native pointer for a given machine address
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.read``1(Microsoft.FSharp.Core.nativeptr`1{``0})">
<summary>
 Dereference the given typed native pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.set``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32,``0)">
<summary>
 Assign the <c>value</c> into the memory location referenced by the typed native 
 pointer computed by adding index * sizeof&lt;'T&gt; to the given input pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.to_nativeint``1(Microsoft.FSharp.Core.nativeptr`1{``0})">
<summary>
 Return a machine address for a given typed native pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.write``1(Microsoft.FSharp.Core.nativeptr`1{``0},``0)">
<summary>
 Assign the <c>value</c> into the memory location referenced by the given typed native pointer 
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativePtr">
<summary>
 Contains operations on native pointers.  Use of these operators may
 result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.permute``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Int32},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.zeroCreate``1(System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.Array">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.collect``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Collections.FSharpList`1{``1}},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.concat``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.FSharpList`1{``0}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.forall``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.of_array``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.rev``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.sortWith``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.to_array``1(Microsoft.FSharp.Collections.FSharpList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.unzip``2(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.unzip3``3(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Core.Tuple`3{``0,``1,``2}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.zip``2(Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.zip3``3(Microsoft.FSharp.Collections.FSharpList`1{``0},Microsoft.FSharp.Collections.FSharpList`1{``1},Microsoft.FSharp.Collections.FSharpList`1{``2})">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.List">

</member>
<member name="P:Microsoft.FSharp.Quotations.Expr.Type">
<summary>
 Returns type of an expression
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Expr.CustomAttributes">
<summary>
 Returns the custom attributes of an expression
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.WhileLoop(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents a while loop
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.VarSet(Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents setting a mutable variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Var(Microsoft.FSharp.Quotations.Var)">
<summary>
 Build an expression that represents a variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Value(System.Object,System.Type)">
<summary>
 Build an expression that represents a constant value of a particular type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Value``1(``0)">
<summary>
 Build an expression that represents a constant value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.UnionCaseTest(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Reflection.UnionCaseInfo)">
<summary>
 Build an expression that represents a test of a value is of a particular union case
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TypeTest(Microsoft.FSharp.Quotations.Expr,System.Type)">
<summary>
 Build an expression that represents a type test
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TupleGet(Microsoft.FSharp.Quotations.Expr,System.Int32)">
<summary>
 Build an expression that represents getting a field of a tuple
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TryWith(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents a try/with construct for exception filtering and catching 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TryGetReflectedDefinition(System.Reflection.MethodBase)">
<summary>
 Try and find a stored reflection definition for the given method. Stored reflection
 definitions are added to an F# assembly through the use of the [&lt;ReflectedDefinition&gt;] attribute.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TryFinally(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents a try/finally construct 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Substitute(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Substitute through the given expression using the given functions
 to map variables to new values.  The functions must give consistent results
 at each application.  Variable renaming may occur on the target expression
 if variable capture occurs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Sequential(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents the sequential execution of one expression followed by another
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.RegisterReflectedDefinitions(System.Reflection.Assembly,System.String,System.Byte[]`1)">
<summary>
 Permit interactive environments such as F# Interactive
 to explicitly register new pickled resources that represent persisted 
 top level definitions. The string indicates a unique name for the resources
 being added. The format for the bytes is the encoding generated by the F# compiler.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Quote(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents a nested quotation literal
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.PropSet(Microsoft.FSharp.Quotations.Expr,System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents writing to a property of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.PropSet(System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents writing to a static property 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.PropGet(Microsoft.FSharp.Quotations.Expr,System.Reflection.PropertyInfo,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents reading a property of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.PropGet(System.Reflection.PropertyInfo,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents reading a static property 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewUnionCase(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents the creation of a union case value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewTuple(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents the creation of an F# tuple value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewRecord(System.Type,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build record-construction expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewObject(System.Reflection.ConstructorInfo,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents the invocation of an object constructor
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewDelegate(System.Type,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Var},Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents the creation of a delegate value for the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewArray(System.Type,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents the creation of an array value initialized with the given elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.LetRec(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr}},Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build recursives expressions associated with 'let rec' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Let(Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions associated with 'let' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Lambda(Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents the constrution of an F# function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.IfThenElse(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build 'if ... then ... else' expressions    
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.GlobalVar``1(System.String)">
<summary>
 Fetch or create a new variable with the given name and type from a global pool of shared variables
 indexed by name and type. The type is given by the expicit or inferred type parameter
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.GetFreeVars">
<summary>
 Get the free expression variables of an expression as a list
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.ForIntegerRangeLoop(Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build a 'for i = ... to ... do ...' expression that represent loops over integer ranges
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.FieldSet(System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents writing to a static field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.FieldSet(Microsoft.FSharp.Quotations.Expr,System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents writing to a field of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.FieldGet(System.Reflection.FieldInfo)">
<summary>
 Build an expression that represents the access of a static field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.FieldGet(Microsoft.FSharp.Quotations.Expr,System.Reflection.FieldInfo)">
<summary>
 Build an expression that represents the access of a field of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Deserialize(System.Type,Microsoft.FSharp.Collections.FSharpList`1{System.Type},Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr},System.Byte[]`1)">
<summary>
 This function is called automatically when quotation syntax (&lt;@ @&gt;) and related typed-expression
 quotations are used. The bytes are a pickled binary representation of an unlinked form of the qutoed expression,
 and the System.Type argument is any type in the assembly where the quoted
 expression occurs, i.e. it helps scope the interpretation of the cross-assembly
 references in the bytes.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.DefaultValue(System.Type)">
<summary>
 Build an expression that represents the invocation of a default object constructor
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Coerce(Microsoft.FSharp.Quotations.Expr,System.Type)">
<summary>
 Build an expression that represents the coercion of an expression to a type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Cast``1(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Return a new typed expression given an underlying runtime-typed expression.
 A type annotation is usually required to use this function, and 
 using an incorrect type annotation may result in a later runtime exception.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Call(System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents a call to an static method or module-bound function
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Call(Microsoft.FSharp.Quotations.Expr,System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents a call to an instance method associated with an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Applications(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents the application of a first class function value to multiple arguments
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Application(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents the application of a first class function value to a single argument
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.AddressSet(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents setting the value held at a particular address
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.AddressOf(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents getting the address of a value
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Expr">
<summary>
 Quoted expressions annotated with System.Type values. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Expr`1.Raw">
<summary>
 Get the raw expression associated with this type-carrying expression
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Expr`1">
<summary>
 Type-carrying quoted expressions.  Expressions are generated either
 by quotations in source text or programatically
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Var.Type">
<summary>
 The type associated with the variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Var.Name">
<summary>
 The declared name of the variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Var.IsMutable">
<summary>
 Indicates if the variable represents a mutable storage location
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Var.Global(System.String,System.Type)">
<summary>
 Fetch or create a new variable with the given name and type from a global pool of shared variables
 indexed by name and type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Var..ctor(System.String,System.Type,Microsoft.FSharp.Core.Option`1{System.Boolean})">
<summary>
 Create a new variable with the given name, type and mutability
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Var">
<summary>
 Information at the binding site of a variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|AndAlso|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions of the form <c>a &amp;&amp; b</c> 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Applications|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent the application of a (possibly curried or tupled) first class function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Bool|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant boolean expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Byte|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant byte expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Char|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant unicode character expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Double|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant 64-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Int16|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant int16 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Int32|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant int32 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Int64|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant int64 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Lambdas|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a (possibly curried or tupled) first class function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|MethodWithReflectedDefinition|_|(System.Reflection.MethodBase)">
<summary>
 An active pattern to recognize methods that have an associated ReflectedDefinition
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|OrElse|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions of the form <c>a || b</c> 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|PropertyGetterWithReflectedDefinition|_|(System.Reflection.PropertyInfo)">
<summary>
 An active pattern to recognize property getters or values in modules that have an associated ReflectedDefinition
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|PropertySetterWithReflectedDefinition|_|(System.Reflection.PropertyInfo)">
<summary>
 An active pattern to recognize property setters that have an associated ReflectedDefinition
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|SByte|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant signed byte expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Single|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant 32-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|SpecificCall|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 A parameterized active pattern to recognize calls to a specified function or method
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|String|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant string expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|UInt16|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant unsigned int16 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|UInt32|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant unsigned int32 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|UInt64|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant unsigned int64 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Unit|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize <c>()</c> constant expressions
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.DerivedPatterns">
<summary>
 Contains a set of derived F# active patterns to analyze F# expression objects
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShape.RebuildShapeCombination(System.Object,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Re-build combination expressions. The first parameter should be an object
 returned by the <c>ShapeCombination</c> case of the active pattern in this module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShape.|ShapeVar|ShapeLambda|ShapeCombination|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern that performs a complete decomposition viewing the expression tree as a binding structure
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.ExprShape">
<summary>
 Active patterns for traversing, visiting, rebuilding and tranforming expressions in a generic way
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|AddressOf|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent getting the address of a value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|AddressSet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent setting the value held at an address 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Application|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent applications of first class function values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Call|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent calls to static and instance methods, and functions defined in modules
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Coerce|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent coercions from one type to another
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|DefaultValue|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent invocations of a default constructor of a struct
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|FieldGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent getting a static or instance field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|FieldSet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent setting a static or instance field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|ForIntegerRangeLoop|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent loops over integer ranges
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|IfThenElse|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent conditionals
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Lambda|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent first class function values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|LetRec|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent recursive let bindings of one or more variables
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Let|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent let bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewArray|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent the construction of arrays 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewDelegate|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent construction of delegate values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewObject|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent invocation of object constructors
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewRecord|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent construction of record values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewTuple|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent construction of tuple values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewUnionCase|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent construction of particular union case values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|PropGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent the read of a static or instance property, or a non-function value declared in a module
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|PropSet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent setting a static or instance property, or a non-function value declared in a module
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Quote|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a nested quotation literal
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Sequential|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent sequential exeuction of one expression followed by another
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|TryFinally|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a try/finally construct 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|TryWith|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a try/with construct for exception filtering and catching 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|TupleGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent getting a tuple field
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|TypeTest|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a dynamic type test
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|UnionCaseTest|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a test if a value is of a particular union case
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Value|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a constant value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|VarSet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent setting a mutable variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Var|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|WhileLoop|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent while loops 
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Patterns">
<summary>
 Contains a set of primitive F# active patterns to analyze F# expression objects
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeTupleType(System.Type[]`1)">
<summary>
 Return a <c>System.Type</c> representing an F# tuple type with the given element types
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeFunctionType(System.Type,System.Type)">
<summary>
 Return a <c>System.Type</c> representing the F# function type with the given domain and range
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsUnion(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Return true if the <c>typ</c> is a representation of an F# union type or the runtime type of a value of that type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsTuple(System.Type)">
<summary>
 Return true if the <c>typ</c> is a representation of an F# tuple type 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsRecord(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Return true if the <c>typ</c> is a representation of an F# record type 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsModule(System.Type)">
<summary>
 Return true if the <c>typ</c> is a <c>System.Type</c> value corresponding to the compiled form of an F# module 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsFunction(System.Type)">
<summary>
 Return true if the <c>typ</c> is a representation of an F# function type or the runtime type of a closure implementing an F# function type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsExceptionRepresentation(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Return true if the <c>typ</c> is a representation of an F# exception declaration
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetUnionCases(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Get the cases of a union type.

 Assumes the given type is a union type. If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetTupleElements(System.Type)">
<summary>
 Get the tuple elements from the representation of an F# tuple type  
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetRecordFields(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from a record value, in declaration order

 Assumes the given input is a record value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetFunctionElements(System.Type)">
<summary>
 Get the domain and range types from an F# function type  or from the runtime type of a closure implementing an F# type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetExceptionFields(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from an F# exception declaration, in declaration order

 Assumes <c>exceptionType</c> is an exception representation type. If not, ArgumentException is raised.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpType">
<summary>
 Contains operations associated with constructing and analyzing F# types such as records, unions and tuples
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagReader(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Assumes the given type is a union type. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function is more efficient than calling GetUnionCase
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagMemberInfo(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a property or static method for reading an integer representing the case tag of a union type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionReader(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for reading all the fields for a particular discriminator case of a union type

 Using the computed function will typically be faster than executing a corresponding call to GetFields
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructorInfo(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 A method that constructs objects of the given case
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructor(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for constructing a discriminated union value for a particular union case. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleReader(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTuplePropertyInfo(System.Type,System.Int32)">
<summary>
 Get information that indicates how to read a field of a tuple
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructorInfo(System.Type)">
<summary>
 Get a method that constructs objects of the given tuple type. 
 For small tuples, no additional typoe will be returned.
 
 For large tuples, an additional type is returned indicating that
 a nested encoding has been used for the tuple type. In this case
 the suffix portion of the tuple type has the given type and an
 object of this type must be created and passed as the last argument 
 to the ConstructorInfo. A recursive call to PreComputeTupleConstructorInfo 
 can be used to determine the constructor for that the suffix type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructor(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordReader(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.

 Assumes the given type is a RecordType. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordFieldReader(System.Reflection.PropertyInfo)">
<summary>
 Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructorInfo(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Get a ConstructorInfo for a record type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructor(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for constructing a record value. 

 Assumes the given type is a RecordType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeUnion(Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[]`1,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Create a union case value
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(System.Object[]`1,System.Type)">
<summary>
 Create an instance of a tuple type

 Assumes at least one element is given. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeRecord(System.Type,System.Object[]`1,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Create an instance of a record type

 Assumes the given input is a record type. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeFunction(System.Type,Microsoft.FSharp.Core.FastFunc`2{System.Object,System.Object})">
<summary>
 Build a typed function from object from a dynamic function implementation
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetUnionFields(System.Object,System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Identify the union case and its fields for an object

 Assumes the given input is a union case value. If not, ArgumentException is raised.

 If the type is not given, then the runtime type of the input object is used to identify the
 relevant union type. The type should always be given if the input object may be null. For example, 
 option values may be represented using the 'null'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleFields(System.Object)">
<summary>
 Read all fields from a tuple 

 Assumes the given input is a tuple value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleField(System.Object,System.Int32)">
<summary>
 Read a field from a tuple value

 Assumes the given input is a tuple value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordFields(System.Object,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from a record value

 Assumes the given input is a record value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordField(System.Object,System.Reflection.PropertyInfo)">
<summary>
 Read a field from a record value

 Assumes the given input is a record value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetExceptionFields(System.Object,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from a value built using an instance of an F# exception declaration

 Assumes the given input is an F# exception value. If not, ArgumentException is raised.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpValue">
<summary>
 Contains operations associated with constructing and analyzing values associated with F# types such as records, unions and tuples
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Tag">
<summary>
 The integer tag for the case
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Name">
<summary>
 The name of the case
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.DeclaringType">
<summary>
 The type in which the case occurs
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetFields">
<summary>
 The fields associated with the case, represented by PropertyInfo 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes">
<summary>
 Return the custom attributes associated with the case
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes(System.Type)">
<summary>
 Return the custom attributes associated with the case matching the given attribute type
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.UnionCaseInfo">
<summary>
Represents a case of a discriminated union type
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Format`4">
<summary>
 Type of a formatting expression
     'Printer : function type generated by printf
     'State: type argument passed to %a formatters
     'Residue: value generated by the overall printf action (e.g. sprint generates a string)
     'Result: value generated after post processing (e.g. failwithf generates a string internally then raises an exception)
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Format`5">
<summary>
 Type of a formatting expression
     'Printer : function type generated by printf
     'State: type argument passed to %a formatters
     'Residue: value generated by the overall printf action (e.g. sprint generates a string)
     'Result: value generated after post processing (e.g. failwithf generates a string internally then raises an exception)
     'Tuple: tuple of values generated by scan or match
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.PrintfFormat`4.Value">
<summary>
 The raw text of the format string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.PrintfFormat`4..ctor(System.String)">
<summary>
 Construct a format string 
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.PrintfFormat`4">
<summary>
 Type of a formatting expression.
     'Printer : function type generated by printf
     'State: type argument passed to %a formatters
     'Residue: value generated by the overall printf action (e.g. sprint generates a string)
     'Result: value generated after post processing (e.g. failwithf generates a string internally then raises an exception)
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.PrintfFormat`5..ctor(System.String)">
<summary>
 Construct a format string 
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.PrintfFormat`5">
<summary>
 Type of a formatting expression.
     'Printer : function type generated by printf
     'State: type argument passed to %a formatters
     'Residue: value generated by the overall printf action (e.g. sprint generates a string)
     'Result: value generated after post processing (e.g. failwithf generates a string internally then raises an exception)
     'Tuple: tuple of values generated by scan or match
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.BuilderFormat`1">
<summary>
 Represents a statically-analyzed format associated with writing to a <c>System.Text.StringBuilder</c>. The type parameter indicates the
 arguments and return type of the format operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.BuilderFormat`2">
<summary>
 Represents a statically-analyzed format associated with writing to a <c>System.Text.StringBuilder</c>. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.StringFormat`1">
<summary>
 Represents a statically-analyzed format when formatting builds a string. The type parameter indicates the
 arguments and return type of the format operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.StringFormat`2">
<summary>
 Represents a statically-analyzed format when formatting builds a string. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.TextWriterFormat`1">
<summary>
 Represents a statically-analyzed format associated with writing to a <c>System.IO.TextWriter</c>. The type parameter indicates the
 arguments and return type of the format operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.TextWriterFormat`2">
<summary>
 Represents a statically-analyzed format associated with writing to a <c>System.IO.TextWriter</c>. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.bprintf``1(System.Text.StringBuilder,Microsoft.FSharp.Text.PrintfFormat`4{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a <c>System.Text.StringBuilder</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.eprintf``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stderr
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.eprintfn``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stderr, adding a newline 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.failwithf``2(Microsoft.FSharp.Text.PrintfFormat`4{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Print to a string buffer and raise an exception with the given
 result. Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.fprintf``1(System.IO.TextWriter,Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a text writer or an OCaml-compatible channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.fprintfn``1(System.IO.TextWriter,Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a text writer or an OCaml-compatible channel, adding a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kbprintf``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},System.Text.StringBuilder,Microsoft.FSharp.Text.PrintfFormat`4{``1,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 bprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kfprintf``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},System.IO.TextWriter,Microsoft.FSharp.Text.PrintfFormat`4{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 fprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kprintf``2(Microsoft.FSharp.Core.FastFunc`2{System.String,``0},Microsoft.FSharp.Text.PrintfFormat`4{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
<summary>
 printf, but call the given 'final' function to generate the result.
 For example, these let the printing force a flush after all output has 
 been entered onto the channel, but not before. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.ksprintf``2(Microsoft.FSharp.Core.FastFunc`2{System.String,``0},Microsoft.FSharp.Text.PrintfFormat`4{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
<summary>
 sprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.ktwprintf``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},System.IO.TextWriter,Microsoft.FSharp.Text.PrintfFormat`4{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 twprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.printf``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stdout
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.printfn``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stdout, adding a newline 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.sprintf``1(Microsoft.FSharp.Text.PrintfFormat`4{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
 Print to a string via an internal string buffer and return 
 the result as a string.  Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.twprintf``1(System.IO.TextWriter,Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to any subtype of the .NET type System.IO.TextWriter
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.twprintfn``1(System.IO.TextWriter,Microsoft.FSharp.Text.PrintfFormat`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to any subtype of the .NET type System.IO.TextWriter, and add a newline
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf">
<summary>
 Extensible printf-style formatting for numbers and other datatypes

 Format specifications are strings with "%" markers indicating format 
 placeholders. Format placeholders consist of:
  <c>
    %[flags][width][.precision][type]
  </c>
 where the type is interpreted as follows:
  <c>
     %b:         bool, formatted as "true" or "false"
     %s:         string, formatted as its unescaped contents
     %d, %i:     any basic integer type formatted as a decimal integer, signed if the basic integer type is signed.
     %u:         any basic integer type formatted as an unsigned decimal integer
     %x, %X, %o: any basic integer type formatted as an unsigned hexadecimal 
                 (a-f)/Hexadecimal (A-F)/Octal integer
 
     %e, %E, %f, %F, %g, %G: 
                 any basic floating point type (float,float32) formatted
                 using a C-style floating point format specifications, i.e
 
     %e, %E: Signed value having the form [-]d.dddde[sign]ddd where 
                 d is a single decimal digit, dddd is one or more decimal
                 digits, ddd is exactly three decimal digits, and sign 
                 is + or -
 
     %f:     Signed value having the form [-]dddd.dddd, where dddd is one
                 or more decimal digits. The number of digits before the 
                 decimal point depends on the magnitude of the number, and 
                 the number of digits after the decimal point depends on 
                 the requested precision.
 
     %g, %G: Signed value printed in f or e format, whichever is 
                 more compact for the given value and precision.
 
 
    %M:      System.Decimal value
 
    %O:      Any value, printed by boxing the object and using it's ToString method(s)
 
    %A:      Any value, printed by using Microsoft.FSharp.Text.StructuredPrintfImpl.Display.any_to_string with the default layout settings 
 
    %a:      A general format specifier, requires two arguments:
                 (1) a function which accepts two arguments:
                     (a) a context parameter of the appropriate type for the
                         given formatting function (e.g. an #System.IO.TextWriter)
                     (b) a value to print
                         and which either outputs or returns appropriate text.
 
                 (2) the particular value to print
 
 
    %t:      A general format specifier, requires one argument:
                 (1) a function which accepts a context parameter of the
                     appropriate type for the given formatting function (e.g. 
                     an System.IO.TextWriter)and which either outputs or returns 
                     appropriate text.

  Basic integer types are:
     byte,sbyte,int16,uint16,int32,uint32,int64,uint64,nativeint,unativeint
  Basic floating point types are:
     float, float32

 The following format patterns are accepted but a warning is printed:

     %h(d|u|x|X|o)
     %l(d|u|x|X|o)

  The following format patterns are now deprecated:

     %Ld, %Li, %Lu, %Lx, %LX, %Lo: same, but an int64
     %nd, %ni, %nu, %nx, %nX, %no: same, but a nativeint
     %Ud, %Ui, %Uu, %Ux, %UX, %Uo: same, but an unsigned int32 (uint32)
     %ULd, %ULi, %ULu, %ULx, %ULX, %ULo: same, but an unsigned int64 (uint64)
     %Und, %Uni, %Unu, %Unx, %UnX, %Uno: same, but an unsigned nativeint (unativeint)
 </c>
 The optional width is an integer indicating the minimal width of the
 result. For instance, %6d prints an integer, prefixing it with spaces
 to fill at least 6 characters. If width is '*', then an extra integer
 argument is taken to specify the corresponding width.
 <c>
     any number
     '*': 
 </c>
 Valid flags are:
 <c>
     0: add zeros instead of spaces to make up the required width
     '-': left justify the result within the width specified
     '+': add a '+' character if the number is positive (to match a '-' sign 
          for negatives)
     ' ': add an extra space if the number is positive (to match a '-' 
              sign for negatives)
 </c>
 The printf '#' flag is invalid and a compile-time error will be reported if it is used.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions.Default">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the 'fsi'
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 <example>
 From F# Interactive the default settings can be adjusted using, for example, 
 <pre>
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 </pre>
 </example>
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Layout">
<summary>
 Data representing structured layouts of terms.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the "[1;2]" notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.layout_to_string(Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.printf_any_to_string``1(Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions,System.Reflection.BindingFlags,``0)">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Display">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveListL(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Layout list vertically.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.braceL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap braces around layout.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.bracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.commaListL(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.isEmptyL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.leftL(System.String)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.listL``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Collections.FSharpList`1{``0})">
<summary>
 Layout like an F# list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAt(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=1 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_DollarDollar(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, unbreakable. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_PlusPlus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.optionL``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.rightL(System.String)">
<summary>
 An string which is right parenthesis (no space on it's left).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.semiListL(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepL(System.String)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepListL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.spaceListL(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a space separated list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.squareBracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap square brackets around layout.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Core.Tuple`2{System.String,System.String}},Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tupleL(Microsoft.FSharp.Collections.FSharpList`1{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Form tuple of layouts.            
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}}},``1,System.Int32)">
<summary>
 For limitting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.wordL(System.String)">
<summary>
 An string leaf 
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
</members>
</doc>
